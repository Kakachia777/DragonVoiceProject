#!/usr/bin/env python3
"""
DragonVoiceProject - Futuristic GUI Interface

This module provides a modern, futuristic user interface for the DragonVoiceProject,
allowing users to monitor and control the voice assistant, view query history,
and configure system settings with a sleek, responsive design.

Features:
- Real-time system status visualization
- Query history tracking and management
- Chatbot configuration with visual layout
- Dark mode interface with accent colors
- System tray integration
- Multi-monitor visualization
- Voice command visualization

Requirements:
- customtkinter
- pillow
- pystray
- pyperclip
- pygetwindow
- pyautogui
"""

import os
import sys
import json
import time
import logging
import threading
import webbrowser
import random
import math
from datetime import datetime
from typing import Dict, List, Tuple, Optional, Any, Union
import tkinter as tk
import tkinter.messagebox as messagebox

# Try to import required packages
try:
    import customtkinter as ctk
    from PIL import Image, ImageTk, ImageDraw
    import pyperclip
    import pygetwindow as gw
    import pyautogui
    import pystray
except ImportError as e:
    # We'll handle this error in the GUI itself
    missing_package = str(e).split("'")[1]
    print(f"Missing required package: {missing_package}")
    print(f"Please install it using: pip install {missing_package}")
    
# Local imports
# These will be used to integrate with existing functionality
try:
    from voice_assistant import MultiScreenVoiceAssistant
except ImportError:
    print("Warning: Could not import MultiScreenVoiceAssistant. Some features may be disabled.")
    MultiScreenVoiceAssistant = None

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('dragon_gui.log')
    ]
)
logger = logging.getLogger('DragonVoiceProject.GUI')

# Default configuration path
DEFAULT_CONFIG_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), "config.json")

# Theme definitions
THEMES = {
    "cyberpunk": {
        "name": "Cyberpunk",
        "colors": {
            "bg_dark": "#0D1117",           # Darker background for header/footer
            "bg_medium": "#161B22",         # Medium background for main content
            "bg_light": "#21262D",          # Lighter background for panels
            "bg_glass": "#21262D",          # Semi-transparent glass effect
            "primary": "#58A6FF",           # Primary accent color - electric blue
            "secondary": "#F0883E",         # Secondary accent - cyber orange
            "tertiary": "#7B68EE",          # Tertiary accent - purple
            "accent_green": "#3FB950",      # Success green
            "accent_red": "#F85149",        # Error red
            "accent_yellow": "#F0B72F",     # Warning yellow
            "accent_cyan": "#39C5BB",       # Info cyan
            "text": "#F0F6FC",              # Main text
            "text_secondary": "#8B949E",    # Secondary text
            "success": "#3FB950",           # Success color
            "warning": "#F0B72F",           # Warning color
            "error": "#F85149",             # Error color
            "card_bg": "#1C2128",           # Card background
            "card_border": "#30363D",       # Card border
            "input_bg": "#0D1117",          # Input field background
            "input_border": "#30363D",      # Input field border
            "button_hover": "#1F6FEB",      # Button hover color (for primary)
            "secondary_hover": "#E67E22",   # Button hover color (for secondary)
            "glow_primary": "#58A6FF",      # Glow effect for primary elements
            "glow_secondary": "#F0883E",    # Glow effect for secondary elements
            "grid_line": "#30363D",         # Grid lines
            "shadow": "#000000"             # Shadow color
        },
        "gradients": {
            "header": ["#0D1117", "#161B22"],
            "primary_button": ["#1F6FEB", "#58A6FF"],
            "secondary_button": ["#E67E22", "#F0883E"],
            "success_button": ["#2EA043", "#3FB950"],
            "error_button": ["#DA3633", "#F85149"],
            "card_bg": ["#1C2128", "#21262D"],
            "monitor_primary": ["#1F6FEB", "#58A6FF"],
            "monitor_secondary": ["#2EA043", "#3FB950"],
            "monitor_tertiary": ["#E67E22", "#F0883E"]
        }
    },
    "neon": {
        "name": "Neon Nights",
        "colors": {
            "bg_dark": "#121212",           # Darker background for header/footer
            "bg_medium": "#1E1E1E",         # Medium background for main content
            "bg_light": "#2D2D2D",          # Lighter background for panels
            "bg_glass": "#2D2D2D",          # Semi-transparent glass effect
            "primary": "#00FFFF",           # Primary accent color - cyan
            "secondary": "#FF00FF",         # Secondary accent - magenta
            "tertiary": "#FFFF00",          # Tertiary accent - yellow
            "accent_green": "#00FF00",      # Success green
            "accent_red": "#FF0000",        # Error red
            "accent_yellow": "#FFFF00",     # Warning yellow
            "accent_cyan": "#00FFFF",       # Info cyan
            "text": "#FFFFFF",              # Main text
            "text_secondary": "#AAAAAA",    # Secondary text
            "success": "#00FF00",           # Success color
            "warning": "#FFFF00",           # Warning color
            "error": "#FF0000",             # Error color
            "card_bg": "#1A1A1A",           # Card background
            "card_border": "#333333",       # Card border
            "input_bg": "#121212",          # Input field background
            "input_border": "#333333",      # Input field border
            "button_hover": "#00CCCC",      # Button hover color (for primary)
            "secondary_hover": "#CC00CC",   # Button hover color (for secondary)
            "glow_primary": "#00FFFF",      # Glow effect for primary elements
            "glow_secondary": "#FF00FF",    # Glow effect for secondary elements
            "grid_line": "#333333",         # Grid lines
            "shadow": "#000000"             # Shadow color
        },
        "gradients": {
            "header": ["#121212", "#1E1E1E"],
            "primary_button": ["#00CCCC", "#00FFFF"],
            "secondary_button": ["#CC00CC", "#FF00FF"],
            "success_button": ["#00CC00", "#00FF00"],
            "error_button": ["#CC0000", "#FF0000"],
            "card_bg": ["#1A1A1A", "#2D2D2D"],
            "monitor_primary": ["#00CCCC", "#00FFFF"],
            "monitor_secondary": ["#00CC00", "#00FF00"],
            "monitor_tertiary": ["#CC00CC", "#FF00FF"]
        }
    },
    "midnight": {
        "name": "Midnight Blue",
        "colors": {
            "bg_dark": "#0A192F",           # Darker background for header/footer
            "bg_medium": "#112240",         # Medium background for main content
            "bg_light": "#1A365D",          # Lighter background for panels
            "bg_glass": "#1A365D",          # Semi-transparent glass effect
            "primary": "#64FFDA",           # Primary accent color - teal
            "secondary": "#FF6B6B",         # Secondary accent - coral
            "tertiary": "#A78BFA",          # Tertiary accent - lavender
            "accent_green": "#10B981",      # Success green
            "accent_red": "#EF4444",        # Error red
            "accent_yellow": "#F59E0B",     # Warning yellow
            "accent_cyan": "#06B6D4",       # Info cyan
            "text": "#E2E8F0",              # Main text
            "text_secondary": "#94A3B8",    # Secondary text
            "success": "#10B981",           # Success color
            "warning": "#F59E0B",           # Warning color
            "error": "#EF4444",             # Error color
            "card_bg": "#112240",           # Card background
            "card_border": "#1E3A8A",       # Card border
            "input_bg": "#0A192F",          # Input field background
            "input_border": "#1E3A8A",      # Input field border
            "button_hover": "#4FD1C5",      # Button hover color (for primary)
            "secondary_hover": "#F43F5E",   # Button hover color (for secondary)
            "glow_primary": "#64FFDA",      # Glow effect for primary elements
            "glow_secondary": "#FF6B6B",    # Glow effect for secondary elements
            "grid_line": "#1E3A8A",         # Grid lines
            "shadow": "#000000"             # Shadow color
        },
        "gradients": {
            "header": ["#0A192F", "#112240"],
            "primary_button": ["#4FD1C5", "#64FFDA"],
            "secondary_button": ["#F43F5E", "#FF6B6B"],
            "success_button": ["#059669", "#10B981"],
            "error_button": ["#DC2626", "#EF4444"],
            "card_bg": ["#112240", "#1A365D"],
            "monitor_primary": ["#4FD1C5", "#64FFDA"],
            "monitor_secondary": ["#059669", "#10B981"],
            "monitor_tertiary": ["#F43F5E", "#FF6B6B"]
        }
    }
}

# Default theme
THEME_DARK = THEMES["cyberpunk"]["colors"]
GRADIENTS = THEMES["cyberpunk"]["gradients"]

# Animation durations
ANIMATIONS = {
    "fast": 150,      # Fast animations (150ms)
    "normal": 300,    # Normal animations (300ms)
    "slow": 500       # Slow animations (500ms)
}

# Application version
APP_VERSION = "1.0.0" 

# Add this import for Whisper integration
try:
    from whisper_integration import WhisperRecognizer
    WHISPER_AVAILABLE = True
except ImportError:
    WHISPER_AVAILABLE = False
    
# Add this near the top of the file, before the DragonVoiceGUI class
# Define default color theme
DEFAULT_COLORS = {
    "bg": "#1E1E2E",  # Dark background
    "bg_darker": "#181825",  # Darker background for contrast
    "bg_lighter": "#313244",  # Lighter background for hover effects
    "card_bg": "#242436",  # Background for cards
    "card_bg_lighter": "#2A2A42",  # Lighter background for nested cards
    "text": "#CDD6F4",  # Main text color
    "text_bright": "#FFFFFF",  # Bright text for emphasis
    "text_dim": "#A6ADC8",  # Dimmed text for less important elements
    "accent": "#CBA6F7",  # Purple accent color
    "accent_hover": "#D8B4FF",  # Lighter purple for hover
    "success": "#A6E3A1",  # Green for success messages
    "success_hover": "#B4F4AF",  # Lighter green for hover
    "warning": "#F9E2AF",  # Yellow for warnings
    "warning_hover": "#FFEFBD",  # Lighter yellow for hover
    "error": "#F38BA8",  # Red for errors
    "error_hover": "#FFB3C6",  # Lighter red for hover
    "separator": "#45475A",  # Color for separators
    "scrollbar_bg": "#313244",  # Scrollbar background
    "entry_bg": "#313244",  # Entry field background
    "entry_border": "#45475A",  # Entry field border
    "dropdown_bg": "#313244",  # Dropdown background
    "dropdown_button": "#45475A",  # Dropdown button
    "dropdown_button_hover": "#585B70",  # Dropdown button hover
    "dropdown_menu_bg": "#242436",  # Dropdown menu background
    "cancel_button": "#585B70",  # Cancel button color
    "cancel_hover": "#6C7086",  # Cancel button hover
}

class DragonVoiceGUI:
    """Main GUI class for the DragonVoiceProject application."""
    
    def __init__(self, config_path=DEFAULT_CONFIG_PATH):
        """Initialize the GUI."""
        # Set up logging
        self.setup_logging()
        
        # Store config path
        self.config_path = config_path
        
        # Initialize colors dictionary
        self.colors = DEFAULT_COLORS.copy()
        
        # Load configuration
        self.config = self.load_config()
        
        # Apply theme from config if available
        theme = self.config.get("theme", "dark")
        
        # Create the main window
        self.root = ctk.CTk()
        self.root.title(f"Dragon Voice Project {APP_VERSION}")
        self.root.geometry("1200x800")
        self.root.minsize(800, 600)
        
        # Set icon if available
        try:
            icon_path = os.path.join("src", "assets", "dragon_icon.ico")
            if os.path.exists(icon_path):
                self.root.iconbitmap(icon_path)
        except Exception as e:
            logger.warning(f"Could not set application icon: {e}")
        
        # Apply theme
        self.apply_theme(theme)
        
        # Initialize variables
        self.voice_assistant_running = False
        self.is_muted = False
        self.mic_devices = self.get_available_microphones()
        
        # Set up the main window
        self.setup_main_window()
        
        # Set up keyboard shortcuts
        self.setup_keyboard_shortcuts()
        
        # Set up system tray
        self.setup_system_tray()
        
        # Define save_configuration method
        def save_configuration(self, show_notification=True):
            """Save the configuration to the config file."""
            try:
                # Make sure the theme is saved
                if hasattr(self, 'current_theme'):
                    self.config["theme"] = self.current_theme
                
                # Save the config to file
                with open(self.config_path, "w") as f:
                    json.dump(self.config, f, indent=4)
                
                # Update status
                if show_notification:
                    self.update_status("Configuration saved successfully", level="success")
                    
                    # Show notification
                    self.show_notification(
                        "Configuration saved successfully",
                        title="Configuration Saved",
                        level="success"
                    )
                
                return True
            except Exception as e:
                logger.error(f"Error saving configuration: {e}")
                if show_notification:
                    self.update_status(f"Error saving configuration: {str(e)}", level="error")
                    
                    # Show error notification
                    self.show_notification(
                        f"Error saving configuration: {str(e)}",
                        title="Configuration Error",
                        level="error"
                    )
                
                return False
        
        # Attach the method to the class instance
        self.save_configuration = save_configuration.__get__(self, type(self))
        
        try:
            # Load configuration
            self.config = self.load_config()
            
            # Set theme from config
            if "theme" in self.config:
                self.current_theme = self.config["theme"]
                # Update theme constants without trying to save
                global THEME_DARK, GRADIENTS
                theme_name = self.current_theme
                if theme_name in THEMES:
                    THEME_DARK = THEMES[theme_name]["colors"]
                    GRADIENTS = THEMES[theme_name]["gradients"]
            
            # Set up the main application window
            self.setup_main_window()
            
            # Create UI components
            self.create_header()
            self.create_tabs()
            self.create_footer()
            
            # Create the dashboard tab content
            self.create_dashboard_tab()
            
            # Create the history tab content
            self.create_history_tab()
            
            # Create the configuration tab content
            self.create_config_tab()
            
            # Create the chatbot tab content
            self.create_chatbot_tab()
            
            # Create the about tab content
            self.create_about_tab()
            
            # Set up system tray icon
            self.setup_system_tray()
            
            # Update status
            self.update_status("Ready")
            
            # Check for updates (simulated)
            self.check_updates()
            
        except Exception as e:
            logger.error(f"Error initializing GUI: {e}")
            messagebox.showerror("Initialization Error", f"Failed to initialize the application: {str(e)}")
            
            # Make sure to destroy the root window if it exists
            if hasattr(self, 'root'):
                self.root.destroy()
            
            raise
    
    def apply_theme(self, theme_name):
        """Apply the selected theme to the application."""
        if theme_name not in THEMES:
            logger.warning(f"Theme {theme_name} not found, using default")
            theme_name = "cyberpunk"
        
        # Update current theme
        self.current_theme = theme_name
        
        # Update theme constants
        global THEME_DARK, GRADIENTS
        THEME_DARK = THEMES[theme_name]["colors"]
        GRADIENTS = THEMES[theme_name]["gradients"]
        
        # Save theme to config
        if hasattr(self, 'config'):
            self.config["theme"] = theme_name
            # Don't try to save configuration here
        
        # Show notification if the UI is already initialized
        if hasattr(self, 'root') and self.root.winfo_exists():
            self.show_notification(
                f"Theme changed to {THEMES[theme_name]['name']}",
                title="Theme Changed",
                level="info"
            )
            
            # Show a message that a restart is required for full theme application
            self.update_status(
                "Please restart the application for the theme to be fully applied",
                level="warning"
            )
            
    def load_config(self) -> dict:
        """Load configuration from the config file."""
        try:
            with open(self.config_path, 'r') as f:
                config = json.load(f)
            logger.info("Configuration loaded successfully")
            return config
        except Exception as e:
            logger.error(f"Error loading configuration: {e}")
            # Return a default configuration
            return {
                "integration": {
                    "mode": "clipboard",
                    "file_path": "./dragon_query.txt",
                    "polling_interval": 1.0,
                    "command_prefix": "ask"
                },
                "browser": {
                    "window_title_pattern": "Chrome",
                    "typing_delay": 0.05,
                    "window_switch_delay": 0.5
                },
                "chatbots": {},
                "feedback": {
                    "audio_enabled": True,
                    "popup_enabled": True,
                    "log_queries": True,
                    "log_file": "dragon_voice_queries.log"
                },
                "advanced": {
                    "max_retries": 3,
                    "retry_delay": 1.0,
                    "send_timeout": 5.0
                }
            }
    
    def setup_main_window(self):
        """Set up the main application window."""
        # Configure the window
        self.root.title("Dragon Voice Project")
        
        # Set up custom tkinter theme
        ctk.set_appearance_mode("dark")  # Options: "light", "dark", "system"
        ctk.set_default_color_theme("blue")  # Options: "blue", "green", "dark-blue"
        
        # Set window icon if available
        try:
            icon_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "assets", "dragon_icon.ico")
            if os.path.exists(icon_path):
                self.root.iconbitmap(icon_path)
        except Exception as e:
            logger.warning(f"Could not set window icon: {e}")
        
        # Configure the grid layout
        self.root.grid_columnconfigure(0, weight=1)
        self.root.grid_rowconfigure(0, weight=0)  # Header
        self.root.grid_rowconfigure(1, weight=1)  # Content
        self.root.grid_rowconfigure(2, weight=0)  # Footer
        
        # Maximize window by default 
        self.root.state('zoomed')
        # Set to fullscreen if needed
        # self.root.attributes("-fullscreen", True)
        
        # Make sure content expands to fill window
        self.root.update_idletasks()
        
        # Add Escape key binding to exit full screen if needed
        self.root.bind("<Escape>", lambda event: self.toggle_fullscreen())
        
        # Bind close event
        self.root.protocol("WM_DELETE_WINDOW", self.on_close)
        
        # Set up keyboard shortcuts
        self.setup_keyboard_shortcuts()
        
    def toggle_fullscreen(self):
        """Toggle between fullscreen and normal window."""
        is_fullscreen = self.root.attributes("-fullscreen")
        
        if is_fullscreen:
            # Exit fullscreen and maximize
            self.root.attributes("-fullscreen", False)
            self.root.state('zoomed')
        else:
            # Enter fullscreen
            self.root.attributes("-fullscreen", True)
    
    def setup_keyboard_shortcuts(self):
        """Set up keyboard shortcuts for the application."""
        # Start/Stop voice assistant (F5)
        self.root.bind("<F5>", lambda event: self.toggle_voice_assistant())
        
        # Mute/Unmute microphone (F6)
        self.root.bind("<F6>", lambda event: self.toggle_mute() if hasattr(self, 'toggle_mute') else None)
        
        # Show keyboard shortcuts help (F1)
        self.root.bind("<F1>", lambda event: self.show_keyboard_shortcuts())
        
        # Switch tabs (Ctrl+1 through Ctrl+5)
        self.root.bind("<Control-1>", lambda event: self.select_tab(0))
        self.root.bind("<Control-2>", lambda event: self.select_tab(1))
        self.root.bind("<Control-3>", lambda event: self.select_tab(2))
        self.root.bind("<Control-4>", lambda event: self.select_tab(3))
        self.root.bind("<Control-5>", lambda event: self.select_tab(4))
        
        # Save configuration (Ctrl+S) - make sure the method exists
        if hasattr(self, 'save_configuration'):
            self.root.bind("<Control-s>", lambda event: self.save_configuration())
        
        # Refresh monitor visualization (F2)
        self.root.bind("<F2>", lambda event: self.refresh_monitor_visualization())
        
        # Open command palette (Ctrl+P or Ctrl+K)
        self.root.bind("<Control-p>", lambda event: self.show_command_palette())
        self.root.bind("<Control-k>", lambda event: self.show_command_palette())
        
    def show_command_palette(self):
        """Show the command palette for quick access to functions."""
        # If method doesn't exist fully yet, create a simple version
        if not hasattr(self, 'toggle_voice_assistant'):
            self.show_notification(
                "Command palette is not available yet",
                title="Not Available",
                level="warning"
            )
            return
    
    def show_keyboard_shortcuts(self):
        """Show a dialog with keyboard shortcuts."""
        # Create a modal dialog
        dialog = ctk.CTkToplevel(self.root)
        dialog.title("Keyboard Shortcuts")
        dialog.geometry("500x500")
        dialog.resizable(False, False)
        dialog.grab_set()  # Make it modal
        
        # Center the dialog on the main window
        x = self.root.winfo_x() + (self.root.winfo_width() - 500) // 2
        y = self.root.winfo_y() + (self.root.winfo_height() - 500) // 2
        dialog.geometry(f"+{x}+{y}")
        
        # Configure the dialog
        dialog.grid_columnconfigure(0, weight=1)
        dialog.grid_rowconfigure(0, weight=0)  # Title
        dialog.grid_rowconfigure(1, weight=1)  # Content
        dialog.grid_rowconfigure(2, weight=0)  # Button
        
        # Title
        title_frame = ctk.CTkFrame(dialog, fg_color=THEME_DARK["bg_dark"], corner_radius=0, height=60)
        title_frame.grid(row=0, column=0, sticky="nsew")
        title_frame.grid_propagate(False)  # Force the height
        
        keyboard_icon = ctk.CTkLabel(
            title_frame,
            text="⌨️",
            font=ctk.CTkFont(size=24),
            text_color=THEME_DARK["primary"]
        )
        keyboard_icon.place(relx=0.05, rely=0.5, anchor="w")
        
        title_label = ctk.CTkLabel(
            title_frame,
            )
            text="Keyboard Shortcuts",
            font=ctk.CTkFont(size=20, weight="bold"),
#!/usr/bin/env python3
"""
DragonVoiceProject - Futuristic GUI Interface

This module provides a modern, futuristic user interface for the DragonVoiceProject,
allowing users to monitor and control the voice assistant, view query history,
and configure system settings with a sleek, responsive design.

Features:
- Real-time system status visualization
- Query history tracking and management
- Chatbot configuration with visual layout
- Dark mode interface with accent colors
- System tray integration
- Multi-monitor visualization
- Voice command visualization

Requirements:
- customtkinter
- pillow
- pystray
- pyperclip
- pygetwindow
- pyautogui
"""

import os
import sys
import json
import time
import logging
import threading
import webbrowser
import random
import math
from datetime import datetime
from typing import Dict, List, Tuple, Optional, Any, Union
import tkinter as tk
import tkinter.messagebox as messagebox

# Try to import required packages
try:
    import customtkinter as ctk
    from PIL import Image, ImageTk, ImageDraw
    import pyperclip
    import pygetwindow as gw
    import pyautogui
    import pystray
except ImportError as e:
    # We'll handle this error in the GUI itself
    missing_package = str(e).split("'")[1]
    print(f"Missing required package: {missing_package}")
    print(f"Please install it using: pip install {missing_package}")
    
# Local imports
# These will be used to integrate with existing functionality
try:
    from voice_assistant import MultiScreenVoiceAssistant
except ImportError:
    print("Warning: Could not import MultiScreenVoiceAssistant. Some features may be disabled.")
    MultiScreenVoiceAssistant = None

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('dragon_gui.log')
    ]
)
logger = logging.getLogger('DragonVoiceProject.GUI')

# Default configuration path
DEFAULT_CONFIG_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), "config.json")

# Theme definitions
THEMES = {
    "cyberpunk": {
        "name": "Cyberpunk",
        "colors": {
            "bg_dark": "#0D1117",           # Darker background for header/footer
            "bg_medium": "#161B22",         # Medium background for main content
            "bg_light": "#21262D",          # Lighter background for panels
            "bg_glass": "#21262D",          # Semi-transparent glass effect
            "primary": "#58A6FF",           # Primary accent color - electric blue
            "secondary": "#F0883E",         # Secondary accent - cyber orange
            "tertiary": "#7B68EE",          # Tertiary accent - purple
            "accent_green": "#3FB950",      # Success green
            "accent_red": "#F85149",        # Error red
            "accent_yellow": "#F0B72F",     # Warning yellow
            "accent_cyan": "#39C5BB",       # Info cyan
            "text": "#F0F6FC",              # Main text
            "text_secondary": "#8B949E",    # Secondary text
            "success": "#3FB950",           # Success color
            "warning": "#F0B72F",           # Warning color
            "error": "#F85149",             # Error color
            "card_bg": "#1C2128",           # Card background
            "card_border": "#30363D",       # Card border
            "input_bg": "#0D1117",          # Input field background
            "input_border": "#30363D",      # Input field border
            "button_hover": "#1F6FEB",      # Button hover color (for primary)
            "secondary_hover": "#E67E22",   # Button hover color (for secondary)
            "glow_primary": "#58A6FF",      # Glow effect for primary elements
            "glow_secondary": "#F0883E",    # Glow effect for secondary elements
            "grid_line": "#30363D",         # Grid lines
            "shadow": "#000000"             # Shadow color
        },
        "gradients": {
            "header": ["#0D1117", "#161B22"],
            "primary_button": ["#1F6FEB", "#58A6FF"],
            "secondary_button": ["#E67E22", "#F0883E"],
            "success_button": ["#2EA043", "#3FB950"],
            "error_button": ["#DA3633", "#F85149"],
            "card_bg": ["#1C2128", "#21262D"],
            "monitor_primary": ["#1F6FEB", "#58A6FF"],
            "monitor_secondary": ["#2EA043", "#3FB950"],
            "monitor_tertiary": ["#E67E22", "#F0883E"]
        }
    },
    "neon": {
        "name": "Neon Nights",
        "colors": {
            "bg_dark": "#121212",           # Darker background for header/footer
            "bg_medium": "#1E1E1E",         # Medium background for main content
            "bg_light": "#2D2D2D",          # Lighter background for panels
            "bg_glass": "#2D2D2D",          # Semi-transparent glass effect
            "primary": "#00FFFF",           # Primary accent color - cyan
            "secondary": "#FF00FF",         # Secondary accent - magenta
            "tertiary": "#FFFF00",          # Tertiary accent - yellow
            "accent_green": "#00FF00",      # Success green
            "accent_red": "#FF0000",        # Error red
            "accent_yellow": "#FFFF00",     # Warning yellow
            "accent_cyan": "#00FFFF",       # Info cyan
            "text": "#FFFFFF",              # Main text
            "text_secondary": "#AAAAAA",    # Secondary text
            "success": "#00FF00",           # Success color
            "warning": "#FFFF00",           # Warning color
            "error": "#FF0000",             # Error color
            "card_bg": "#1A1A1A",           # Card background
            "card_border": "#333333",       # Card border
            "input_bg": "#121212",          # Input field background
            "input_border": "#333333",      # Input field border
            "button_hover": "#00CCCC",      # Button hover color (for primary)
            "secondary_hover": "#CC00CC",   # Button hover color (for secondary)
            "glow_primary": "#00FFFF",      # Glow effect for primary elements
            "glow_secondary": "#FF00FF",    # Glow effect for secondary elements
            "grid_line": "#333333",         # Grid lines
            "shadow": "#000000"             # Shadow color
        },
        "gradients": {
            "header": ["#121212", "#1E1E1E"],
            "primary_button": ["#00CCCC", "#00FFFF"],
            "secondary_button": ["#CC00CC", "#FF00FF"],
            "success_button": ["#00CC00", "#00FF00"],
            "error_button": ["#CC0000", "#FF0000"],
            "card_bg": ["#1A1A1A", "#2D2D2D"],
            "monitor_primary": ["#00CCCC", "#00FFFF"],
            "monitor_secondary": ["#00CC00", "#00FF00"],
            "monitor_tertiary": ["#CC00CC", "#FF00FF"]
        }
    },
    "midnight": {
        "name": "Midnight Blue",
        "colors": {
            "bg_dark": "#0A192F",           # Darker background for header/footer
            "bg_medium": "#112240",         # Medium background for main content
            "bg_light": "#1A365D",          # Lighter background for panels
            "bg_glass": "#1A365D",          # Semi-transparent glass effect
            "primary": "#64FFDA",           # Primary accent color - teal
            "secondary": "#FF6B6B",         # Secondary accent - coral
            "tertiary": "#A78BFA",          # Tertiary accent - lavender
            "accent_green": "#10B981",      # Success green
            "accent_red": "#EF4444",        # Error red
            "accent_yellow": "#F59E0B",     # Warning yellow
            "accent_cyan": "#06B6D4",       # Info cyan
            "text": "#E2E8F0",              # Main text
            "text_secondary": "#94A3B8",    # Secondary text
            "success": "#10B981",           # Success color
            "warning": "#F59E0B",           # Warning color
            "error": "#EF4444",             # Error color
            "card_bg": "#112240",           # Card background
            "card_border": "#1E3A8A",       # Card border
            "input_bg": "#0A192F",          # Input field background
            "input_border": "#1E3A8A",      # Input field border
            "button_hover": "#4FD1C5",      # Button hover color (for primary)
            "secondary_hover": "#F43F5E",   # Button hover color (for secondary)
            "glow_primary": "#64FFDA",      # Glow effect for primary elements
            "glow_secondary": "#FF6B6B",    # Glow effect for secondary elements
            "grid_line": "#1E3A8A",         # Grid lines
            "shadow": "#000000"             # Shadow color
        },
        "gradients": {
            "header": ["#0A192F", "#112240"],
            "primary_button": ["#4FD1C5", "#64FFDA"],
            "secondary_button": ["#F43F5E", "#FF6B6B"],
            "success_button": ["#059669", "#10B981"],
            "error_button": ["#DC2626", "#EF4444"],
            "card_bg": ["#112240", "#1A365D"],
            "monitor_primary": ["#4FD1C5", "#64FFDA"],
            "monitor_secondary": ["#059669", "#10B981"],
            "monitor_tertiary": ["#F43F5E", "#FF6B6B"]
        }
    }
}

# Default theme
THEME_DARK = THEMES["cyberpunk"]["colors"]
GRADIENTS = THEMES["cyberpunk"]["gradients"]

# Animation durations
ANIMATIONS = {
    "fast": 150,      # Fast animations (150ms)
    "normal": 300,    # Normal animations (300ms)
    "slow": 500       # Slow animations (500ms)
}

# Application version
APP_VERSION = "1.0.0" 

# Add this import for Whisper integration
try:
    from whisper_integration import WhisperRecognizer
    WHISPER_AVAILABLE = True
except ImportError:
    WHISPER_AVAILABLE = False
    
class DragonVoiceGUI:
    """Main GUI class for the DragonVoiceProject application."""
    
    def __init__(self, config_path=DEFAULT_CONFIG_PATH):
        """Initialize the GUI."""
        # Save the config path
        self.config_path = config_path
        
        # Set default attributes
        self.is_running = False
        self.voice_assistant = None
        self.voice_thread = None
        self.mic_animation_active = False
        self.systray = None
        self.systray_thread = None
        self.last_query = ""
        self.query_history = []
        self.current_status = "Stopped"
        self.chatbot_windows = {}
        self.is_muted = False
        
        # Set current theme
        self.current_theme = "cyberpunk"
        
        # Initialize microphone devices
        try:
            import speech_recognition as sr
            self.mic_devices = {}
            for index, name in enumerate(sr.Microphone.list_microphone_names()):
                self.mic_devices[name] = index
        except:
            self.mic_devices = {"Default": 0}
        
        # Create the main window first
        self.root = ctk.CTk()
        
        # Define essential methods early to avoid reference errors
        def save_configuration(self, show_notification=True):
            """Save the configuration to the config file."""
            try:
                # Make sure the theme is saved
                if hasattr(self, 'current_theme'):
                    self.config["theme"] = self.current_theme
                
                # Save the config to file
                with open(self.config_path, "w") as f:
                    json.dump(self.config, f, indent=4)
                
                # Update status
                if show_notification:
                    self.update_status("Configuration saved successfully", level="success")
                    
                    # Show notification
                    self.show_notification(
                        "Configuration saved successfully",
                        title="Configuration Saved",
                        level="success"
                    )
                
                return True
            except Exception as e:
                logger.error(f"Error saving configuration: {e}")
                if show_notification:
                    self.update_status(f"Error saving configuration: {str(e)}", level="error")
                    
                    # Show error notification
                    self.show_notification(
                        f"Error saving configuration: {str(e)}",
                        title="Configuration Error",
                        level="error"
                    )
                
                return False
        
        # Attach the method to the class instance
        self.save_configuration = save_configuration.__get__(self, type(self))
        
        try:
            # Load configuration
            self.config = self.load_config()
            
            # Set theme from config
            if "theme" in self.config:
                self.current_theme = self.config["theme"]
                # Update theme constants without trying to save
                global THEME_DARK, GRADIENTS
                theme_name = self.current_theme
                if theme_name in THEMES:
                    THEME_DARK = THEMES[theme_name]["colors"]
                    GRADIENTS = THEMES[theme_name]["gradients"]
            
            # Set up the main application window
            self.setup_main_window()
            
            # Create UI components
            self.create_header()
            self.create_tabs()
            self.create_footer()
            
            # Create the dashboard tab content
            self.create_dashboard_tab()
            
            # Create the history tab content
            self.create_history_tab()
            
            # Create the configuration tab content
            self.create_config_tab()
            
            # Create the chatbot tab content
            self.create_chatbot_tab()
            
            # Create the about tab content
            self.create_about_tab()
            
            # Set up system tray icon
            self.setup_system_tray()
            
            # Update status
            self.update_status("Ready")
            
            # Check for updates (simulated)
            self.check_updates()
            
        except Exception as e:
            logger.error(f"Error initializing GUI: {e}")
            messagebox.showerror("Initialization Error", f"Failed to initialize the application: {str(e)}")
            
            # Make sure to destroy the root window if it exists
            if hasattr(self, 'root'):
                self.root.destroy()
            
            raise
    
    def apply_theme(self, theme_name):
        """Apply the selected theme to the application."""
        if theme_name not in THEMES:
            logger.warning(f"Theme {theme_name} not found, using default")
            theme_name = "cyberpunk"
        
        # Update current theme
        self.current_theme = theme_name
        
        # Update theme constants
        global THEME_DARK, GRADIENTS
        THEME_DARK = THEMES[theme_name]["colors"]
        GRADIENTS = THEMES[theme_name]["gradients"]
        
        # Save theme to config
        if hasattr(self, 'config'):
            self.config["theme"] = theme_name
            # Don't try to save configuration here
        
        # Show notification if the UI is already initialized
        if hasattr(self, 'root') and self.root.winfo_exists():
            self.show_notification(
                f"Theme changed to {THEMES[theme_name]['name']}",
                title="Theme Changed",
                level="info"
            )
            
            # Show a message that a restart is required for full theme application
            self.update_status(
                "Please restart the application for the theme to be fully applied",
                level="warning"
            )
            
    def load_config(self) -> dict:
        """Load configuration from the config file."""
        try:
            with open(self.config_path, 'r') as f:
                config = json.load(f)
            logger.info("Configuration loaded successfully")
            return config
        except Exception as e:
            logger.error(f"Error loading configuration: {e}")
            # Return a default configuration
            return {
                "integration": {
                    "mode": "clipboard",
                    "file_path": "./dragon_query.txt",
                    "polling_interval": 1.0,
                    "command_prefix": "ask"
                },
                "browser": {
                    "window_title_pattern": "Chrome",
                    "typing_delay": 0.05,
                    "window_switch_delay": 0.5
                },
                "chatbots": {},
                "feedback": {
                    "audio_enabled": True,
                    "popup_enabled": True,
                    "log_queries": True,
                    "log_file": "dragon_voice_queries.log"
                },
                "advanced": {
                    "max_retries": 3,
                    "retry_delay": 1.0,
                    "send_timeout": 5.0
                }
            }
    
    def setup_main_window(self):
        """Set up the main application window."""
        # Configure the window
        self.root.title("Dragon Voice Project")
        
        # Set up custom tkinter theme
        ctk.set_appearance_mode("dark")  # Options: "light", "dark", "system"
        ctk.set_default_color_theme("blue")  # Options: "blue", "green", "dark-blue"
        
        # Set window icon if available
        try:
            icon_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "assets", "dragon_icon.ico")
            if os.path.exists(icon_path):
                self.root.iconbitmap(icon_path)
        except Exception as e:
            logger.warning(f"Could not set window icon: {e}")
        
        # Configure the grid layout
        self.root.grid_columnconfigure(0, weight=1)
        self.root.grid_rowconfigure(0, weight=0)  # Header
        self.root.grid_rowconfigure(1, weight=1)  # Content
        self.root.grid_rowconfigure(2, weight=0)  # Footer
        
        # Maximize window by default 
        self.root.state('zoomed')
        # Set to fullscreen if needed
        # self.root.attributes("-fullscreen", True)
        
        # Make sure content expands to fill window
        self.root.update_idletasks()
        
        # Add Escape key binding to exit full screen if needed
        self.root.bind("<Escape>", lambda event: self.toggle_fullscreen())
        
        # Bind close event
        self.root.protocol("WM_DELETE_WINDOW", self.on_close)
        
        # Set up keyboard shortcuts
        self.setup_keyboard_shortcuts()
        
    def toggle_fullscreen(self):
        """Toggle between fullscreen and normal window."""
        is_fullscreen = self.root.attributes("-fullscreen")
        
        if is_fullscreen:
            # Exit fullscreen and maximize
            self.root.attributes("-fullscreen", False)
            self.root.state('zoomed')
        else:
            # Enter fullscreen
            self.root.attributes("-fullscreen", True)
    
    def setup_keyboard_shortcuts(self):
        """Set up keyboard shortcuts for the application."""
        # Start/Stop voice assistant (F5)
        self.root.bind("<F5>", lambda event: self.toggle_voice_assistant())
        
        # Mute/Unmute microphone (F6)
        self.root.bind("<F6>", lambda event: self.toggle_mute() if hasattr(self, 'toggle_mute') else None)
        
        # Show keyboard shortcuts help (F1)
        self.root.bind("<F1>", lambda event: self.show_keyboard_shortcuts())
        
        # Switch tabs (Ctrl+1 through Ctrl+5)
        self.root.bind("<Control-1>", lambda event: self.select_tab(0))
        self.root.bind("<Control-2>", lambda event: self.select_tab(1))
        self.root.bind("<Control-3>", lambda event: self.select_tab(2))
        self.root.bind("<Control-4>", lambda event: self.select_tab(3))
        self.root.bind("<Control-5>", lambda event: self.select_tab(4))
        
        # Save configuration (Ctrl+S) - make sure the method exists
        if hasattr(self, 'save_configuration'):
            self.root.bind("<Control-s>", lambda event: self.save_configuration())
        
        # Refresh monitor visualization (F2)
        self.root.bind("<F2>", lambda event: self.refresh_monitor_visualization())
        
        # Open command palette (Ctrl+P or Ctrl+K)
        self.root.bind("<Control-p>", lambda event: self.show_command_palette())
        self.root.bind("<Control-k>", lambda event: self.show_command_palette())
        
    def show_command_palette(self):
        """Show the command palette for quick access to functions."""
        # If method doesn't exist fully yet, create a simple version
        if not hasattr(self, 'toggle_voice_assistant'):
            self.show_notification(
                "Command palette is not available yet",
                title="Not Available",
                level="warning"
            )
            return
    
    def show_keyboard_shortcuts(self):
        """Show a dialog with keyboard shortcuts."""
        # Create a modal dialog
        dialog = ctk.CTkToplevel(self.root)
        dialog.title("Keyboard Shortcuts")
        dialog.geometry("500x500")
        dialog.resizable(False, False)
        dialog.grab_set()  # Make it modal
        
        # Center the dialog on the main window
        x = self.root.winfo_x() + (self.root.winfo_width() - 500) // 2
        y = self.root.winfo_y() + (self.root.winfo_height() - 500) // 2
        dialog.geometry(f"+{x}+{y}")
        
        # Configure the dialog
        dialog.grid_columnconfigure(0, weight=1)
        dialog.grid_rowconfigure(0, weight=0)  # Title
        dialog.grid_rowconfigure(1, weight=1)  # Content
        dialog.grid_rowconfigure(2, weight=0)  # Button
        
        # Title
        title_frame = ctk.CTkFrame(dialog, fg_color=THEME_DARK["bg_dark"], corner_radius=0, height=60)
        title_frame.grid(row=0, column=0, sticky="nsew")
        title_frame.grid_propagate(False)  # Force the height
        
        keyboard_icon = ctk.CTkLabel(
            title_frame,
            text="⌨️",
            font=ctk.CTkFont(size=24),
            text_color=THEME_DARK["primary"]
        )
        keyboard_icon.place(relx=0.05, rely=0.5, anchor="w")
        
        title_label = ctk.CTkLabel(
            title_frame,
            )
            text="Keyboard Shortcuts",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=THEME_DARK["text"]
        )
        title_label.place(relx=0.5, rely=0.5, anchor="center")
        
        # Content
        content_frame = ctk.CTkScrollableFrame(dialog, fg_color=THEME_DARK["bg_medium"])
        content_frame.grid(row=1, column=0, sticky="nsew", padx=20, pady=20)
        
        # Define the shortcuts
        shortcuts = [
            ("F1", "Show keyboard shortcuts"),
            ("F2", "Refresh monitor visualization"),
            ("F5", "Start/Stop voice assistant"),
            ("F6", "Mute/Unmute microphone"),
            ("Ctrl+1", "Switch to Dashboard tab"),
            ("Ctrl+2", "Switch to Query History tab"),
            ("Ctrl+3", "Switch to Configuration tab"),
            ("Ctrl+4", "Switch to Chatbots tab"),
            ("Ctrl+5", "Switch to About tab"),
            ("Ctrl+S", "Save configuration"),
            ("Alt+F4", "Exit application")
        ]
        
        # Add shortcuts to the content frame
        for i, (key, description) in enumerate(shortcuts):
            row_frame = ctk.CTkFrame(content_frame, fg_color=THEME_DARK["card_bg"] if i % 2 == 0 else THEME_DARK["bg_medium"], height=50)
            row_frame.pack(fill="x", padx=10, pady=5)
            row_frame.pack_propagate(False)  # Force the height
            
            # Key
            key_frame = ctk.CTkFrame(row_frame, fg_color=THEME_DARK["bg_dark"], corner_radius=5, width=100, height=30)
            key_frame.pack(side="left", padx=15, pady=10)
            key_frame.pack_propagate(False)  # Force the height and width
            
            key_label = ctk.CTkLabel(
                key_frame,
                text=key,
                font=ctk.CTkFont(size=14, weight="bold"),
                text_color=THEME_DARK["primary"]
            )
            key_label.place(relx=0.5, rely=0.5, anchor="center")
            
            # Description
            desc_label = ctk.CTkLabel(
                row_frame,
                text=description,
                font=ctk.CTkFont(size=14),
                text_color=THEME_DARK["text"]
            )
            desc_label.pack(side="left", padx=15, pady=10)
        
        # Close button
        button_frame = ctk.CTkFrame(dialog, fg_color=THEME_DARK["bg_dark"], corner_radius=0, height=60)
        button_frame.grid(row=2, column=0, sticky="ew")
        
        close_button = ctk.CTkButton(
            button_frame,
            text="Close",
            font=ctk.CTkFont(size=14, weight="bold"),
            fg_color=THEME_DARK["primary"],
            hover_color=THEME_DARK["button_hover"],
            width=120,
            height=35,
            corner_radius=5,
            command=dialog.destroy
        )
        close_button.place(relx=0.5, rely=0.5, anchor="center")
    
    def update_status(self, status, level="info"):
        """Update the application status."""
        self.current_status = status
        
        # Update status in UI if applicable
        if hasattr(self, 'status_label'):
            status_text = f"Status: {status}"
            self.status_label.configure(text=status_text)
            
            # Change color based on level
            if level == "error":
                self.status_label.configure(text_color="#FF5252")
            elif level == "warning":
                self.status_label.configure(text_color="#FFC107")
            elif level == "success":
                self.status_label.configure(text_color="#4CAF50")
            else:
                self.status_label.configure(text_color=THEME_DARK["text"])
        
        # Log the status
        if level == "error":
            logger.error(status)
        elif level == "warning":
            logger.warning(status)
        else:
            logger.info(status)
            
    def check_updates(self):
        """Check for application updates."""
        # This would connect to a server to check for updates
        # For now, we'll just log that we checked
        logger.info("Checking for updates...")
        # Simulate checking for updates
        self.root.after(2000, lambda: self.update_status("No updates available"))
    
    def on_close(self):
        """Handle application closing."""
        if self.is_running:
            if not self.ask_confirmation("The voice assistant is still running. Are you sure you want to exit?"):
                return
        
        # Stop the voice assistant if running
        self.stop_voice_assistant()
        
        # Destroy systray icon if it exists
        if self.systray:
            try:
                self.systray.stop()
            except:
                pass
        
        # Destroy main window
        self.root.destroy()
    
    def ask_confirmation(self, message, title="Confirmation", icon=None):
        """Ask for user confirmation with a styled dialog."""
        # Create a modal dialog
        dialog = ctk.CTkToplevel(self.root)
        dialog.title(title)
        dialog.geometry("400x200")
        dialog.resizable(False, False)
        dialog.grab_set()  # Make it modal
        
        # Center the dialog on the main window
        x = self.root.winfo_x() + (self.root.winfo_width() - 400) // 2
        y = self.root.winfo_y() + (self.root.winfo_height() - 200) // 2
        dialog.geometry(f"+{x}+{y}")
        
        # Configure the dialog
        dialog.grid_columnconfigure(0, weight=1)
        dialog.grid_rowconfigure(0, weight=1)  # Content
        dialog.grid_rowconfigure(1, weight=0)  # Buttons
        
        # Content frame
        content_frame = ctk.CTkFrame(dialog, fg_color=THEME_DARK["bg_medium"], corner_radius=0)
        content_frame.grid(row=0, column=0, sticky="nsew", padx=0, pady=0)
        
        # Center the content
        content_frame.grid_columnconfigure(0, weight=1)
        content_frame.grid_rowconfigure(0, weight=1)
        
        # Icon and message container
        message_container = ctk.CTkFrame(content_frame, fg_color="transparent")
        message_container.place(relx=0.5, rely=0.5, anchor="center")
        
        # Set up the icon
        if icon == "warning":
            icon_text = "⚠️"
            icon_color = "#FFC107"
        elif icon == "error":
            icon_text = "❌"
            icon_color = "#FF5252"
        elif icon == "info":
            icon_text = "ℹ️"
            icon_color = THEME_DARK["primary"]
        else:
            icon_text = "❓"
            icon_color = THEME_DARK["primary"]
            
        # Add icon
        icon_label = ctk.CTkLabel(
            message_container,
            text=icon_text,
            font=ctk.CTkFont(size=36),
            text_color=icon_color
        )
        icon_label.pack(pady=(0, 10))
        
        # Add message
        message_label = ctk.CTkLabel(
            message_container,
            text=message,
            font=ctk.CTkFont(size=14),
            text_color=THEME_DARK["text"],
            wraplength=350,
            justify="center"
        )
        message_label.pack(pady=10)
        
        # Button frame
        button_frame = ctk.CTkFrame(dialog, fg_color=THEME_DARK["bg_dark"], corner_radius=0, height=50)
        button_frame.grid(row=1, column=0, sticky="ew", padx=0, pady=0)
        button_frame.grid_propagate(False)  # Force the height
        
        # Center the buttons
        button_container = ctk.CTkFrame(button_frame, fg_color="transparent")
        button_container.place(relx=0.5, rely=0.5, anchor="center")
        
        # Result variable
        result = [False]  # Use a list to allow modification from inner functions
        
        # Yes button
        yes_button = ctk.CTkButton(
            button_container,
            text="Yes",
            font=ctk.CTkFont(size=14, weight="bold"),
            fg_color=THEME_DARK["primary"],
            hover_color="#1976D2",
            width=100,
            height=32,
            command=lambda: self.confirm_dialog(dialog, result, True)
        )
        yes_button.pack(side="left", padx=10)
        
        # No button
        no_button = ctk.CTkButton(
            button_container,
            text="No",
            font=ctk.CTkFont(size=14),
            fg_color=THEME_DARK["bg_light"],
            hover_color="#3D3D3D",
            width=100,
            height=32,
            command=lambda: self.confirm_dialog(dialog, result, False)
        )
        no_button.pack(side="left", padx=10)
        
        # Set focus on the No button by default (safer choice)
        no_button.focus_set()
        
        # Handle dialog close with window button
        dialog.protocol("WM_DELETE_WINDOW", lambda: self.confirm_dialog(dialog, result, False))
        
        # Wait for the dialog to be destroyed
        self.root.wait_window(dialog)
        
        # Return the result
        return result[0]
    
    def confirm_dialog(self, dialog, result, value):
        """Handle dialog confirmation."""
        result[0] = value
        dialog.destroy()
        
    def show_notification(self, message, title="Notification", duration=3000, level="info"):
        """Show a temporary notification to the user."""
        # Get level-specific settings
        if level == "error":
            icon = "❌"
            color = "#FF5252"
        elif level == "warning":
            icon = "⚠️"
            color = "#FFC107"
        elif level == "success":
            icon = "✅"
            color = "#4CAF50"
        else:  # info
            icon = "ℹ️"
            color = THEME_DARK["primary"]
        
        # Create the notification window
        notification = ctk.CTkToplevel(self.root)
        notification.title("")
        notification.geometry("300x80")
        notification.resizable(False, False)
        notification.overrideredirect(True)  # Remove window decorations
        
        # Position in bottom right of main window
        x = self.root.winfo_x() + self.root.winfo_width() - 320
        y = self.root.winfo_y() + self.root.winfo_height() - 100
        notification.geometry(f"+{x}+{y}")
        
        # Configure the notification window
        notification.configure(fg_color=THEME_DARK["bg_dark"])
        
        # Create a frame with border
        frame = ctk.CTkFrame(
            notification, 
            fg_color=THEME_DARK["bg_medium"],
            border_width=2,
            border_color=color,
            corner_radius=5
        )
        frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Add icon and message
        content_frame = ctk.CTkFrame(frame, fg_color="transparent")
        content_frame.pack(fill="both", expand=True, padx=10, pady=5)
        
        # Icon
        icon_label = ctk.CTkLabel(
            content_frame,
            text=icon,
            font=ctk.CTkFont(size=24),
            text_color=color,
            width=30
        )
        icon_label.pack(side="left", padx=(0, 10))
        
        # Message container
        message_container = ctk.CTkFrame(content_frame, fg_color="transparent")
        message_container.pack(side="left", fill="both", expand=True)
        
        # Title if provided
        if title:
            title_label = ctk.CTkLabel(
                message_container,
                )
                text=title,
                font=ctk.CTkFont(size=12, weight="bold"),
                text_color=THEME_DARK["text"],
                anchor="w"
            )
            title_label.pack(anchor="w")
        
        # Message
        message_label = ctk.CTkLabel(
            message_container,
            text=message,
            font=ctk.CTkFont(size=11),
            text_color=THEME_DARK["text_secondary"],
            anchor="w",
            wraplength=230
        )
        message_label.pack(anchor="w")
        
        # Schedule the notification to disappear
        notification.after(duration, notification.destroy)
        
        # Make the notification slowly fade in
        notification.attributes("-alpha", 0.0)
        
        def fade_in():
            alpha = notification.attributes("-alpha")
            if alpha < 1.0:
                notification.attributes("-alpha", min(alpha + 0.1, 1.0))
                notification.after(20, fade_in)
                
        fade_in()
    
    def create_header(self):
        """Create the application header."""
        header_frame = ctk.CTkFrame(self.root, fg_color=THEME_DARK["bg_dark"], corner_radius=0)
        header_frame.grid(row=0, column=0, sticky="ew", padx=0, pady=0)
        
        # Configure header grid
        header_frame.grid_columnconfigure(0, weight=0)  # Logo
        header_frame.grid_columnconfigure(1, weight=1)  # Title
        header_frame.grid_columnconfigure(2, weight=0)  # Controls
        
        # Logo placeholder (would be replaced with actual logo)
        logo_frame = ctk.CTkFrame(header_frame, width=60, height=60, fg_color="transparent")
        logo_frame.grid(row=0, column=0, padx=10, pady=10)
        
        try:
            # Try to load the logo image
            logo_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "assets", "dragon_logo.png")
            if os.path.exists(logo_path):
                logo_img = ctk.CTkImage(light_image=Image.open(logo_path), 
                                        dark_image=Image.open(logo_path),
                                        size=(50, 50))
                logo_label = ctk.CTkLabel(logo_frame, image=logo_img, text="")
                logo_label.pack(fill="both", expand=True)
            else:
                # If no logo image, use text
                logo_label = ctk.CTkLabel(logo_frame, text="🐉", font=ctk.CTkFont(size=30, weight="bold"))
                logo_label.pack(fill="both", expand=True)
        except Exception as e:
            logger.warning(f"Could not load logo: {e}")
            # Fallback to text
            logo_label = ctk.CTkLabel(logo_frame, text="🐉", font=ctk.CTkFont(size=30, weight="bold"))
            logo_label.pack(fill="both", expand=True)
        
        # Title and version
        title_frame = ctk.CTkFrame(header_frame, fg_color="transparent")
        title_frame.grid(row=0, column=1, sticky="w", padx=10, pady=10)
        
        app_title = ctk.CTkLabel(
            title_frame, 
            text="Dragon Voice Project",
            font=ctk.CTkFont(size=24, weight="bold")
        )
        app_title.pack(anchor="w")
        
        app_version_label = ctk.CTkLabel(
            title_frame,
            text=f"Version {APP_VERSION}",
            font=ctk.CTkFont(size=12),
            text_color=THEME_DARK["text_secondary"]
        )
        app_version_label.pack(anchor="w")
        
        # Controls: Start/Stop button
        controls_frame = ctk.CTkFrame(header_frame, fg_color="transparent")
        controls_frame.grid(row=0, column=2, padx=20, pady=10)
        
        self.toggle_button = ctk.CTkButton(
            controls_frame,
            text="Start",
            font=ctk.CTkFont(size=14, weight="bold"),
            fg_color=THEME_DARK["primary"],
            hover_color="#1976D2",  # Slightly darker shade
            command=self.toggle_voice_assistant
        )
        self.toggle_button.pack(side="right", padx=5)
        
        # Add tooltip to the toggle button
        self.create_tooltip(self.toggle_button, "Start/Stop the voice assistant")
        
        # Status indicator
        self.status_label = ctk.CTkLabel(
            controls_frame,
            text="Status: Ready",
            font=ctk.CTkFont(size=14),
            text_color=THEME_DARK["text"]
        )
        self.status_label.pack(side="right", padx=15)
    
    def create_tooltip(self, widget, text):
        """Create a tooltip for a widget."""
        # This is a simple tooltip implementation
        # In a real application, you might want to use a more sophisticated tooltip system
        
        tooltip_window = None
        
        def enter(event):
            nonlocal tooltip_window
            x, y, _, _ = widget.bbox("insert")
            x += widget.winfo_rootx() + 25
            y += widget.winfo_rooty() + 25
            
            # Create a toplevel window
            tooltip_window = ctk.CTkToplevel(widget)
            tooltip_window.wm_overrideredirect(True)
            tooltip_window.wm_geometry(f"+{x}+{y}")
            
            # Create tooltip content
            frame = ctk.CTkFrame(tooltip_window, fg_color=THEME_DARK["bg_dark"], corner_radius=5)
            frame.pack(ipadx=5, ipady=5)
            
            label = ctk.CTkLabel(frame, text=text, font=ctk.CTkFont(size=12))
            label.pack()
            
        def leave(event):
            nonlocal tooltip_window
            if tooltip_window:
                tooltip_window.destroy()
                tooltip_window = None
        
        # Bind events
        widget.bind("<Enter>", enter)
        widget.bind("<Leave>", leave)
    
    def create_tabs(self):
        """Create the tabbed interface."""
        # Create a frame for the tabs
        self.tabs_frame = ctk.CTkFrame(self.root)
        self.tabs_frame.grid(row=1, column=0, sticky="nsew", padx=10, pady=10)
        
        # Configure the tabs frame grid
        self.tabs_frame.grid_columnconfigure(0, weight=1)
        self.tabs_frame.grid_rowconfigure(0, weight=0)  # Tab bar
        self.tabs_frame.grid_rowconfigure(1, weight=1)  # Tab content
        
        # Create the tab view
        self.tab_view = ctk.CTkTabview(
            self.tabs_frame, 
            fg_color=THEME_DARK["bg_medium"],
            segmented_button_fg_color=THEME_DARK["bg_dark"],
            segmented_button_selected_color=THEME_DARK["primary"],
            segmented_button_selected_hover_color="#1976D2",
            segmented_button_unselected_color=THEME_DARK["bg_dark"],
            segmented_button_unselected_hover_color=THEME_DARK["bg_light"]
        )
        self.tab_view.grid(row=0, column=0, sticky="nsew", padx=0, pady=0)
        
        # Configure the tab view to fill the frame
        self.tab_view.grid_columnconfigure(0, weight=1)
        self.tab_view.grid_rowconfigure(0, weight=1)
        
        # Add tabs
        self.dashboard_tab = self.tab_view.add("Dashboard")
        self.history_tab = self.tab_view.add("Query History")
        self.config_tab = self.tab_view.add("Configuration")
        self.chatbot_tab = self.tab_view.add("Chatbots")
        self.about_tab = self.tab_view.add("About")
        
        # Configure each tab's grid
        for tab in [self.dashboard_tab, self.history_tab, self.config_tab, self.chatbot_tab, self.about_tab]:
            tab.grid_columnconfigure(0, weight=1)
            tab.grid_rowconfigure(0, weight=1)
        
        # Add tooltips to tab buttons
        tab_tooltips = {
            "Dashboard": "Main control center with system status and monitor visualization",
            "Query History": "View and manage past voice commands",
            "Configuration": "Adjust system settings and preferences",
            "Chatbots": "Configure and manage chatbot connections",
            "About": "Information about the Dragon Voice Project"
        }
        
        # Get the tab buttons
        # Note: This is a bit hacky and depends on the internal structure of CTkTabview
        # In a real application, you might want to use a different approach
        try:
            tab_bar = self.tab_view._segmented_button
            for i, (tab_name, tooltip_text) in enumerate(tab_tooltips.items()):
                # Try to get the button widget
                for child in tab_bar.winfo_children():
                    if hasattr(child, "cget") and child.cget("text") == tab_name:
                        self.create_tooltip(child, tooltip_text)
                        break
        except Exception as e:
            logger.warning(f"Could not add tooltips to tabs: {e}")
    
    def create_footer(self):
        """Create the application footer."""
        footer_frame = ctk.CTkFrame(self.root, fg_color=THEME_DARK["bg_dark"], corner_radius=0, height=30)
        footer_frame.grid(row=2, column=0, sticky="ew", padx=0, pady=0)
        
        # Configure footer grid
        footer_frame.grid_columnconfigure(0, weight=1)  # Copyright
        footer_frame.grid_columnconfigure(1, weight=0)  # Links
        
        # Copyright text
        copyright_label = ctk.CTkLabel(
            footer_frame,
            text=f"© {datetime.now().year} Dragon Voice Project",
            font=ctk.CTkFont(size=12),
            text_color=THEME_DARK["text_secondary"]
        )
        copyright_label.grid(row=0, column=0, sticky="w", padx=15, pady=5)
        
        # Links frame
        links_frame = ctk.CTkFrame(footer_frame, fg_color="transparent")
        links_frame.grid(row=0, column=1, sticky="e", padx=15, pady=5)
        
        # Help link
        help_link = ctk.CTkLabel(
            links_frame,
            text="Help",
            font=ctk.CTkFont(size=12),
            text_color=THEME_DARK["primary"],
            cursor="hand2"
        )
        help_link.pack(side="left", padx=10)
        help_link.bind("<Button-1>", lambda e: self.open_help())
        
        # Settings link
        settings_link = ctk.CTkLabel(
            links_frame,
            text="Settings",
            font=ctk.CTkFont(size=12),
            text_color=THEME_DARK["primary"],
            cursor="hand2"
        )
        settings_link.pack(side="left", padx=10)
        settings_link.bind("<Button-1>", lambda e: self.tab_view.set("Configuration"))
    
    def open_help(self):
        """Open the help documentation."""
        # Ideally, this would open a local help file or documentation website
        webbrowser.open("https://github.com/yourusername/DragonVoiceProject/wiki")

    def setup_system_tray(self):
        """Set up the system tray icon."""
        try:
            # Create a system tray icon
            icon_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "assets", "dragon_icon.ico")
            
            # If icon doesn't exist, create a placeholder
            if not os.path.exists(icon_path):
                # Use a simpler approach to create an icon
                img = Image.new('RGBA', (64, 64), color=(30, 136, 229, 255))
                img.save("temp_icon.ico")
                icon_path = "temp_icon.ico"
            
            # Create icon and menu
            icon = pystray.Icon("dragon_voice")
            icon.icon = Image.open(icon_path)
            
            # Define menu items
            def show_window(icon, item):
                self.root.deiconify()
                self.root.lift()
            
            def exit_app(icon, item):
                icon.stop()
                self.root.destroy()
            
            # Create menu
            icon.menu = pystray.Menu(
                pystray.MenuItem("Show", show_window),
                pystray.MenuItem("Exit", exit_app)
            )
            
            # Run icon in a separate thread
            self.systray = icon
            self.systray_thread = threading.Thread(target=icon.run, daemon=True)
            self.systray_thread.start()
            
            logger.info("System tray icon initialized")
        except Exception as e:
            logger.error(f"Error setting up system tray: {e}")
            self.systray = None  # Make sure it's set to None so we don't try to stop it later
    
    def toggle_voice_assistant(self):
        """Toggle the voice assistant on/off."""
        if self.is_running:
            self.stop_voice_assistant()
        else:
            self.start_voice_assistant()
    
    def start_voice_assistant(self):
        """Start the voice assistant."""
        if self.is_running:
            return
        
        self.update_status("Starting voice assistant...", level="info")
        
        try:
            # Create voice assistant if needed
            if not self.voice_assistant and MultiScreenVoiceAssistant:
                try:
                    self.voice_assistant = MultiScreenVoiceAssistant(
                        config_path=self.config_path,
                        mode=self.config.get("integration", {}).get("mode", "clipboard")
                    )
                except Exception as e:
                    raise Exception(f"Failed to initialize voice assistant: {str(e)}")
            
            if not self.voice_assistant:
                raise Exception("Voice assistant module not available")
            
            # Check if we can access microphone (dummy check for now)
            try:
                # In a real implementation, this would check actual microphone access
                # For example, using a library like sounddevice or pyaudio
                # For this demo, we'll simulate it
                self.update_status("Checking microphone access...", level="info")
                
                # Show a notification about microphone access
                self.show_notification(
                    "Checking microphone access...",
                    title="Microphone Check",
                    level="info"
                )
                
                # Add a small delay to simulate checking microphone
                self.root.after(1000, lambda: self._continue_voice_assistant_start())
                
            except Exception as e:
                # Show a notification about microphone access failure
                self.show_notification(
                    f"Microphone access failed: {str(e)}",
                    title="Microphone Error",
                    level="error"
                )
                raise Exception(f"Microphone access error: {str(e)}")
            
        except Exception as e:
            logger.error(f"Error starting voice assistant: {e}")
            self.update_status(f"Error starting voice assistant: {str(e)}", level="error")
            
            # Show error dialog
            self.ask_confirmation(
                f"Failed to start voice assistant: {str(e)}\n\nPlease check your configuration and try again.",
                title="Voice Assistant Error",
                icon="error"
            )
    
    def _continue_voice_assistant_start(self):
        """Continue starting the voice assistant after microphone check."""
        try:
            # Start the voice assistant in a separate thread
            self.voice_thread = threading.Thread(target=self.run_voice_assistant, daemon=True)
            self.voice_thread.start()
            
            # Update UI elements
            self.is_running = True
            self.toggle_button.configure(text="Stop", fg_color="#FF5252", hover_color="#D32F2F")
            
            # Update status indicators
            self.va_status.configure(text="Active", text_color="#4CAF50")
            
            # Update progress bars
            if hasattr(self, 'va_progress'):
                self.va_progress.set(1.0)  # Full progress for active
            
            # Count active chatbots
            chatbots = self.config.get("chatbots", {})
            active_chatbots = sum(1 for c in chatbots.values() if c.get("active", True))
            total_chatbots = len(chatbots) or 1  # Avoid division by zero
            
            # Update chatbot status
            if hasattr(self, 'cb_status'):
                self.cb_status.configure(text=f"{active_chatbots}/{total_chatbots}")
            
            if hasattr(self, 'cb_progress'):
                self.cb_progress.set(active_chatbots / total_chatbots)
            
            # Set all chatbot statuses to "Ready" in the dashboard
            self.update_chatbot_statuses("Ready", "#4CAF50")
            
            # Start microphone visualization animation
            self.start_mic_visualization()
            
            # Update command text
            if hasattr(self, 'command_text'):
                self.command_text.configure(text="Listening for voice commands...", text_color=THEME_DARK["primary"])
            
            # Update status
            self.update_status("Voice assistant started successfully", level="success")
            
            # Show success notification
            self.show_notification(
                "Voice assistant is now active and listening for commands",
                title="Voice Assistant Active",
                level="success"
            )
            
        except Exception as e:
            logger.error(f"Error in voice assistant continuation: {e}")
            self.update_status(f"Error starting voice assistant: {str(e)}", level="error")
            
            # Show error notification
            self.show_notification(
                f"Failed to start voice assistant: {str(e)}",
                title="Voice Assistant Error",
                level="error"
            )
    
    def start_mic_visualization(self):
        """Start the microphone visualization animation."""
        if not hasattr(self, 'mic_animation_active'):
            self.mic_animation_active = False
        
        if not hasattr(self, 'mic_animation_levels'):
            # Create random levels for visualization
            self.mic_animation_levels = [0.2, 0.5, 0.3, 0.7, 0.4, 0.8, 0.6, 0.9]
            self.mic_animation_index = 0
        
        self.mic_animation_active = True
        self.update_mic_visualization()
    
    def update_mic_visualization(self):
        """Update the microphone visualization animation."""
        if not self.mic_animation_active or not self.is_running:
            return
        
        # Find the visualization elements
        # This assumes we have a voice_canvas element for visualization
        if hasattr(self, 'voice_canvas'):
            # Get the next level
            level = self.mic_animation_levels[self.mic_animation_index]
            self.mic_animation_index = (self.mic_animation_index + 1) % len(self.mic_animation_levels)
            
            # Update the visualization
            self.update_voice_activity_display(level)
            
            # Schedule the next update
            self.root.after(300, self.update_mic_visualization)
    
    def update_voice_activity_display(self, level):
        """Update the voice activity display with the given level (0.0 to 1.0)."""
        if not hasattr(self, 'voice_canvas'):
            return
        
        # Clear the canvas
        self.voice_canvas.delete("all")
        
        # Get canvas dimensions
        width = self.voice_canvas.winfo_width()
        height = self.voice_canvas.winfo_height()
        
        # If canvas not yet drawn, use default size
        if width <= 1:
            width = 60
        if height <= 1:
            height = 60
        
        # Draw the outer circle
        outer_radius = min(width, height) // 2 - 2
        center_x = width // 2
        center_y = height // 2
        
        # Draw a futuristic audio visualizer
        if level > 0.05:  # Only show animation if there's significant activity
            # Draw multiple circles with varying opacity based on level
            num_circles = 5
            for i in range(num_circles):
                # Calculate radius and opacity
                radius_factor = 0.6 + (i / num_circles) * 0.4
                radius = outer_radius * radius_factor
                
                # Color based on level
                if level < 0.3:
                    color = THEME_DARK["primary"]  # Blue for low level
                elif level < 0.7:
                    color = THEME_DARK["secondary"]  # Orange for medium level
                else:
                    color = THEME_DARK["accent_red"]  # Red for high level
                
                # Draw the circle
                self.voice_canvas.create_oval(
                    center_x - radius, center_y - radius,
                    center_x + radius, center_y + radius,
                    outline=color,
                    width=2,
                    fill=""
                )
            
            # Draw audio waveform
            num_bars = 16
            bar_width = (width - 20) / num_bars
            bar_spacing = 2
            max_bar_height = height * 0.8
            
            for i in range(num_bars):
                # Calculate bar height based on level and position
                # Create a wave-like pattern
                position_factor = abs(((i / (num_bars - 1)) * 2) - 1)  # 0->1->0
                bar_level = level * (0.5 + 0.5 * position_factor)
                
                # Add some randomness for a more dynamic look
                bar_level *= (0.7 + 0.3 * random.random())
                
                bar_height = max_bar_height * bar_level
                
                # Calculate bar position
                bar_x = 10 + i * (bar_width + bar_spacing)
                bar_y = center_y - bar_height / 2
                
                # Color based on position and level
                if i < num_bars / 3:
                    color = THEME_DARK["primary"]  # Blue for left
                elif i < num_bars * 2 / 3:
                    color = THEME_DARK["secondary"]  # Orange for middle
                else:
                    color = THEME_DARK["tertiary"]  # Purple for right
                
                # Draw the bar
                self.voice_canvas.create_rectangle(
                    bar_x, bar_y,
                    bar_x + bar_width, bar_y + bar_height,
                    fill=color,
                    outline="",
                    width=0
                )
        else:
            # Draw a simple circle when inactive
            self.voice_canvas.create_oval(
                center_x - outer_radius, center_y - outer_radius,
                center_x + outer_radius, center_y + outer_radius,
                outline=THEME_DARK["primary"],
                width=2,
                fill=""
            )
            
            # Draw a small dot in the center
            self.voice_canvas.create_oval(
                center_x - 3, center_y - 3,
                center_x + 3, center_y + 3,
                outline="",
                fill=THEME_DARK["primary"]
            )
    
    def update_chatbot_statuses(self, status_text, status_color):
        """Update all chatbot status indicators in the dashboard."""
        if hasattr(self, 'chatbot_status_widgets'):
            for name, widgets in self.chatbot_status_widgets.items():
                if 'status_circle' in widgets and 'status_text' in widgets:
                    widgets['status_circle'].configure(fg_color=status_color)
                    widgets['status_text'].configure(text=status_text)
    
    def run_voice_assistant(self):
        """Run the voice assistant process."""
        if not self.voice_assistant_running:
            return
        
        try:
            # Check if Whisper is enabled and available
            use_whisper = WHISPER_AVAILABLE and self.config.get("whisper", {}).get("enabled", False)
            
            if use_whisper:
                self.update_command_display("Listening for commands... (Whisper API Enabled)")
                self.update_status("Listening with Whisper API... Say a command", level="info")
                
                # Get whisper settings
                api_key = self.config.get("whisper", {}).get("api_key", "")
                base_url = self.config.get("whisper", {}).get("base_url", "")
                model = self.config.get("whisper", {}).get("model", "whisper-1")
                language = self.config.get("whisper", {}).get("language", "en")
                
                # Initialize Whisper recognizer
                recognizer = WhisperRecognizer(api_key=api_key, base_url=base_url)
                recognizer.model = model
                recognizer.language = language if language != "auto" else None
                
                # Record and transcribe (returns None if an error occurs)
                command = recognizer.record_and_transcribe(
                    max_seconds=30,
                    silence_threshold=500,
                    silence_duration=1.0
                )
                
                # Clean up resources
                recognizer.cleanup()
                
                # Process command if valid
                if command:
                    self.process_voice_command(command)
                
                # Schedule next run
                if self.voice_assistant_running:
                    self.root.after(1000, self.run_voice_assistant)
            
            else:
                # Original implementation using simulated or SpeechRecognition
                # In a real implementation, this would use SpeechRecognition or another library
                self.update_command_display("Listening for commands...")
                
                # Simulate voice command (for demonstration)
                # In a real implementation, this would record from the microphone and convert to text
                
                # In this simulation, we'll just wait for 3-5 seconds, then randomly
                # generate a command or continue listening
                import random
                
                # Update the visualization
                if random.random() < 0.1:  # 10% chance of detecting a command
                    self.update_command_display("Processing command...")
                    
                    # Show activity in the visualization (high activity)
                    for i in range(5):
                        level = random.randint(50, 100)
                        self.update_voice_activity_display(level)
                        self.root.update()
                        time.sleep(0.1)
                    
                    # Simulate detected command
                    command = random.choice([
                        "ask what are the latest treatments for hypertension",
                        "ask explain the mechanism of action for atorvastatin",
                        "ask what is the recommended dosage for lisinopril",
                        "ask describe the side effects of metformin",
                        "ask what are the contraindications for amoxicillin"
                    ])
                    
                    self.process_voice_command(command)
                else:
                    # Show low activity in the visualization
                    level = random.randint(5, 20)
                    self.update_voice_activity_display(level)
                
                # Schedule next run
                if self.voice_assistant_running:
                    self.root.after(100, self.run_voice_assistant)
        except Exception as e:
            logger.error(f"Error in voice assistant: {e}")
            self.update_status(f"Error in voice assistant: {str(e)}", level="error")
            
            # Still schedule next run despite error
            if self.voice_assistant_running:
                self.root.after(1000, self.run_voice_assistant)
    
    def process_voice_command(self, command):
        """Process a voice command."""
        if not self.is_running:
            return
        
        logger.info(f"Processing voice command: {command}")
        
        # Check if the command starts with the command prefix
        command_prefix = self.config.get("integration", {}).get("command_prefix", "ask")
        if not command.lower().startswith(command_prefix.lower()):
            logger.info(f"Command does not start with prefix '{command_prefix}', ignoring")
            return
        
        # Update the command display
        self.update_command_display(command)
        
        # Update voice activity visualization
        self.update_voice_activity_display(0.8)  # High activity level
        
        # Add to history
        self.add_to_history({
            "timestamp": datetime.now().strftime("%H:%M:%S"),
            "query": command,
            "success": True,
            "chatbots": 3  # Simulated number of chatbots
        })
        
        # Update last activity time
        if hasattr(self, 'la_status'):
            current_time = datetime.now().strftime("%H:%M:%S")
            self.la_status.configure(text=current_time)
            
            # Animate the progress bar
            if hasattr(self, 'la_progress'):
                self.la_progress.set(1.0)  # Full progress
                
                # Reset progress after a delay
                def reset_progress():
                    if hasattr(self, 'la_progress'):
                        self.la_progress.set(0.0)
                
                self.root.after(3000, reset_progress)
        
        # Increment query count
        if hasattr(self, 'qp_status'):
            current_count = int(self.qp_status.cget("text") or "0")
            new_count = current_count + 1
            self.qp_status.configure(text=str(new_count))
            
            # Update the progress bar
            if hasattr(self, 'qp_progress'):
                # Scale progress based on number of queries (max 20 for full bar)
                progress = min(new_count / 20, 1.0)
                self.qp_progress.set(progress)
        
        # Simulate sending to chatbots
        self.simulate_sending_to_chatbots(command)
        
        # Update status
        self.update_status(f"Processed command: {command}", level="success")
    
    def update_command_display(self, command):
        """Update the command display with the latest command."""
        if hasattr(self, 'command_text'):
            self.command_text.configure(text=command, text_color=THEME_DARK["text"])
            
        # Also add to history if applicable
        self.add_to_history(command)
    
    def add_to_history(self, query):
        """Add a query to the history."""
        # Create a history entry
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        chatbot_count = len(self.config.get("chatbots", {}))
        if chatbot_count == 0:
            chatbot_count = random.randint(3, 7)  # For demo
            
        history_entry = {
            "query": query,
            "timestamp": timestamp,
            "chatbot_count": chatbot_count,
            "success": True  # Assume success for now
        }
        
        # Add to our history list
        if not hasattr(self, 'query_history') or self.query_history is None:
            self.query_history = []
            
        self.query_history.insert(0, history_entry)
        
        # If we're on the history tab, refresh the display
        if hasattr(self, 'tab_view') and self.tab_view.get() == "Query History":
            self.add_sample_history_items()
    
    def simulate_sending_to_chatbots(self, command):
        """Simulate sending a command to chatbots."""
        # Get all chatbots
        chatbots = self.config.get("chatbots", {})
        if not chatbots:
            # Use sample chatbots for demo
            chatbots = {
                "grok": {},
                "healthuniverse": {},
                "openevidence": {},
                "coral": {},
                "glasshelp": {}
            }
            
        # Update chatbot status to indicate activity
        if hasattr(self, 'chatbot_status_widgets'):
            for name, widgets in self.chatbot_status_widgets.items():
                if 'status_circle' in widgets and 'status_text' in widgets:
                    widgets['status_circle'].configure(fg_color="#FFC107")  # Yellow for processing
                    widgets['status_text'].configure(text="Processing")
                    
        # After a delay, update to success
        self.root.after(2000, lambda: self.update_chatbot_statuses("Active", "#4CAF50"))
    
    def stop_voice_assistant(self):
        """Stop the voice assistant."""
        if not self.is_running:
            return
        
        self.update_status("Stopping voice assistant...", level="info")
        
        try:
            # Stop the voice assistant
            self.is_running = False
            self.mic_animation_active = False
            
            # Give the thread time to stop
            if self.voice_thread and self.voice_thread.is_alive():
                self.voice_thread.join(timeout=2)
            
            # Update UI elements
            self.toggle_button.configure(text="Start", fg_color=THEME_DARK["primary"], hover_color=THEME_DARK["button_hover"])
            self.va_status.configure(text="Inactive", text_color="#FF5252")
            
            # Reset progress bars
            if hasattr(self, 'va_progress'):
                self.va_progress.set(0.0)
            
            # Update all chatbot status indicators
            self.update_chatbot_statuses("Inactive", "#FF5252")
            
            # Reset voice visualization if it exists
            if hasattr(self, 'voice_canvas'):
                self.voice_canvas.delete("all")
                self.voice_canvas.create_oval(5, 5, 55, 55, outline=THEME_DARK["primary"], width=2, fill="")
            
            if hasattr(self, 'mic_status_label'):
                self.mic_status_label.configure(text="Inactive", text_color=THEME_DARK["text_secondary"])
            
            # Update command display
            if hasattr(self, 'command_text'):
                self.command_text.configure(text="Waiting for voice command...", text_color=THEME_DARK["text_secondary"])
            
            # Update status
            self.update_status("Voice assistant stopped", level="info")
            
            # Show notification
            self.show_notification(
                "Voice assistant has been stopped",
                title="Voice Assistant Stopped",
                level="info"
            )
            
        except Exception as e:
            logger.error(f"Error stopping voice assistant: {e}")
            self.update_status(f"Error stopping voice assistant: {str(e)}", level="error")
            
            # Show error notification
            self.show_notification(
                f"Error stopping voice assistant: {str(e)}",
                title="Error",
                level="error"
            )
    
    def create_dashboard_tab(self):
        """Create the dashboard tab with futuristic UI elements."""
        # Main container
        dashboard_frame = ctk.CTkFrame(self.dashboard_tab, fg_color="transparent")
        dashboard_frame.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        
        # Configure dashboard grid
        dashboard_frame.grid_columnconfigure(0, weight=1)  # Left column
        dashboard_frame.grid_columnconfigure(1, weight=1)  # Right column
        dashboard_frame.grid_rowconfigure(0, weight=0)  # Status panel
        dashboard_frame.grid_rowconfigure(1, weight=1)  # Main content
        dashboard_frame.grid_rowconfigure(2, weight=0)  # Voice command panel
        
        # Status panel (spans both columns)
        status_panel = ctk.CTkFrame(dashboard_frame, fg_color=THEME_DARK["bg_medium"], corner_radius=10)
        status_panel.grid(row=0, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        
        # Status panel title
        status_title = ctk.CTkLabel(
            status_panel,
            text="SYSTEM STATUS",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=THEME_DARK["text"]
        )
        status_title.pack(anchor="w", padx=15, pady=(15, 5))
        
        # Separator
        separator = ctk.CTkFrame(status_panel, height=1, fg_color=THEME_DARK["bg_light"])
        separator.pack(fill="x", padx=15, pady=5)
        
        # Status indicators
        status_grid = ctk.CTkFrame(status_panel, fg_color="transparent")
        status_grid.pack(fill="x", padx=15, pady=10)
        
        status_grid.grid_columnconfigure(0, weight=1)
        status_grid.grid_columnconfigure(1, weight=1)
        status_grid.grid_columnconfigure(2, weight=1)
        status_grid.grid_columnconfigure(3, weight=1)
        
        # Voice Assistant Status
        va_frame = ctk.CTkFrame(status_grid, fg_color="transparent")
        va_frame.grid(row=0, column=0, padx=10, pady=10)
        
        va_icon = ctk.CTkLabel(va_frame, text="🎤", font=ctk.CTkFont(size=20))
        va_icon.pack()
        
        va_label = ctk.CTkLabel(va_frame, text="Voice Assistant", font=ctk.CTkFont(size=12))
        va_label.pack()
        
        self.va_status = ctk.CTkLabel(va_frame, text="Inactive", font=ctk.CTkFont(size=14, weight="bold"), text_color="#FF5252")
        self.va_status.pack()
        
        # Chatbots Ready
        cb_frame = ctk.CTkFrame(status_grid, fg_color="transparent")
        cb_frame.grid(row=0, column=1, padx=10, pady=10)
        
        cb_icon = ctk.CTkLabel(cb_frame, text="🤖", font=ctk.CTkFont(size=20))
        cb_icon.pack()
        
        cb_label = ctk.CTkLabel(cb_frame, text="Chatbots Ready", font=ctk.CTkFont(size=12))
        cb_label.pack()
        
        self.cb_status = ctk.CTkLabel(cb_frame, text="0/0", font=ctk.CTkFont(size=14, weight="bold"), text_color="#FFC107")
        self.cb_status.pack()
        
        # Queries Processed
        qp_frame = ctk.CTkFrame(status_grid, fg_color="transparent")
        qp_frame.grid(row=0, column=2, padx=10, pady=10)
        
        qp_icon = ctk.CTkLabel(qp_frame, text="💬", font=ctk.CTkFont(size=20))
        qp_icon.pack()
        
        qp_label = ctk.CTkLabel(qp_frame, text="Queries Processed", font=ctk.CTkFont(size=12))
        qp_label.pack()
        
        self.qp_status = ctk.CTkLabel(qp_frame, text="0", font=ctk.CTkFont(size=14, weight="bold"))
        self.qp_status.pack()
        
        # Last Activity
        la_frame = ctk.CTkFrame(status_grid, fg_color="transparent")
        la_frame.grid(row=0, column=3, padx=10, pady=10)
        
        la_icon = ctk.CTkLabel(la_frame, text="🕒", font=ctk.CTkFont(size=20))
        la_icon.pack()
        
        la_label = ctk.CTkLabel(la_frame, text="Last Activity", font=ctk.CTkFont(size=12))
        la_label.pack()
        
        self.la_status = ctk.CTkLabel(la_frame, text="Never", font=ctk.CTkFont(size=14, weight="bold"))
        self.la_status.pack()
        
        # Monitor visualization (left column)
        self.create_monitor_visualization(dashboard_frame)
        
        # Chatbot status cards (right column)
        chatbot_frame = ctk.CTkFrame(dashboard_frame, fg_color=THEME_DARK["bg_medium"], corner_radius=10)
        chatbot_frame.grid(row=1, column=1, sticky="nsew", padx=10, pady=10)
        
        chatbot_title = ctk.CTkLabel(
            chatbot_frame,
            text="CHATBOT STATUS",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=THEME_DARK["text"]
        )
        chatbot_title.pack(anchor="w", padx=15, pady=(15, 5))
        
        chatbot_separator = ctk.CTkFrame(chatbot_frame, height=1, fg_color=THEME_DARK["bg_light"])
        chatbot_separator.pack(fill="x", padx=15, pady=5)
        
        # Scrollable frame for chatbot cards
        self.chatbot_cards = ctk.CTkScrollableFrame(
            chatbot_frame,
            fg_color="transparent",
            scrollbar_fg_color=THEME_DARK["bg_dark"],
            scrollbar_button_color=THEME_DARK["primary"]
        )
        self.chatbot_cards.pack(fill="both", expand=True, padx=15, pady=15)
        
        # Add sample chatbot cards
        self.add_sample_chatbot_cards()
        
        # Voice command panel (spans both columns)
        self.create_voice_command_panel(dashboard_frame)
    
    def create_monitor_visualization(self, parent):
        """Create an improved monitor visualization panel."""
        monitor_frame = ctk.CTkFrame(parent, fg_color=THEME_DARK["bg_medium"], corner_radius=10)
        monitor_frame.grid(row=1, column=0, sticky="nsew", padx=10, pady=10)
        
        # Configure monitor frame
        monitor_frame.grid_columnconfigure(0, weight=1)
        monitor_frame.grid_rowconfigure(0, weight=0)  # Header
        monitor_frame.grid_rowconfigure(1, weight=1)  # Visualization
        
        # Header with title and refresh button
        header_frame = ctk.CTkFrame(monitor_frame, fg_color="transparent")
        header_frame.grid(row=0, column=0, sticky="ew", padx=15, pady=(15, 5))
        
        # Display icon before title
        display_icon = ctk.CTkLabel(
            header_frame,
            text="🖥️",
            font=ctk.CTkFont(size=18),
            text_color=THEME_DARK["primary"]
        )
        display_icon.pack(side="left", padx=(0, 5))
        
        # Title
        title = ctk.CTkLabel(
            header_frame,
            text="MONITOR CONFIGURATION",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=THEME_DARK["text"]
        )
        title.pack(side="left")
        
        # Refresh button with spinning animation on click
        self.refresh_button = ctk.CTkButton(
            header_frame,
            text="⟳ Refresh",
            font=ctk.CTkFont(size=12),
            width=100,
            height=28,
            fg_color=THEME_DARK["bg_light"],
            hover_color="#3D3D3D",
            command=self.refresh_monitor_visualization
        )
        self.refresh_button.pack(side="right")
        
        # Separator
        separator = ctk.CTkFrame(monitor_frame, height=1, fg_color=THEME_DARK["bg_light"])
        separator.grid(row=0, column=0, sticky="ew", padx=15, pady=(45, 5))
        
        # Create the visualization frame
        self.monitor_viz_frame = ctk.CTkFrame(monitor_frame, fg_color=THEME_DARK["bg_dark"], corner_radius=5)
        self.monitor_viz_frame.grid(row=1, column=0, sticky="nsew", padx=15, pady=15)
        
        # Initialize the monitor visualization
        self.init_monitor_visualization()
    
    def init_monitor_visualization(self):
        """Initialize the monitor visualization."""
        # Clear existing content
        for widget in self.monitor_viz_frame.winfo_children():
            widget.destroy()
        
        # Create a canvas for drawing
        canvas_frame = ctk.CTkFrame(self.monitor_viz_frame, fg_color="transparent")
        canvas_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        self.monitor_canvas = ctk.CTkCanvas(
            canvas_frame,
            bg=THEME_DARK["bg_dark"],
            highlightthickness=0
        )
        self.monitor_canvas.pack(fill="both", expand=True)
        
        # Detect screens
        self.detected_screens = self.get_screen_info()
        
        # Draw the monitors and chatbot windows
        self.draw_monitors()
    
    def get_screen_info(self):
        """Get information about all connected screens."""
        # In a real implementation, this would use pygetwindow or another library
        # to detect actual monitors. For now, we'll simulate common configurations.
        
        # Try to get actual screen info if pygetwindow is available
        try:
            import pygetwindow as gw
            screens = []
            
            # Get all monitors
            all_screens = gw.getAllScreens() if hasattr(gw, 'getAllScreens') else []
            
            if all_screens:
                for i, screen in enumerate(all_screens):
                    screens.append({
                        "left": screen.left,
                        "top": screen.top,
                        "width": screen.width,
                        "height": screen.height,
                        "primary": i == 0  # Assume first screen is primary
                    })
                return screens
        except Exception as e:
            logger.warning(f"Could not get actual screen info: {e}")
        
        # Fallback to simulated configurations
        # Determine which configuration to use based on the refresh count
        # This creates a nice demo effect when refreshing
        
        if not hasattr(self, 'refresh_count'):
            self.refresh_count = 0
        
        config_index = self.refresh_count % 4
        self.refresh_count += 1
        
        # Common screen configurations
        configurations = [
            # Configuration 1: Single monitor (1080p)
            [
                {"left": 0, "top": 0, "width": 1920, "height": 1080, "primary": True}
            ],
            
            # Configuration 2: Dual monitors side by side (both 1080p)
            [
                {"left": 0, "top": 0, "width": 1920, "height": 1080, "primary": True},
                {"left": 1920, "top": 0, "width": 1920, "height": 1080, "primary": False}
            ],
            
            # Configuration 3: Triple monitors (1080p)
            [
                {"left": 1920, "top": 0, "width": 1920, "height": 1080, "primary": True},
                {"left": 0, "top": 0, "width": 1920, "height": 1080, "primary": False},
                {"left": 3840, "top": 0, "width": 1920, "height": 1080, "primary": False}
            ],
            
            # Configuration 4: Laptop with external monitor (different resolutions)
            [
                {"left": 0, "top": 0, "width": 1366, "height": 768, "primary": True},
                {"left": 1366, "top": -200, "width": 2560, "height": 1440, "primary": False}
            ]
        ]
        
        return configurations[config_index]
    
    def draw_monitors(self):
        """Draw monitors and chatbot windows on the canvas."""
        if not hasattr(self, 'monitor_canvas'):
            return
        
        # Clear canvas
        self.monitor_canvas.delete("all")
        
        # Get canvas dimensions
        canvas_width = self.monitor_canvas.winfo_width()
        canvas_height = self.monitor_canvas.winfo_height()
        
        # If canvas not yet drawn, use default size
        if canvas_width <= 1:
            canvas_width = 400
        if canvas_height <= 1:
            canvas_height = 250
        
        # Calculate total screen area
        min_x = min(screen["left"] for screen in self.detected_screens)
        max_x = max(screen["left"] + screen["width"] for screen in self.detected_screens)
        min_y = min(screen["top"] for screen in self.detected_screens)
        max_y = max(screen["top"] + screen["height"] for screen in self.detected_screens)
        
        total_width = max_x - min_x
        total_height = max_y - min_y
        
        # Calculate scale factor with padding
        padding = 30
        scale_x = (canvas_width - padding * 2) / total_width
        scale_y = (canvas_height - padding * 2) / total_height
        scale = min(scale_x, scale_y) * 0.9  # Add some extra margin
        
        # Draw background grid
        grid_spacing = 20
        for x in range(padding, canvas_width - padding, grid_spacing):
            self.monitor_canvas.create_line(
                x, padding, x, canvas_height - padding,
                fill=THEME_DARK["bg_light"],
                dash=(1, 3)
            )
        
        for y in range(padding, canvas_height - padding, grid_spacing):
            self.monitor_canvas.create_line(
                padding, y, canvas_width - padding, y,
                fill=THEME_DARK["bg_light"],
                dash=(1, 3)
            )
        
        # Draw each monitor
        colors = [THEME_DARK["primary"], "#4CAF50", "#FFC107", "#FF5252"]  # Blue, Green, Amber, Red
        
        for i, screen in enumerate(self.detected_screens):
            # Calculate scaled coordinates
            x1 = padding + (screen["left"] - min_x) * scale
            y1 = padding + (screen["top"] - min_y) * scale
            x2 = x1 + screen["width"] * scale
            y2 = y1 + screen["height"] * scale
            
            # Draw monitor outline with gradient effect
            color = colors[i % len(colors)]
            
            # Draw monitor bezel (outer edge)
            bezel_width = 5
            self.monitor_canvas.create_rectangle(
                x1 - bezel_width, y1 - bezel_width, 
                x2 + bezel_width, y2 + bezel_width,
                fill=THEME_DARK["bg_dark"],
                outline=""
            )
            
            # Draw monitor frame
            self.monitor_canvas.create_rectangle(
                x1, y1, x2, y2, 
                fill=THEME_DARK["bg_dark"],
                outline=color, 
                width=2
            )
            
            # Draw monitor stand
            stand_width = (x2 - x1) * 0.3
            stand_height = 15
            self.monitor_canvas.create_rectangle(
                x1 + (x2 - x1) / 2 - stand_width / 2,
                y2 + 2,
                x1 + (x2 - x1) / 2 + stand_width / 2,
                y2 + stand_height,
                fill=THEME_DARK["bg_dark"],
                outline=color,
                width=1
            )
            
            # Draw monitor base
            base_width = stand_width * 1.5
            base_height = 5
            self.monitor_canvas.create_rectangle(
                x1 + (x2 - x1) / 2 - base_width / 2,
                y2 + stand_height,
                x1 + (x2 - x1) / 2 + base_width / 2,
                y2 + stand_height + base_height,
                fill=THEME_DARK["bg_dark"],
                outline=color,
                width=1
            )
            
            # Draw monitor label
            label = f"Monitor {i+1}"
            if screen.get("primary", False):
                label += " (Primary)"
                
            self.monitor_canvas.create_text(
                (x1 + x2) / 2, y1 + 15,
                text=label,
                fill=color,
                font=('TkDefaultFont', 10, 'bold')
            )
            
            # Draw chatbot windows on this monitor
            self.draw_chatbot_windows(i, x1, y1, x2, y2)
            
        # Add a legend
        legend_x = canvas_width - 150
        legend_y = canvas_height - 60
        
        # Legend background
        self.monitor_canvas.create_rectangle(
            legend_x - 10, legend_y - 10,
            legend_x + 140, legend_y + 50,
            fill=THEME_DARK["bg_medium"],
            outline=THEME_DARK["bg_light"],
            width=1
        )
        
        # Legend title
        self.monitor_canvas.create_text(
            legend_x + 60, legend_y,
            text="Legend",
            fill=THEME_DARK["text"],
            font=('TkDefaultFont', 9, 'bold')
        )
        
        # Active chatbot
        self.monitor_canvas.create_rectangle(
            legend_x, legend_y + 15,
            legend_x + 12, legend_y + 27,
            fill="#4CAF50",
            outline=""
        )
        
        self.monitor_canvas.create_text(
            legend_x + 20, legend_y + 21,
            text="Active Chatbot",
            fill=THEME_DARK["text"],
            font=('TkDefaultFont', 8),
            anchor="w"
        )
        
        # Inactive chatbot
        self.monitor_canvas.create_rectangle(
            legend_x, legend_y + 35,
            legend_x + 12, legend_y + 47,
            fill="#FF5252",
            outline=""
        )
        
        self.monitor_canvas.create_text(
            legend_x + 20, legend_y + 41,
            text="Inactive Chatbot",
            fill=THEME_DARK["text"],
            font=('TkDefaultFont', 8),
            anchor="w"
        )
    
    def draw_chatbot_windows(self, monitor_index, x1, y1, x2, y2):
        """Draw simulated chatbot windows on a monitor."""
        # Get chatbots
        chatbots = self.config.get("chatbots", {})
        if not chatbots:
            # Use sample data for demonstration
            chatbots = {
                "grok": {"active": True},
                "healthuniverse": {"active": True},
                "openevidence": {"active": False},
                "coral": {"active": True},
                "glasshelp": {"active": False},
                "dougalgpt": {"active": True},
                "pathway": {"active": True},
                "clinicalkey": {"active": True},
                "droacle": {"active": True}
            }
        
        # Determine which chatbots to show on this monitor
        # For better visualization, assign specific chatbots to specific monitors
        if monitor_index == 0:  # Primary monitor
            monitor_chatbots = ["dougalgpt", "pathway", "clinicalkey", "healthuniverse"]
        elif monitor_index == 1:  # Secondary monitor
            monitor_chatbots = ["grok", "droacle", "coral", "openevidence"]
        else:
            # For any additional monitors, distribute remaining chatbots
            all_assigned = ["dougalgpt", "pathway", "clinicalkey", "healthuniverse", 
                           "grok", "droacle", "coral", "openevidence"]
            monitor_chatbots = [name for name in chatbots.keys() 
                               if name not in all_assigned]
        
        # Filter to only include chatbots that exist in the config
        monitor_chatbots = [name for name in monitor_chatbots if name in chatbots]
        
        if not monitor_chatbots:
            return
        
        # Calculate layout parameters
        monitor_width = x2 - x1
        monitor_height = y2 - y1
        title_height = 30  # Height of the monitor title area
        
        # Determine grid layout based on number of chatbots
        num_chatbots = len(monitor_chatbots)
        if num_chatbots <= 2:
            grid_cols = 1
            grid_rows = num_chatbots
        elif num_chatbots <= 4:
            grid_cols = 2
            grid_rows = (num_chatbots + 1) // 2
        else:
            grid_cols = 3
            grid_rows = (num_chatbots + 2) // 3
        
        # Calculate window dimensions with proper margins
        margin = 15
        inner_margin = 10
        available_width = monitor_width - (margin * 2) - (inner_margin * (grid_cols - 1))
        available_height = monitor_height - title_height - (margin * 2) - (inner_margin * (grid_rows - 1))
        
        window_width = available_width / grid_cols
        window_height = available_height / grid_rows
        
        # Draw each chatbot window
        for i, name in enumerate(monitor_chatbots):
            row = i // grid_cols
            col = i % grid_cols
            
            # Calculate window position
            wx1 = x1 + margin + col * (window_width + inner_margin)
            wy1 = y1 + title_height + margin + row * (window_height + inner_margin)
            wx2 = wx1 + window_width
            wy2 = wy1 + window_height
            
            # Get chatbot status
            active = chatbots[name].get("active", True)
            window_color = "#4CAF50" if active else "#FF5252"
            
            # Draw window background
            self.monitor_canvas.create_rectangle(
                wx1, wy1, wx2, wy2,
                fill=THEME_DARK["bg_light"],
                outline=window_color,
                width=2
            )
            
            # Draw window title bar
            self.monitor_canvas.create_rectangle(
                wx1, wy1, wx2, wy1 + 20,
                fill=window_color,
                outline=""
            )
            
            # Draw window title
            self.monitor_canvas.create_text(
                wx1 + 10, wy1 + 10,
                text=name.capitalize(),
                fill=THEME_DARK["text"],
                font=('TkDefaultFont', 9),
                anchor="w"
            )
            
            # Draw simulated chat content
            chat_area_height = wy2 - wy1 - 50  # Leave space for title bar and input field
            
            # Draw chat messages (3-5 lines depending on window height)
            num_lines = min(5, max(3, int(chat_area_height / 20)))
            for j in range(num_lines):
                # Alternate between left and right aligned messages
                if j % 2 == 0:
                    # Left aligned (user)
                    chat_x = wx1 + 10
                    line_width = (wx2 - wx1 - 20) * (0.3 + random.random() * 0.3)
                else:
                    # Right aligned (bot)
                    chat_x = wx2 - 10 - (wx2 - wx1 - 20) * (0.4 + random.random() * 0.4)
                    line_width = (wx2 - wx1 - 20) * (0.4 + random.random() * 0.4)
                
                chat_y = wy1 + 30 + j * (chat_area_height / (num_lines + 1))
                
                # Draw the message line
                if j % 2 == 0:
                    # User message
                    self.monitor_canvas.create_line(
                        chat_x, chat_y, chat_x + line_width, chat_y,
                        fill="#A0A0C0"
                    )
                else:
                    # Bot message
                    self.monitor_canvas.create_line(
                        chat_x, chat_y, chat_x + line_width, chat_y,
                        fill=THEME_DARK["secondary"]
                    )
            
            # Draw input field at bottom
            input_y = wy2 - 15
            self.monitor_canvas.create_rectangle(
                wx1 + 10, input_y - 10, wx2 - 10, input_y + 5,
                fill=THEME_DARK["bg_medium"],
                outline=THEME_DARK["bg_light"]
            )
    
    def refresh_monitor_visualization(self):
        """Refresh the monitor visualization."""
        # Show a spinner animation on the refresh button
        original_text = self.refresh_button.cget("text")
        self.refresh_button.configure(text="⟲ Refreshing...", state="disabled")
        
        # Create a loading overlay
        if hasattr(self, 'monitor_viz_frame'):
            loading_overlay = ctk.CTkFrame(
                self.monitor_viz_frame, 
                fg_color=THEME_DARK["bg_dark"] + "CC",  # Semi-transparent
                corner_radius=5
            )
            loading_overlay.place(relx=0.5, rely=0.5, anchor="center", relwidth=1, relheight=1)
            
            # Add a loading spinner
            loading_label = ctk.CTkLabel(
                loading_overlay,
                text="Detecting Monitors...",
                font=ctk.CTkFont(size=16, weight="bold"),
                text_color=THEME_DARK["primary"]
            )
            loading_label.place(relx=0.5, rely=0.5, anchor="center")
            
            # Create a progress bar
            progress = ctk.CTkProgressBar(
                loading_overlay,
                width=200,
                height=10,
                progress_color=THEME_DARK["primary"],
                fg_color=THEME_DARK["bg_light"]
            )
            progress.place(relx=0.5, rely=0.6, anchor="center")
            progress.set(0)
            
            # Animate the progress bar
            def update_progress(value):
                if value <= 1.0:
                    progress.set(value)
                    self.root.after(50, lambda: update_progress(value + 0.05))
                else:
                    # When progress is complete, finish the refresh
                    finish_refresh()
            
            # Start the progress animation
            update_progress(0)
            
            # Function to finish the refresh
            def finish_refresh():
                # Destroy the loading overlay
                loading_overlay.destroy()
                
                # Restore the button
                self.refresh_button.configure(text=original_text, state="normal")
                
                # Detect screens again
                self.detected_screens = self.get_screen_info()
                
                # Redraw the monitors
                self.draw_monitors()
                
                # Update status with a success message
                num_screens = len(self.detected_screens)
                screen_text = "screen" if num_screens == 1 else "screens"
                self.update_status(
                    f"Refreshed monitor configuration. Found {num_screens} {screen_text}.",
                    level="success"
                )
                
                # Show a notification
                self.show_notification(
                    f"Found {num_screens} {screen_text}. Visualization updated.",
                    title="Monitor Refresh Complete",
                    level="success"
                )
        else:
            # If no visualization frame, just restore the button
            self.root.after(1000, lambda: self.refresh_button.configure(text=original_text, state="normal"))
    
    def create_voice_command_panel(self, parent):
        """Create the voice command visualization panel."""
        # Main frame with glass effect
        voice_frame = ctk.CTkFrame(
            parent, 
            fg_color=THEME_DARK["bg_medium"],
            corner_radius=15,
            border_width=1,
            border_color=THEME_DARK["card_border"],
            height=150
        )
        voice_frame.grid(row=2, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        voice_frame.grid_propagate(False)  # Force the height
        
        # Configure voice frame
        voice_frame.grid_columnconfigure(0, weight=1)  # Command display
        voice_frame.grid_columnconfigure(1, weight=0)  # Voice indicator
        
        # Title with microphone icon
        title_frame = ctk.CTkFrame(voice_frame, fg_color="transparent")
        title_frame.grid(row=0, column=0, columnspan=2, sticky="ew", padx=15, pady=(15, 5))
        
        # Title with microphone icon
        mic_icon = ctk.CTkLabel(
            title_frame,
            text="🎤",
            font=ctk.CTkFont(size=18),
            text_color=THEME_DARK["primary"]
        )
        mic_icon.pack(side="left", padx=(0, 5))
        
        voice_title = ctk.CTkLabel(
            title_frame,
            text="VOICE COMMAND",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=THEME_DARK["text"]
        )
        voice_title.pack(side="left")
        
        # Add a help button to explain voice commands
        help_button = ctk.CTkButton(
            title_frame,
            text="?",
            font=ctk.CTkFont(size=12, weight="bold"),
            width=25,
            height=25,
            corner_radius=12,
            fg_color=THEME_DARK["bg_light"],
            hover_color=THEME_DARK["bg_dark"],
            command=self.show_voice_help
        )
        help_button.pack(side="right")
        
        # Separator
        separator = ctk.CTkFrame(voice_frame, height=1, fg_color=THEME_DARK["card_border"])
        separator.grid(row=1, column=0, columnspan=2, sticky="ew", padx=15, pady=5)
        
        # Command display with prefix highlighting
        command_frame = ctk.CTkFrame(
            voice_frame, 
            fg_color=THEME_DARK["bg_dark"],
            corner_radius=10,
            border_width=1,
            border_color=THEME_DARK["card_border"],
            height=70
        )
        command_frame.grid(row=2, column=0, sticky="ew", padx=15, pady=10)
        command_frame.grid_propagate(False)  # Force the height
        
        # Centered container for the command display
        command_container = ctk.CTkFrame(command_frame, fg_color="transparent")
        command_container.place(relx=0.5, rely=0.5, anchor="center")
        
        # Prefix label (ask)
        prefix_label = ctk.CTkLabel(
            command_container,
            text="ask",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=THEME_DARK["secondary"]
        )
        prefix_label.pack(side="left", padx=(0, 5))
        
        # Command text
        self.command_text = ctk.CTkLabel(
            command_container,
            text="Waiting for voice command...",
            font=ctk.CTkFont(size=16),
            text_color=THEME_DARK["text_secondary"]
        )
        self.command_text.pack(side="left")
        
        # Voice activity indicator and controls
        voice_indicator = ctk.CTkFrame(
            voice_frame, 
            fg_color="transparent",
            width=150
        )
        voice_indicator.grid(row=2, column=1, padx=(0, 15), pady=10)
        
        # Voice activity visualization - futuristic animation
        viz_container = ctk.CTkFrame(
            voice_indicator, 
            fg_color=THEME_DARK["bg_dark"],
            corner_radius=10,
            border_width=1,
            border_color=THEME_DARK["card_border"],
            width=120,
            height=70
        )
        viz_container.pack(pady=5)
        viz_container.pack_propagate(False)  # Force the size
        
        # Create a canvas for the visualization
        self.voice_canvas = ctk.CTkCanvas(
            viz_container,
            width=100,
            height=60,
            bg=THEME_DARK["bg_dark"],
            highlightthickness=0
        )
        self.voice_canvas.place(relx=0.5, rely=0.5, anchor="center")
        
        # Draw the initial circle
        self.voice_canvas.create_oval(5, 5, 55, 55, outline=THEME_DARK["primary"], width=2, fill="")
        
        # Create a container for the status and mute button
        controls_container = ctk.CTkFrame(voice_indicator, fg_color="transparent")
        controls_container.pack(fill="x", expand=True)
        
        # Microphone status
        self.mic_status_label = ctk.CTkLabel(
            controls_container,
            text="Inactive",
            font=ctk.CTkFont(size=12),
            text_color=THEME_DARK["text_secondary"]
        )
        self.mic_status_label.pack(side="left", padx=(5, 10))
        
        # Mute button
        self.mute_button = ctk.CTkSwitch(
            controls_container,
            text="",
            width=40,
            switch_width=40,
            switch_height=20,
            fg_color=THEME_DARK["bg_light"],
            progress_color=THEME_DARK["accent_red"],  # Red for muted
            button_color=THEME_DARK["text"],
            button_hover_color=THEME_DARK["text_secondary"],
            command=self.toggle_mute
        )
        self.mute_button.pack(side="right")
    
    def show_voice_help(self):
        """Show help for voice commands."""
        # Create a popup window
        help_window = ctk.CTkToplevel(self.root)
        help_window.title("Voice Command Help")
        help_window.geometry("500x400")
        help_window.resizable(False, False)
        help_window.grab_set()  # Make it modal
        
        # Configure the window
        help_window.grid_columnconfigure(0, weight=1)
        help_window.grid_rowconfigure(0, weight=0)  # Title
        help_window.grid_rowconfigure(1, weight=1)  # Content
        help_window.grid_rowconfigure(2, weight=0)  # Button
        
        # Title
        title_frame = ctk.CTkFrame(help_window, fg_color=THEME_DARK["bg_dark"], corner_radius=0, height=60)
        title_frame.grid(row=0, column=0, sticky="nsew")
        title_frame.grid_propagate(False)  # Force the height
        
        title_label = ctk.CTkLabel(
            title_frame,
            )
            text="How to Use Voice Commands",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=THEME_DARK["text"]
        )
        title_label.place(relx=0.5, rely=0.5, anchor="center")
        
        # Content
        content_frame = ctk.CTkFrame(help_window, fg_color=THEME_DARK["bg_medium"])
        content_frame.grid(row=1, column=0, sticky="nsew", padx=20, pady=20)
        
        help_text = """
        The Dragon Voice Project lets you speak commands to multiple chatbots at once.
        
        How it works:
        
        1. Start the voice assistant using the Start button
        2. Begin your query with the command prefix "ask"
        3. Speak your medical query clearly
        4. The system will automatically send your query to all active chatbots
        
        Example commands:
        
        • "ask what are the latest treatments for hypertension"
        • "ask compare the side effects of lisinopril and amlodipine"
        • "ask what is the recommended dosage for metformin"
        
        Tips:
        
        • Speak clearly and at a moderate pace
        • Wait for the microphone indicator to show "Active"
        • You can toggle mute using the switch in the voice command panel
        • All queries are saved in the History tab for future reference
        """
        
        help_label = ctk.CTkLabel(
            content_frame,
            text=help_text,
            font=ctk.CTkFont(size=14),
            text_color=THEME_DARK["text"],
            justify="left",
            wraplength=460
        )
        help_label.pack(padx=20, pady=20, fill="both")
        
        # Close button
        button_frame = ctk.CTkFrame(help_window, fg_color="transparent")
        button_frame.grid(row=2, column=0, sticky="ew", padx=20, pady=(0, 20))
        
        close_button = ctk.CTkButton(
            button_frame,
            text="Got It",
            font=ctk.CTkFont(size=14, weight="bold"),
            fg_color=THEME_DARK["primary"],
            hover_color="#1976D2",
            width=100,
            height=32,
            command=help_window.destroy
        )
        close_button.pack(side="right")
    
    def toggle_mute(self):
        """Toggle microphone mute state."""
        if not hasattr(self, 'is_muted'):
            self.is_muted = False
            
        self.is_muted = not self.is_muted
        
        if self.is_muted:
            self.update_status("Microphone muted", level="warning")
            
            # Update visuals
            if hasattr(self, 'mic_status_label'):
                self.mic_status_label.configure(text="Muted", text_color="#FF5252")
                
            # Stop visualization if it's running
            self.mic_animation_active = False
            
            # Clear the visualization
            if hasattr(self, 'voice_canvas'):
                self.voice_canvas.delete("all")
                self.voice_canvas.create_oval(5, 5, 55, 55, outline="#FF5252", width=2, fill="")
            
            # Show notification
            self.show_notification(
                "Microphone has been muted. Voice commands will not be processed.",
                title="Microphone Muted",
                level="warning"
            )
                
        else:
            self.update_status("Microphone unmuted", level="success")
            
            # Update visuals
            if hasattr(self, 'mic_status_label'):
                self.mic_status_label.configure(text="Listening", text_color=THEME_DARK["text"])
                
            # Restart visualization if voice assistant is running
            if self.is_running:
                self.start_mic_visualization()
                
            # Show notification
            self.show_notification(
                "Microphone has been unmuted. Voice commands will be processed.",
                title="Microphone Active",
                level="success"
            )
    
    def add_sample_chatbot_cards(self):
        """Add sample chatbot cards to the dashboard."""
        # Clear existing cards
        for widget in self.chatbot_cards.winfo_children():
            widget.destroy()
        
        # Get chatbots from config
        chatbots = self.config.get("chatbots", {})
        
        if not chatbots:
            # No chatbots configured
            placeholder = ctk.CTkLabel(
                self.chatbot_cards,
                text="No chatbots configured.\nGo to the Chatbots tab to configure.",
                font=ctk.CTkFont(size=14),
                text_color=THEME_DARK["text_secondary"]
            )
            placeholder.pack(expand=True, pady=20)
            return
        
        # Add a card for each chatbot
        for name, config in chatbots.items():
            self.add_chatbot_card(name, config)
            
    def add_chatbot_card(self, name, config):
        """Add a chatbot status card."""
        card = ctk.CTkFrame(self.chatbot_cards, fg_color=THEME_DARK["bg_dark"], corner_radius=5, height=60)
        card.pack(fill="x", padx=5, pady=5)
        card.pack_propagate(False)  # Force the height
        
        # Chatbot name with first letter as icon
        icon_text = name[0].upper() if name else "?"
        
        icon_frame = ctk.CTkFrame(card, width=30, height=30, fg_color=THEME_DARK["primary"], corner_radius=15)
        icon_frame.pack(side="left", padx=10, pady=15)
        icon_frame.pack_propagate(False)  # Force the size
        
        icon_label = ctk.CTkLabel(icon_frame, text=icon_text, font=ctk.CTkFont(size=16, weight="bold"))
        icon_label.place(relx=0.5, rely=0.5, anchor="center")
        
        # Name and info
        info_frame = ctk.CTkFrame(card, fg_color="transparent")
        info_frame.pack(side="left", fill="both", expand=True, pady=10)
        
        name_label = ctk.CTkLabel(
            info_frame,
            text=name.capitalize(),
            font=ctk.CTkFont(size=14, weight="bold"),
            anchor="w"
        )
        name_label.pack(anchor="w")
        
        pattern = config.get("title_pattern", "Unknown")
        info_label = ctk.CTkLabel(
            info_frame,
            text=f"Pattern: {pattern}",
            font=ctk.CTkFont(size=11),
            text_color=THEME_DARK["text_secondary"],
            anchor="w"
        )
        info_label.pack(anchor="w")
        
        # Status indicator
        status_frame = ctk.CTkFrame(card, fg_color="transparent", width=80)
        status_frame.pack(side="right", padx=10)
        
        status_indicator = ctk.CTkFrame(status_frame, width=12, height=12, corner_radius=6, fg_color="#FF5252")
        status_indicator.pack(pady=(5, 0))
        
        status_text = ctk.CTkLabel(
            status_frame,
            text="Inactive",
            font=ctk.CTkFont(size=11),
            text_color=THEME_DARK["text_secondary"]
        )
        status_text.pack()
    
    def create_history_tab(self):
        """Create the query history tab."""
        # Main container
        history_frame = ctk.CTkFrame(self.history_tab, fg_color="transparent")
        history_frame.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        
        # Configure grid
        history_frame.grid_columnconfigure(0, weight=1)
        history_frame.grid_rowconfigure(0, weight=0)  # Header
        history_frame.grid_rowconfigure(1, weight=1)  # History list
        
        # Header frame
        header_frame = ctk.CTkFrame(history_frame, fg_color=THEME_DARK["bg_medium"], corner_radius=10)
        header_frame.grid(row=0, column=0, sticky="ew", padx=10, pady=10)
        
        # Header title
        header_title = ctk.CTkLabel(
            header_frame,
            text="QUERY HISTORY",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=THEME_DARK["text"]
        )
        header_title.pack(side="left", anchor="w", padx=15, pady=15)
        
        # Controls on the right
        controls_frame = ctk.CTkFrame(header_frame, fg_color="transparent")
        controls_frame.pack(side="right", padx=15, pady=10)
        
        # Search box
        search_entry = ctk.CTkEntry(
            controls_frame,
            placeholder_text="Search queries...",
            width=200,
            height=30,
            font=ctk.CTkFont(size=12),
            fg_color=THEME_DARK["bg_dark"],
            text_color=THEME_DARK["text"],
            border_color=THEME_DARK["bg_light"]
        )
        search_entry.pack(side="left", padx=5)
        
        # Clear button
        clear_button = ctk.CTkButton(
            controls_frame,
            text="Clear All",
            font=ctk.CTkFont(size=12),
            width=80,
            height=30,
            fg_color=THEME_DARK["bg_light"],
            hover_color="#3D3D3D",
            command=self.clear_history
        )
        clear_button.pack(side="left", padx=5)
        
        # Export button
        export_button = ctk.CTkButton(
            controls_frame,
            text="Export",
            font=ctk.CTkFont(size=12),
            width=80,
            height=30,
            fg_color=THEME_DARK["primary"],
            hover_color="#1976D2",
            command=self.export_history
        )
        export_button.pack(side="left", padx=5)
        
        # History list frame
        list_frame = ctk.CTkFrame(history_frame, fg_color=THEME_DARK["bg_medium"], corner_radius=10)
        list_frame.grid(row=1, column=0, sticky="nsew", padx=10, pady=10)
        
        # History list with scrollbar
        self.history_list = ctk.CTkScrollableFrame(
            list_frame,
            fg_color="transparent",
            scrollbar_fg_color=THEME_DARK["bg_dark"],
            scrollbar_button_color=THEME_DARK["primary"]
        )
        self.history_list.pack(fill="both", expand=True, padx=15, pady=15)
        
        # Add sample history items
        self.add_sample_history_items()
    
    def add_sample_history_items(self):
        """Add sample history items for demonstration."""
        # Clear existing items
        for widget in self.history_list.winfo_children():
            widget.destroy()
            
        # Check if we have any history
        if not self.query_history:
            # Sample data for demonstration
            sample_queries = [
                {"query": "ask what are the latest treatments for hypertension", "timestamp": "2023-11-15 14:32:45", "success": True},
                {"query": "ask compare side effects of metformin and glipizide", "timestamp": "2023-11-15 13:20:12", "success": True},
                {"query": "ask what is the recommended dosage for amoxicillin", "timestamp": "2023-11-14 16:45:30", "success": True},
                {"query": "ask explain the mechanism of action for atorvastatin", "timestamp": "2023-11-14 10:12:05", "success": False},
                {"query": "ask what are contraindications for prescribing lisinopril", "timestamp": "2023-11-13 15:30:22", "success": True}
            ]
            self.query_history = sample_queries
        
        # Add each history item
        for query_data in self.query_history:
            self.add_history_item(query_data)
    
    def add_history_item(self, query_data):
        """Add a single history item to the list."""
        # Create the history item card
        item_frame = ctk.CTkFrame(self.history_list, fg_color=THEME_DARK["bg_dark"], corner_radius=5, height=80)
        item_frame.pack(fill="x", padx=5, pady=5, ipady=5)
        item_frame.pack_propagate(False)  # Force the height
        
        # Time indicator and status indicator
        time_frame = ctk.CTkFrame(item_frame, fg_color="transparent", width=120)
        time_frame.pack(side="left", fill="y", padx=10)
        
        # Status indicator color
        status_color = "#4CAF50" if query_data.get("success", True) else "#FF5252"
        
        # Status dot
        status_dot = ctk.CTkFrame(time_frame, width=10, height=10, corner_radius=5, fg_color=status_color)
        status_dot.place(x=0, y=15)
        
        # Timestamp
        timestamp = query_data.get("timestamp", "Unknown")
        time_label = ctk.CTkLabel(
            time_frame,
            text=timestamp,
            font=ctk.CTkFont(size=12),
            text_color=THEME_DARK["text_secondary"]
        )
        time_label.place(x=15, y=12)
        
        # Query text
        query_frame = ctk.CTkFrame(item_frame, fg_color="transparent")
        query_frame.pack(side="left", fill="both", expand=True, padx=5, pady=5)
        
        query_text = query_data.get("query", "").strip()
        
        # If text starts with "ask ", highlight it differently
        prefix = ""
        actual_query = query_text
        if query_text.lower().startswith("ask "):
            prefix = "ask "
            actual_query = query_text[4:]
        
        if prefix:
            # Container for the query with prefix highlighted
            text_container = ctk.CTkFrame(query_frame, fg_color="transparent")
            text_container.pack(anchor="w", fill="x")
            
            # Prefix label (highlighted)
            prefix_label = ctk.CTkLabel(
                text_container,
                text=prefix,
                font=ctk.CTkFont(size=14, weight="bold"),
                text_color=THEME_DARK["secondary"]
            )
            prefix_label.pack(side="left")
            
            # Query text
            query_label = ctk.CTkLabel(
                text_container,
                text=actual_query,
                font=ctk.CTkFont(size=14),
                text_color=THEME_DARK["text"],
                anchor="w"
            )
            query_label.pack(side="left", fill="x")
        else:
            # Just show the whole query text
            query_label = ctk.CTkLabel(
                query_frame,
                text=query_text,
                font=ctk.CTkFont(size=14),
                text_color=THEME_DARK["text"],
                anchor="w",
                justify="left"
            )
            query_label.pack(anchor="w", fill="x")
        
        # Response count
        chatbot_count = query_data.get("chatbot_count", random.randint(1, 11))  # Random for demo
        count_label = ctk.CTkLabel(
            query_frame,
            text=f"Sent to {chatbot_count} chatbots",
            font=ctk.CTkFont(size=12),
            text_color=THEME_DARK["text_secondary"]
        )
        count_label.pack(anchor="w", pady=(5, 0))
        
        # Action buttons
        action_frame = ctk.CTkFrame(item_frame, fg_color="transparent", width=120)
        action_frame.pack(side="right", fill="y", padx=10)
        
        # Repeat button
        repeat_button = ctk.CTkButton(
            action_frame,
            text="Repeat",
            font=ctk.CTkFont(size=12),
            width=90,
            height=25,
            fg_color=THEME_DARK["primary"],
            hover_color="#1976D2",
            command=lambda q=query_text: self.repeat_query(q)
        )
        repeat_button.place(relx=0.5, rely=0.5, anchor="center")
    
    def clear_history(self):
        """Clear all history items."""
        if self.ask_confirmation("Are you sure you want to clear all query history?"):
            self.query_history = []
            for widget in self.history_list.winfo_children():
                widget.destroy()
            
            # Add an empty state message
            empty_label = ctk.CTkLabel(
                self.history_list,
                text="No query history available",
                font=ctk.CTkFont(size=14),
                text_color=THEME_DARK["text_secondary"]
            )
            empty_label.pack(pady=50)
    
    def export_history(self):
        """Export history to a file."""
        # This would show a file dialog and export the history
        # For now, just update the status
        self.update_status("History export feature not implemented yet.")
    
    def repeat_query(self, query):
        """Repeat a query from the history."""
        # This would send the query to all chatbots again
        # For now, just update the status
        self.update_status(f"Repeating query: {query}")
        
        # Show in command display
        if hasattr(self, 'command_text'):
            self.command_text.configure(text=query)

    def create_config_tab(self):
        """Create the configuration tab with settings."""
        # Create main container
        container = ctk.CTkFrame(self.tab_view.tab("Configuration"), fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Create title frame
        title_frame = ctk.CTkFrame(container, fg_color=self.colors["card_bg"], corner_radius=10)
        title_frame.pack(fill="x", padx=0, pady=(0, 20))
        
        title_label = ctk.CTkLabel(
            title_frame,
            )
            text="CONFIGURATION",
            font=ctk.CTkFont(family="Roboto", size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title_label.pack(padx=20, pady=20)
        
        # Create scrollable container for settings
        try:
            config_frame = ctk.CTkScrollableFrame(
                container,
                fg_color="transparent",
                scrollbar_fg_color=self.colors["scrollbar_bg"],
                scrollbar_button_color=self.colors["accent"],
                scrollbar_button_hover_color=self.colors["accent_hover"]
            )
            
            # Don't try to access _scrollbar_frame
            config_frame.grid_columnconfigure(0, weight=1)
            
        except Exception as e:
            logger.error(f"Error creating scrollable frame: {e}")
            # Fallback to regular frame
            config_frame = ctk.CTkFrame(container, fg_color="transparent")
            config_frame.grid_columnconfigure(0, weight=1)
        
        config_frame.pack(fill="both", expand=True, padx=0, pady=0)
        
        # =========== VOICE RECOGNITION SETTINGS ===========
        voice_frame = ctk.CTkFrame(config_frame, fg_color=self.colors["card_bg"], corner_radius=10)
        voice_frame.pack(fill="x", padx=20, pady=(0, 20))
        
        voice_title = ctk.CTkLabel(
            voice_frame,
            text="Voice Recognition Settings",
            font=ctk.CTkFont(family="Roboto", size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        voice_title.pack(anchor="w", padx=20, pady=(20, 5))
        
        separator = ctk.CTkFrame(voice_frame, height=2, fg_color=self.colors["separator"])
        separator.pack(fill="x", padx=20, pady=(0, 20))
        
        # Whisper API settings
        whisper_frame = ctk.CTkFrame(voice_frame, fg_color=self.colors["card_bg_lighter"], corner_radius=5)
        whisper_frame.pack(fill="x", padx=20, pady=(0, 20))
        
        whisper_title = ctk.CTkLabel(
            whisper_frame,
            text="OpenAI Whisper API",
            font=ctk.CTkFont(family="Roboto", size=14, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        whisper_title.pack(anchor="w", padx=20, pady=(15, 5))
        
        # Get Whisper settings
        whisper_settings = self.config.get("whisper", {})
        
        # Enabled switch
        whisper_enabled_var = ctk.IntVar(value=1 if whisper_settings.get("enabled", False) else 0)
        whisper_enabled_switch = ctk.CTkSwitch(
            whisper_frame,
            text="Use Whisper API (enhanced speech recognition)",
            font=ctk.CTkFont(family="Roboto", size=12),
            variable=whisper_enabled_var,
            onvalue=1,
            offvalue=0,
            progress_color=self.colors["accent"],
            button_color=self.colors["accent"],
            button_hover_color=self.colors["accent_hover"]
        )
        whisper_enabled_switch.pack(fill="x", padx=20, pady=(10, 5))
        self.whisper_enabled_switch = whisper_enabled_switch
        
        # API Key
        api_key_frame = ctk.CTkFrame(whisper_frame, fg_color="transparent")
        api_key_frame.pack(fill="x", padx=20, pady=(0, 5))
        
        api_key_label = ctk.CTkLabel(
            api_key_frame,
            text="API Key:",
            font=ctk.CTkFont(family="Roboto", size=12),
            text_color=self.colors["text"],
            width=100
        )
        api_key_label.pack(side="left")
        
        api_key_entry = ctk.CTkEntry(
            api_key_frame,
            placeholder_text="Enter your OpenAI API key",
            show="•",
            font=ctk.CTkFont(family="Roboto", size=12),
            text_color=self.colors["text"],
            fg_color=self.colors["entry_bg"],
            border_color=self.colors["entry_border"]
        )
        api_key_entry.pack(side="left", fill="x", expand=True)
        api_key_entry.insert(0, whisper_settings.get("api_key", ""))
        self.whisper_api_key_entry = api_key_entry
        
        # Base URL (optional)
        base_url_frame = ctk.CTkFrame(whisper_frame, fg_color="transparent")
        base_url_frame.pack(fill="x", padx=20, pady=(0, 5))
        
        base_url_label = ctk.CTkLabel(
            base_url_frame,
            text="Base URL:",
            font=ctk.CTkFont(family="Roboto", size=12),
            text_color=self.colors["text"],
            width=100
        )
        base_url_label.pack(side="left")
        
        base_url_entry = ctk.CTkEntry(
            base_url_frame,
            placeholder_text="Custom API endpoint (leave empty for default)",
            font=ctk.CTkFont(family="Roboto", size=12),
            text_color=self.colors["text"],
            fg_color=self.colors["entry_bg"],
            border_color=self.colors["entry_border"]
        )
        base_url_entry.pack(side="left", fill="x", expand=True)
        base_url_entry.insert(0, whisper_settings.get("base_url", ""))
        self.whisper_base_url_entry = base_url_entry
        
        # Model selection
        model_frame = ctk.CTkFrame(whisper_frame, fg_color="transparent")
        model_frame.pack(fill="x", padx=20, pady=(0, 5))
        
        model_label = ctk.CTkLabel(
            model_frame,
            text="Model:",
            font=ctk.CTkFont(family="Roboto", size=12),
            text_color=self.colors["text"],
            width=100
        )
        model_label.pack(side="left")
        
        models = ["whisper-1", "whisper-large-v3"]
        model_var = ctk.StringVar(value=whisper_settings.get("model", "whisper-1"))
        model_dropdown = ctk.CTkOptionMenu(
            model_frame,
            values=models,
            variable=model_var,
            font=ctk.CTkFont(family="Roboto", size=12),
            text_color=self.colors["text"],
            fg_color=self.colors["dropdown_bg"],
            button_color=self.colors["dropdown_button"],
            button_hover_color=self.colors["dropdown_button_hover"],
            dropdown_fg_color=self.colors["dropdown_menu_bg"]
        )
        model_dropdown.pack(side="left", fill="x", expand=True)
        self.whisper_model_dropdown = model_dropdown
        
        # Language selection
        language_frame = ctk.CTkFrame(whisper_frame, fg_color="transparent")
        language_frame.pack(fill="x", padx=20, pady=(0, 5))
        
        language_label = ctk.CTkLabel(
            language_frame,
            text="Language:",
            font=ctk.CTkFont(family="Roboto", size=12),
            text_color=self.colors["text"],
            width=100
        )
        language_label.pack(side="left")
        
        languages = ["auto", "en", "fr", "de", "es", "it", "pt", "nl", "ru", "zh", "ja", "ko"]
        language_var = ctk.StringVar(value=whisper_settings.get("language", "en"))
        language_dropdown = ctk.CTkOptionMenu(
            language_frame,
            values=languages,
            variable=language_var,
            font=ctk.CTkFont(family="Roboto", size=12),
            text_color=self.colors["text"],
            fg_color=self.colors["dropdown_bg"],
            button_color=self.colors["dropdown_button"],
            button_hover_color=self.colors["dropdown_button_hover"],
            dropdown_fg_color=self.colors["dropdown_menu_bg"]
        )
        language_dropdown.pack(side="left", fill="x", expand=True)
        self.whisper_language_dropdown = language_dropdown
        
        # Test button and status
        test_frame = ctk.CTkFrame(whisper_frame, fg_color="transparent")
        test_frame.pack(fill="x", padx=20, pady=(5, 15))
        
        test_button = ctk.CTkButton(
            test_frame,
            text="Test Whisper Connection",
            font=ctk.CTkFont(family="Roboto", size=12),
            fg_color=self.colors["accent"],
            hover_color=self.colors["accent_hover"],
            command=self.test_whisper_connection
        )
        test_button.pack(side="left")
        
        test_status = ctk.CTkLabel(
            test_frame,
            text="Not tested",
            font=ctk.CTkFont(family="Roboto", size=12),
            text_color=self.colors["text"]
        )
        test_status.pack(side="left", padx=(10, 0))
        self.whisper_test_status = test_status
        
        # Whisper API Tip
        tip_label = ctk.CTkLabel(
            whisper_frame,
            text="Tip: You can get an API key from OpenAI or use a compatible alternative provider.",
            font=ctk.CTkFont(family="Roboto", size=10, slant="italic"),
            text_color=self.colors["text_dim"]
        )
        tip_label.pack(fill="x", padx=20, pady=(0, 15))
        
        # =========== GENERAL SETTINGS ===========
        # Add more settings sections as needed
        # ...
        
        # =========== SAVE/RESET BUTTONS ===========
        button_frame = ctk.CTkFrame(config_frame, fg_color="transparent")
        button_frame.pack(fill="x", padx=20, pady=(20, 0))
        
        save_button = ctk.CTkButton(
            button_frame,
            text="Save Configuration",
            font=ctk.CTkFont(family="Roboto", size=14, weight="bold"),
            fg_color=self.colors["success"],
            hover_color=self.colors["success_hover"],
            command=lambda: self.save_configuration()
        )
        save_button.pack(side="left", padx=(0, 10))
        
        reset_button = ctk.CTkButton(
            button_frame,
            text="Reset to Defaults",
            font=ctk.CTkFont(family="Roboto", size=14),
            fg_color=self.colors["warning"],
            hover_color=self.colors["warning_hover"],
            command=self.reset_configuration
        )
        reset_button.pack(side="left")
        
        # Update configuration references for existing UI elements
        # This allows the configuration to be properly saved when changed
    
    def get_available_microphones(self):
        """Get a list of available microphone devices."""
        mic_devices = {"Default": 0}
        
        try:
            import speech_recognition as sr
            for index, name in enumerate(sr.Microphone.list_microphone_names()):
                mic_devices[name] = index
        except Exception as e:
            logger.warning(f"Could not get microphone list: {e}")
            
        return mic_devices
    
    def refresh_mic_devices(self):
        """Refresh the list of microphone devices."""
        self.mic_devices = self.get_available_microphones()
        
        # Update the dropdown with new values
        if hasattr(self, 'mic_device_var'):
            device_names = list(self.mic_devices.keys())
            
            # Find the dropdown and update it
            for widget in self.config_tab.winfo_children():
                if isinstance(widget, ctk.CTkFrame):
                    for child in widget.winfo_children():
                        if isinstance(child, ctk.CTkScrollableFrame):
                            # Check all widgets in the scroll frame
                            for section in child.winfo_children():
                                if isinstance(section, ctk.CTkFrame):
                                    for frame in section.winfo_children():
                                        if isinstance(frame, ctk.CTkFrame):
                                            for option_menu in frame.winfo_children():
                                                if isinstance(option_menu, ctk.CTkOptionMenu):
                                                    try:
                                                        option_menu.configure(values=device_names)
                                                    except:
                                                        pass
            
            # Set to first device
            if device_names:
                self.mic_device_var.set(device_names[0])
                
        # Show notification
        self.show_notification(
            f"Found {len(self.mic_devices)} microphone devices",
            title="Microphones Refreshed",
            level="success"
        )
    
    def on_mic_device_change(self, device_name):
        """Handle microphone device selection change."""
        if "microphone" not in self.config:
            self.config["microphone"] = {}
            
        self.config["microphone"]["device"] = device_name
        self.config["microphone"]["device_id"] = self.mic_devices.get(device_name, 0)
        
        # Instead of calling save_configuration directly, just update the status
        try:
            # Save the config to file
            with open(self.config_path, "w") as f:
                json.dump(self.config, f, indent=4)
        except Exception as e:
            logger.error(f"Error saving microphone configuration: {e}")
        
        # Update status
        self.update_status(f"Microphone set to: {device_name}", level="info")
    
    def update_mic_sensitivity(self, value=None):
        """Update the microphone sensitivity."""
        if hasattr(self, 'sensitivity_value_label'):
            # Update the label
            sensitivity = int(self.mic_sensitivity_var.get() * 100)
            self.sensitivity_value_label.configure(text=f"{sensitivity}%")
            
            # Save to config
            if "microphone" not in self.config:
                self.config["microphone"] = {}
                
            self.config["microphone"]["sensitivity"] = self.mic_sensitivity_var.get()
            
            # We don't save to file here to avoid errors
    
    def open_mic_test_dialog(self):
        """Open a dialog to test the microphone."""
        # Create a dialog window
        dialog = ctk.CTkToplevel(self.root)
        dialog.title("Test Microphone")
        dialog.geometry("600x400")
        dialog.grab_set()  # Make it modal
        
        # Center on screen
        dialog.update_idletasks()
        width = dialog.winfo_width()
        height = dialog.winfo_height()
        x = (dialog.winfo_screenwidth() // 2) - (width // 2)
        y = (dialog.winfo_screenheight() // 2) - (height // 2)
        dialog.geometry(f'{width}x{height}+{x}+{y}')
        
        # Create a label
        label = ctk.CTkLabel(
            dialog,
            text="Microphone testing will be available in a future update.\n\nPlease check back soon!",
            font=ctk.CTkFont(size=16),
            wraplength=500
        )
        label.pack(expand=True, fill="both", padx=20, pady=20)
        
        # Close button
        close_button = ctk.CTkButton(
            dialog,
            text="Close",
            command=dialog.destroy
        )
        close_button.pack(pady=20)
    
    def create_chatbot_tab(self):
        """Create the chatbot configuration tab."""
        # Main container
        chatbot_frame = ctk.CTkFrame(self.chatbot_tab, fg_color="transparent")
        chatbot_frame.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        
        # Configure grid
        chatbot_frame.grid_columnconfigure(0, weight=1)
        chatbot_frame.grid_rowconfigure(0, weight=0)  # Title
        chatbot_frame.grid_rowconfigure(1, weight=1)  # Chatbot list & editor
        
        # Title frame
        title_frame = ctk.CTkFrame(chatbot_frame, fg_color=THEME_DARK["bg_medium"], corner_radius=10)
        title_frame.grid(row=0, column=0, sticky="ew", padx=10, pady=10)
        
        # Title
        title = ctk.CTkLabel(
            title_frame,
            text="CHATBOT CONFIGURATION",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=THEME_DARK["text"]
        )
        title.pack(side="left", anchor="w", padx=15, pady=15)
        
        # Add button
        add_button = ctk.CTkButton(
            title_frame,
            text="+ Add Chatbot",
            font=ctk.CTkFont(size=12),
            width=120,
            height=30,
            fg_color=THEME_DARK["primary"],
            hover_color="#1976D2",
            command=self.add_new_chatbot
        )
        add_button.pack(side="right", padx=15)
        
        # Main content frame with 2 columns
        content_frame = ctk.CTkFrame(chatbot_frame, fg_color=THEME_DARK["bg_medium"], corner_radius=10)
        content_frame.grid(row=1, column=0, sticky="nsew", padx=10, pady=10)
        
        # Configure content grid
        content_frame.grid_columnconfigure(0, weight=1)  # Chatbot list
        content_frame.grid_columnconfigure(1, weight=2)  # Chatbot editor
        content_frame.grid_rowconfigure(0, weight=1)
        
        # Chatbot list frame
        list_frame = ctk.CTkFrame(content_frame, fg_color=THEME_DARK["bg_dark"], corner_radius=5)
        list_frame.grid(row=0, column=0, sticky="nsew", padx=15, pady=15)
        
        # Chatbot list title
        list_title = ctk.CTkLabel(
            list_frame,
            text="Available Chatbots",
            font=ctk.CTkFont(size=14, weight="bold"),
            text_color=THEME_DARK["text"]
        )
        list_title.pack(anchor="w", padx=15, pady=15)
        
        # Separator
        list_separator = ctk.CTkFrame(list_frame, height=1, fg_color=THEME_DARK["bg_light"])
        list_separator.pack(fill="x", padx=15, pady=5)
        
        # Scrollable chatbot list
        self.chatbot_list = ctk.CTkScrollableFrame(
            list_frame,
            fg_color="transparent",
            scrollbar_fg_color=THEME_DARK["bg_medium"],
            scrollbar_button_color=THEME_DARK["primary"]
        )
        self.chatbot_list.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Chatbot editor frame
        editor_frame = ctk.CTkFrame(content_frame, fg_color=THEME_DARK["bg_dark"], corner_radius=5)
        editor_frame.grid(row=0, column=1, sticky="nsew", padx=15, pady=15)
        
        # Chatbot editor title
        self.editor_title = ctk.CTkLabel(
            editor_frame,
            text="Chatbot Configuration",
            font=ctk.CTkFont(size=14, weight="bold"),
            text_color=THEME_DARK["text"]
        )
        self.editor_title.pack(anchor="w", padx=15, pady=15)
        
        # Separator
        editor_separator = ctk.CTkFrame(editor_frame, height=1, fg_color=THEME_DARK["bg_light"])
        editor_separator.pack(fill="x", padx=15, pady=5)
        
        # Chatbot editor content
        self.editor_content = ctk.CTkFrame(editor_frame, fg_color="transparent")
        self.editor_content.pack(fill="both", expand=True, padx=15, pady=15)
        
        # Populate the list
        self.populate_chatbot_list()
        
        # Show empty editor initially
        self.show_empty_editor()
    
    def populate_chatbot_list(self):
        """Populate the chatbot list from config."""
        # Clear existing items
        for widget in self.chatbot_list.winfo_children():
            widget.destroy()
        
        # Get chatbots from config
        chatbots = self.config.get("chatbots", {})
        
        if not chatbots:
            # No chatbots configured
            empty_label = ctk.CTkLabel(
                self.chatbot_list,
                text="No chatbots configured.\nClick '+ Add Chatbot' to create one.",
                font=ctk.CTkFont(size=12),
                text_color=THEME_DARK["text_secondary"]
            )
            empty_label.pack(pady=50)
            return
        
        # Add each chatbot
        for name, config in chatbots.items():
            self.add_chatbot_list_item(name, config)
    
    def add_chatbot_list_item(self, name, config):
        """Add a chatbot item to the list."""
        # Item frame
        item_frame = ctk.CTkFrame(self.chatbot_list, fg_color="transparent", height=40)
        item_frame.pack(fill="x", pady=5)
        item_frame.pack_propagate(False)  # Force the height
        
        # Configure item layout
        item_frame.grid_columnconfigure(0, weight=1)  # Name
        item_frame.grid_columnconfigure(1, weight=0)  # Actions
        
        # Chatbot name with first letter as icon
        icon_text = name[0].upper() if name else "?"
        
        name_frame = ctk.CTkFrame(item_frame, fg_color="transparent")
        name_frame.grid(row=0, column=0, sticky="w", padx=5)
        
        icon_frame = ctk.CTkFrame(name_frame, width=24, height=24, fg_color=THEME_DARK["primary"], corner_radius=12)
        icon_frame.pack(side="left", padx=5)
        icon_frame.pack_propagate(False)  # Force the size
        
        icon_label = ctk.CTkLabel(icon_frame, text=icon_text, font=ctk.CTkFont(size=12, weight="bold"))
        icon_label.place(relx=0.5, rely=0.5, anchor="center")
        
        name_label = ctk.CTkLabel(
            name_frame,
            text=name.capitalize(),
            font=ctk.CTkFont(size=12),
            text_color=THEME_DARK["text"]
        )
        name_label.pack(side="left", padx=8)
        
        # Actions frame
        actions_frame = ctk.CTkFrame(item_frame, fg_color="transparent")
        actions_frame.grid(row=0, column=1, sticky="e", padx=5)
        
        # Edit button
        edit_button = ctk.CTkButton(
            actions_frame,
            text="Edit",
            font=ctk.CTkFont(size=11),
            width=50,
            height=24,
            fg_color=THEME_DARK["bg_light"],
            hover_color="#3D3D3D",
            command=lambda n=name, c=config: self.edit_chatbot(n, c)
        )
        edit_button.pack(side="left", padx=2)
        
        # Delete button
        delete_button = ctk.CTkButton(
            actions_frame,
            text="Delete",
            font=ctk.CTkFont(size=11),
            width=50,
            height=24,
            fg_color="#FF5252",
            hover_color="#D32F2F",
            command=lambda n=name: self.delete_chatbot(n)
        )
        delete_button.pack(side="left", padx=2)
        
        # Make the whole item clickable
        item_frame.bind("<Button-1>", lambda e, n=name, c=config: self.edit_chatbot(n, c))
        name_frame.bind("<Button-1>", lambda e, n=name, c=config: self.edit_chatbot(n, c))
        name_label.bind("<Button-1>", lambda e, n=name, c=config: self.edit_chatbot(n, c))
    
    def show_empty_editor(self):
        """Show empty editor state."""
        # Clear editor content
        for widget in self.editor_content.winfo_children():
            widget.destroy()
        
        # Update title
        self.editor_title.configure(text="Chatbot Configuration")
        
        # Show placeholder
        placeholder = ctk.CTkLabel(
            self.editor_content,
            text="Select a chatbot from the list to edit,\nor click '+ Add Chatbot' to create a new one.",
            font=ctk.CTkFont(size=12),
            text_color=THEME_DARK["text_secondary"]
        )
        placeholder.pack(pady=50)
    
    def edit_chatbot(self, name, config):
        """Show the chatbot editor."""
        # Clear any existing editor content
        for widget in self.chatbot_editor_frame.winfo_children():
            widget.destroy()
        
        # Create editor title
        title_frame = ctk.CTkFrame(self.chatbot_editor_frame, fg_color="transparent")
        title_frame.pack(fill="x", padx=20, pady=(20, 10))
        
        title_label = ctk.CTkLabel(
            title_frame,
            )
            text=f"Edit Chatbot: {name}",
            font=ctk.CTkFont(family="Roboto", size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title_label.pack(side="left", padx=0, pady=0)
        
        # Create form for editing
        form_frame = ctk.CTkFrame(self.chatbot_editor_frame, fg_color=self.colors["card_bg"], corner_radius=10)
        form_frame.pack(fill="both", expand=True, padx=20, pady=(0, 20))
        
        # Name field
        name_frame = ctk.CTkFrame(form_frame, fg_color="transparent")
        name_frame.pack(fill="x", padx=20, pady=(20, 10))
        
        name_label = ctk.CTkLabel(
            name_frame,
            text="Name:",
            font=ctk.CTkFont(family="Roboto", size=12),
            text_color=self.colors["text"]
        )
        name_label.pack(side="left", padx=(0, 10))
        
        name_entry = ctk.CTkEntry(
            name_frame,
            placeholder_text="Enter chatbot name",
            font=ctk.CTkFont(family="Roboto", size=12),
            text_color=self.colors["text"],
            fg_color=self.colors["entry_bg"],
            border_color=self.colors["entry_border"]
        )
        name_entry.pack(side="left", fill="x", expand=True)
        name_entry.insert(0, name)
        
        # Window title pattern
        title_frame = ctk.CTkFrame(form_frame, fg_color="transparent")
        title_frame.pack(fill="x", padx=20, pady=10)
        
        title_label = ctk.CTkLabel(
            title_frame,
            )
            text="Window Title Pattern:",
            font=ctk.CTkFont(family="Roboto", size=12),
            text_color=self.colors["text"]
        )
        title_label.pack(side="left", padx=(0, 10))
        
        title_entry = ctk.CTkEntry(
            title_frame,
            placeholder_text="Enter window title pattern to match",
            font=ctk.CTkFont(family="Roboto", size=12),
            text_color=self.colors["text"],
            fg_color=self.colors["entry_bg"],
            border_color=self.colors["entry_border"]
        )
        title_entry.pack(side="left", fill="x", expand=True)
        title_entry.insert(0, config.get("title_pattern", ""))
        
        # Input position
        position_frame = ctk.CTkFrame(form_frame, fg_color=self.colors["card_bg_lighter"], corner_radius=5)
        position_frame.pack(fill="x", padx=20, pady=10)
        
        position_title = ctk.CTkLabel(
            position_frame,
            text="Input Field Position",
            font=ctk.CTkFont(family="Roboto", size=12, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        position_title.pack(anchor="w", padx=10, pady=(10, 5))
        
        # Position description
        position_desc = ctk.CTkLabel(
            position_frame,
            text="These coordinates specify where to click to focus the input field",
            font=ctk.CTkFont(family="Roboto", size=10),
            text_color=self.colors["text_dim"]
        )
        position_desc.pack(anchor="w", padx=10, pady=(0, 10))
        
        # X coordinate
        x_frame = ctk.CTkFrame(position_frame, fg_color="transparent")
        x_frame.pack(fill="x", padx=10, pady=(0, 5))
        
        x_label = ctk.CTkLabel(
            x_frame,
            text="X Coordinate:",
            font=ctk.CTkFont(family="Roboto", size=12),
            text_color=self.colors["text"]
        )
        x_label.pack(side="left", padx=(0, 10))
        
        x_entry = ctk.CTkEntry(
            x_frame,
            placeholder_text="X position (horizontal)",
            font=ctk.CTkFont(family="Roboto", size=12),
            text_color=self.colors["text"],
            fg_color=self.colors["entry_bg"],
            border_color=self.colors["entry_border"],
            width=80
        )
        x_entry.pack(side="left")
        
        # Parse input position
        input_position = config.get("input_position", "0,0")
        x_pos, y_pos = "0", "0"
        
        try:
            if isinstance(input_position, str) and "," in input_position:
                x_pos, y_pos = input_position.split(",")
            elif isinstance(input_position, list) and len(input_position) >= 2:
                x_pos, y_pos = str(input_position[0]), str(input_position[1])
        except:
            pass
        
        x_entry.insert(0, x_pos.strip())
        
        # Visual coordinates display
        coords_display = ctk.CTkFrame(x_frame, fg_color=self.colors["bg_darker"], corner_radius=5, height=30)
        coords_display.pack(side="left", fill="x", expand=True, padx=(10, 0))
        
        coordinates_label = ctk.CTkLabel(
            coords_display,
            text=f"Input Position: {x_pos.strip()}, {y_pos.strip()}",
            font=ctk.CTkFont(family="Roboto", size=12),
            text_color=self.colors["accent"]
        )
        coordinates_label.pack(padx=10, pady=5)
        
        # Y coordinate
        y_frame = ctk.CTkFrame(position_frame, fg_color="transparent")
        y_frame.pack(fill="x", padx=10, pady=(0, 10))
        
        y_label = ctk.CTkLabel(
            y_frame,
            text="Y Coordinate:",
            font=ctk.CTkFont(family="Roboto", size=12),
            text_color=self.colors["text"]
        )
        y_label.pack(side="left", padx=(0, 10))
        
        y_entry = ctk.CTkEntry(
            y_frame,
            placeholder_text="Y position (vertical)",
            font=ctk.CTkFont(family="Roboto", size=12),
            text_color=self.colors["text"],
            fg_color=self.colors["entry_bg"],
            border_color=self.colors["entry_border"],
            width=80
        )
        y_entry.pack(side="left")
        y_entry.insert(0, y_pos.strip())
        
        # Find position button
        find_button = ctk.CTkButton(
            y_frame,
            text="Find Position",
            font=ctk.CTkFont(family="Roboto", size=12),
            fg_color=self.colors["accent"],
            hover_color=self.colors["accent_hover"],
            command=lambda: self.find_input_position(x_entry, y_entry)
        )
        find_button.pack(side="left", padx=(10, 0))
        
        # Update coordinates label when entries change
        def update_coords_label(*args):
            coordinates_label.configure(text=f"Input Position: {x_entry.get()}, {y_entry.get()}")
        
        x_entry._entry.bind("<KeyRelease>", update_coords_label)
        y_entry._entry.bind("<KeyRelease>", update_coords_label)
        
        # Send method
        send_frame = ctk.CTkFrame(form_frame, fg_color="transparent")
        send_frame.pack(fill="x", padx=20, pady=10)
        
        send_label = ctk.CTkLabel(
            send_frame,
            text="Send Method:",
            font=ctk.CTkFont(family="Roboto", size=12),
            text_color=self.colors["text"]
        )
        send_label.pack(side="left", padx=(0, 10))
        
        send_var = ctk.StringVar(value=config.get("send_method", "enter"))
        send_dropdown = ctk.CTkOptionMenu(
            send_frame,
            values=["enter", "button"],
            variable=send_var,
            font=ctk.CTkFont(family="Roboto", size=12),
            text_color=self.colors["text"],
            fg_color=self.colors["dropdown_bg"],
            button_color=self.colors["dropdown_button"],
            button_hover_color=self.colors["dropdown_button_hover"],
            dropdown_fg_color=self.colors["dropdown_menu_bg"]
        )
        send_dropdown.pack(side="left", fill="x", expand=True)
        
        # Typing delay
        delay_frame = ctk.CTkFrame(form_frame, fg_color="transparent")
        delay_frame.pack(fill="x", padx=20, pady=(10, 20))
        
        delay_label = ctk.CTkLabel(
            delay_frame,
            text="Typing Delay:",
            font=ctk.CTkFont(family="Roboto", size=12),
            text_color=self.colors["text"]
        )
        delay_label.pack(side="left", padx=(0, 10))
        
        # Get typing delay or use default
        typing_delay = config.get("typing_delay", 0.05)
        try:
            typing_delay = float(typing_delay)
        except:
            typing_delay = 0.05
        
        delay_value = ctk.DoubleVar(value=typing_delay)
        delay_slider = ctk.CTkSlider(
            delay_frame,
            from_=0.01,
            to=0.2,
            variable=delay_value,
            number_of_steps=19,
            progress_color=self.colors["accent"],
            button_color=self.colors["accent"],
            button_hover_color=self.colors["accent_hover"]
        )
        delay_slider.pack(side="left", fill="x", expand=True, padx=(0, 10))
        
        delay_value_label = ctk.CTkLabel(
            delay_frame,
            text=f"{typing_delay:.2f}s",
            font=ctk.CTkFont(family="Roboto", size=12),
            text_color=self.colors["text"],
            width=40
        )
        delay_value_label.pack(side="left")
        
        # Update the delay value label when the slider changes
        def update_delay_label(value):
            delay_value_label.configure(text=f"{float(value):.2f}s")
        
        delay_slider.configure(command=update_delay_label)
        
        # Buttons
        button_frame = ctk.CTkFrame(form_frame, fg_color="transparent")
        button_frame.pack(fill="x", padx=20, pady=(0, 20))
        
        # Test button
        test_button = ctk.CTkButton(
            button_frame,
            text="Test Chatbot",
            font=ctk.CTkFont(family="Roboto", size=12),
            fg_color=self.colors["accent"],
            hover_color=self.colors["accent_hover"],
            command=lambda: self.test_chatbot(
                name_entry.get(),
                title_entry.get(),
                f"{x_entry.get()},{y_entry.get()}",
                send_var.get(),
                delay_value.get()
            )
        )
        test_button.pack(side="left", padx=(0, 10))
        
        # Save button
        save_button = ctk.CTkButton(
            button_frame,
            text="Save Changes",
            font=ctk.CTkFont(family="Roboto", size=12, weight="bold"),
            fg_color=self.colors["success"],
            hover_color=self.colors["success_hover"],
            command=lambda: self.save_chatbot(
                name,
                name_entry.get(),
                title_entry.get(),
                f"{x_entry.get()},{y_entry.get()}",
                send_var.get(),
                delay_value.get()
            )
        )
        save_button.pack(side="left", padx=(0, 10))
        
        # Cancel button
        cancel_button = ctk.CTkButton(
            button_frame,
            text="Cancel",
            font=ctk.CTkFont(family="Roboto", size=12),
            fg_color=self.colors["cancel_button"],
            hover_color=self.colors["cancel_hover"],
            command=self.show_empty_editor
        )
        cancel_button.pack(side="left")
    
    def add_new_chatbot(self):
        """Add a new chatbot."""
        # Generate a unique name
        base_name = "new_chatbot"
        name = base_name
        count = 1
        
        # Check if name exists
        while name in self.config.get("chatbots", {}):
            name = f"{base_name}_{count}"
            count += 1
        
        # Default config
        config = {
            "title_pattern": "ChatGPT",
            "input_position": [500, 700],
            "send_method": "enter",
            "typing_delay": 0.05
        }
        
        # Edit the new chatbot
        self.edit_chatbot(name, config)
    
    def delete_chatbot(self, name):
        """Delete a chatbot from configuration."""
        if self.ask_confirmation(f"Are you sure you want to delete the chatbot '{name}'?"):
            # In a real implementation, this would remove the chatbot from config
            # and save the changes
            self.update_status(f"Chatbot '{name}' deleted!", level="success")
            
            # Refresh list and show empty editor
            self.populate_chatbot_list()
            self.show_empty_editor()
    
    def save_chatbot(self, original_name, new_name, title_pattern, input_position, send_method, typing_delay):
        """Save chatbot configuration."""
        if not new_name:
            self.show_notification(
                "Chatbot name cannot be empty",
                title="Validation Error",
                level="error"
            )
            return
        
        if not title_pattern:
            self.show_notification(
                "Window title pattern cannot be empty",
                title="Validation Error",
                level="error"
            )
            return
        
        # Parse input position
        try:
            if isinstance(input_position, str):
                # Handle both "x,y" and [x, y] formats
                if "," in input_position:
                    x, y = input_position.split(",")
                    input_position = [int(x.strip()), int(y.strip())]
                else:
                    self.show_notification(
                        "Invalid input position format. Use 'X,Y'",
                        title="Validation Error",
                        level="error"
                    )
                    return
            elif isinstance(input_position, list) and len(input_position) >= 2:
                # Ensure position is a list of integers
                input_position = [int(input_position[0]), int(input_position[1])]
            else:
                self.show_notification(
                    "Invalid input position",
                    title="Validation Error",
                    level="error"
                )
                return
        except ValueError:
            self.show_notification(
                "Input position must be valid numbers",
                title="Validation Error",
                level="error"
            )
            return
        
        # Create or update chatbot config
        chatbot_config = {
            "title_pattern": title_pattern,
            "input_position": input_position,
            "send_method": send_method,
            "typing_delay": typing_delay
        }
        
        # Update chatbots dictionary
        chatbots = self.config.setdefault("chatbots", {})
        
        # Remove old entry if name changed
        if original_name != new_name and original_name in chatbots:
            del chatbots[original_name]
        
        # Add new entry
        chatbots[new_name] = chatbot_config
        
        # Save configuration
        self.save_configuration()
        
        # Update UI
        self.populate_chatbot_list()
        self.show_empty_editor()
        
        # Show success notification
        self.show_notification(
            f"Chatbot '{new_name}' saved successfully",
            title="Chatbot Saved",
            level="success"
        )
        
        # Refresh dashboard chatbot cards
        if hasattr(self, 'add_sample_chatbot_cards'):
            self.add_sample_chatbot_cards()
    
    def find_input_position(self, x_entry, y_entry):
        """Launch the coordinate finder and update position entries."""
        # In a real implementation, this would launch coordinate_finder.py
        # and get the coordinates from it
        
        self.update_status("Launching coordinate finder... Please position the cursor over the input field and press Enter.", level="info")
        
        # Simulate finding coordinates
        self.root.after(3000, lambda: self.update_position_entries(x_entry, y_entry, 600, 650))
    
    def update_position_entries(self, x_entry, y_entry, x, y):
        """Update position entries with found coordinates."""
        # Clear entries
        x_entry.delete(0, "end")
        y_entry.delete(0, "end")
        
        # Set new values
        x_entry.insert(0, str(x))
        y_entry.insert(0, str(y))
        
        self.update_status(f"Coordinates found: X={x}, Y={y}", level="success")
    
    def test_chatbot(self, name, title_pattern, input_position, send_method, typing_delay):
        """Test chatbot configuration."""
        # In a real implementation, this would attempt to find and
        # interact with the chatbot window
        
        self.update_status(f"Testing chatbot '{name}'...", level="info")
        
        # Simulate successful test
        self.root.after(2000, lambda: self.update_status(f"Chatbot '{name}' tested successfully!", level="success"))
    
    def create_about_tab(self):
        """Create the about tab."""
        # Main container
        about_frame = ctk.CTkFrame(self.about_tab, fg_color="transparent")
        about_frame.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        
        # Configure grid
        about_frame.grid_columnconfigure(0, weight=1)
        about_frame.grid_rowconfigure(0, weight=1)
        
        # Content frame
        content_frame = ctk.CTkFrame(about_frame, fg_color=THEME_DARK["bg_medium"], corner_radius=10)
        content_frame.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        
        # Center everything
        content_frame.grid_columnconfigure(0, weight=1)
        content_frame.grid_rowconfigure(1, weight=2)
        
        # Logo and title
        header_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        header_frame.grid(row=0, column=0, sticky="ew", padx=20, pady=20)
        
        # Try to load the logo
        try:
            logo_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "assets", "dragon_logo.png")
            if os.path.exists(logo_path):
                logo_img = ctk.CTkImage(light_image=Image.open(logo_path), 
                                        dark_image=Image.open(logo_path),
                                        size=(120, 120))
                logo_label = ctk.CTkLabel(header_frame, image=logo_img, text="")
                logo_label.pack(pady=10)
            else:
                # If no logo image, use text
                logo_label = ctk.CTkLabel(header_frame, text="🐉", font=ctk.CTkFont(size=80, weight="bold"))
                logo_label.pack(pady=10)
        except Exception as e:
            logger.warning(f"Could not load logo: {e}")
            # Fallback to text
            logo_label = ctk.CTkLabel(header_frame, text="🐉", font=ctk.CTkFont(size=80, weight="bold"))
            logo_label.pack(pady=10)
        
        # App title
        app_title = ctk.CTkLabel(
            header_frame,
            text="Dragon Voice Project",
            font=ctk.CTkFont(size=28, weight="bold"),
            text_color=THEME_DARK["text"]
        )
        app_title.pack(pady=5)
        
        # Version
        version_label = ctk.CTkLabel(
            header_frame,
            text=f"Version {APP_VERSION}",
            font=ctk.CTkFont(size=14),
            text_color=THEME_DARK["text_secondary"]
        )
        version_label.pack()
        
        # Description
        desc_frame = ctk.CTkScrollableFrame(
            content_frame,
            fg_color=THEME_DARK["bg_dark"],
            corner_radius=5,
            scrollbar_fg_color=THEME_DARK["bg_light"],
            scrollbar_button_color=THEME_DARK["primary"]
        )
        desc_frame.grid(row=1, column=0, sticky="nsew", padx=40, pady=(0, 30))
        
        # Description text
        description = """
        The Dragon Voice Project is a voice-controlled multi-chatbot system designed to enhance research efficiency with Dragon Medical One.
        
        It lets medical professionals voice-control multiple AI chatbots simultaneously, sending the same query to different medical AI assistants across multiple windows. This dramatically speeds up medical information retrieval by replacing manual typing and window switching.
        
        Key Features:
        • Voice-Activated Chatbots
        • Multi-Chatbot Control
        • Flexible Integration
        • Customizable Configuration
        • Visual Feedback
        • Automatic Startup
        
        This application is designed to work with various medical AI chatbots, including Grok, HealthUniverse, OpenEvidence, Coral AI, GlassHelp, Bearly, RobertLab, Dr. Oracle, DougallGPT, ClinicalKey, and Pathway.
        
        For more information and documentation, please visit the GitHub repository or contact the support team.
        """
        
        desc_label = ctk.CTkLabel(
            desc_frame,
            text=description,
            font=ctk.CTkFont(size=14),
            text_color=THEME_DARK["text"],
            justify="left",
            wraplength=500
        )
        desc_label.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Links
        links_frame = ctk.CTkFrame(desc_frame, fg_color="transparent")
        links_frame.pack(fill="x", padx=20, pady=(0, 20))
        
        # Documentation link
        docs_button = ctk.CTkButton(
            links_frame,
            text="Documentation",
            font=ctk.CTkFont(size=12),
            width=120,
            height=30,
            fg_color=THEME_DARK["primary"],
            hover_color="#1976D2",
            command=lambda: webbrowser.open("https://github.com/yourusername/DragonVoiceProject/wiki")
        )
        docs_button.pack(side="left", padx=5)
        
        # GitHub link
        github_button = ctk.CTkButton(
            links_frame,
            text="GitHub Repository",
            font=ctk.CTkFont(size=12),
            width=120,
            height=30,
            fg_color=THEME_DARK["bg_light"],
            hover_color="#3D3D3D",
            command=lambda: webbrowser.open("https://github.com/yourusername/DragonVoiceProject")
        )
        github_button.pack(side="left", padx=5)
        
        # Report issue link
        issue_button = ctk.CTkButton(
            links_frame,
            text="Report Issue",
            font=ctk.CTkFont(size=12),
            width=120,
            height=30,
            fg_color=THEME_DARK["bg_light"],
            hover_color="#3D3D3D",
            command=lambda: webbrowser.open("https://github.com/yourusername/DragonVoiceProject/issues")
        )
        issue_button.pack(side="left", padx=5)

    def create_status_panel(self, parent):
        """Create the status panel with key metrics."""
        status_frame = ctk.CTkFrame(parent, fg_color=THEME_DARK["bg_medium"], corner_radius=10, height=120)
        status_frame.grid(row=0, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        status_frame.grid_propagate(False)  # Force the height
        
        # Configure status frame
        status_frame.grid_columnconfigure(0, weight=1)  # Title
        status_frame.grid_columnconfigure(1, weight=0)  # Status grid
        
        # Title with dashboard icon
        title_frame = ctk.CTkFrame(status_frame, fg_color="transparent")
        title_frame.grid(row=0, column=0, sticky="w", padx=15, pady=(15, 5))
        
        dashboard_icon = ctk.CTkLabel(
            title_frame,
            text="📊",
            font=ctk.CTkFont(size=18),
            text_color=THEME_DARK["primary"]
        )
        dashboard_icon.pack(side="left", padx=(0, 5))
        
        title = ctk.CTkLabel(
            title_frame,
            text="SYSTEM STATUS",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=THEME_DARK["text"]
        )
        title.pack(side="left")
        
        # Current time display
        time_frame = ctk.CTkFrame(status_frame, fg_color="transparent")
        time_frame.grid(row=0, column=1, sticky="e", padx=15, pady=(15, 5))
        
        self.time_label = ctk.CTkLabel(
            time_frame,
            text=datetime.now().strftime("%H:%M:%S"),
            font=ctk.CTkFont(size=14),
            text_color=THEME_DARK["text_secondary"]
        )
        self.time_label.pack(side="right")
        
        # Update time every second
        def update_time():
            if hasattr(self, 'time_label'):
                self.time_label.configure(text=datetime.now().strftime("%H:%M:%S"))
                self.root.after(1000, update_time)
        
        self.root.after(1000, update_time)
        
        # Separator
        separator = ctk.CTkFrame(status_frame, height=1, fg_color=THEME_DARK["bg_light"])
        separator.grid(row=1, column=0, columnspan=2, sticky="ew", padx=15, pady=5)
        
        # Status grid
        status_grid = ctk.CTkFrame(status_frame, fg_color="transparent")
        status_grid.grid(row=2, column=0, columnspan=2, sticky="ew", padx=15, pady=5)
        
        # Configure status grid
        status_grid.grid_columnconfigure(0, weight=1)  # Voice Assistant Status
        status_grid.grid_columnconfigure(1, weight=1)  # Chatbots Ready
        status_grid.grid_columnconfigure(2, weight=1)  # Queries Processed
        status_grid.grid_columnconfigure(3, weight=1)  # Last Activity
        
        # Voice Assistant Status
        va_frame = ctk.CTkFrame(status_grid, fg_color=THEME_DARK["card_bg"], corner_radius=5)
        va_frame.grid(row=0, column=0, sticky="ew", padx=5, pady=5)
        
        va_label = ctk.CTkLabel(
            va_frame,
            text="Voice Assistant",
            font=ctk.CTkFont(size=12),
            text_color=THEME_DARK["text_secondary"]
        )
        va_label.pack(anchor="w", padx=10, pady=(10, 0))
        
        self.va_status = ctk.CTkLabel(
            va_frame,
            text="Inactive",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color="#FF5252"  # Red for inactive
        )
        self.va_status.pack(anchor="w", padx=10, pady=(0, 10))
        
        # Create a progress bar for voice assistant
        self.va_progress = ctk.CTkProgressBar(
            va_frame,
            width=120,
            height=4,
            progress_color=THEME_DARK["primary"],
            fg_color=THEME_DARK["bg_light"]
        )
        self.va_progress.pack(anchor="w", padx=10, pady=(0, 10))
        self.va_progress.set(0)  # Initially inactive
        
        # Chatbots Ready
        cb_frame = ctk.CTkFrame(status_grid, fg_color=THEME_DARK["card_bg"], corner_radius=5)
        cb_frame.grid(row=0, column=1, sticky="ew", padx=5, pady=5)
        
        cb_label = ctk.CTkLabel(
            cb_frame,
            text="Chatbots Ready",
            font=ctk.CTkFont(size=12),
            text_color=THEME_DARK["text_secondary"]
        )
        cb_label.pack(anchor="w", padx=10, pady=(10, 0))
        
        self.cb_status = ctk.CTkLabel(
            cb_frame,
            text="0/0",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=THEME_DARK["text"]
        )
        self.cb_status.pack(anchor="w", padx=10, pady=(0, 10))
        
        # Create a progress bar for chatbots
        self.cb_progress = ctk.CTkProgressBar(
            cb_frame,
            width=120,
            height=4,
            progress_color=THEME_DARK["secondary"],
            fg_color=THEME_DARK["bg_light"]
        )
        self.cb_progress.pack(anchor="w", padx=10, pady=(0, 10))
        self.cb_progress.set(0)  # Initially no chatbots
        
        # Queries Processed
        qp_frame = ctk.CTkFrame(status_grid, fg_color=THEME_DARK["card_bg"], corner_radius=5)
        qp_frame.grid(row=0, column=2, sticky="ew", padx=5, pady=5)
        
        qp_label = ctk.CTkLabel(
            qp_frame,
            text="Queries Processed",
            font=ctk.CTkFont(size=12),
            text_color=THEME_DARK["text_secondary"]
        )
        qp_label.pack(anchor="w", padx=10, pady=(10, 0))
        
        self.qp_status = ctk.CTkLabel(
            qp_frame,
            text="0",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=THEME_DARK["text"]
        )
        self.qp_status.pack(anchor="w", padx=10, pady=(0, 10))
        
        # Create a progress bar for queries
        self.qp_progress = ctk.CTkProgressBar(
            qp_frame,
            width=120,
            height=4,
            progress_color=THEME_DARK["success"],
            fg_color=THEME_DARK["bg_light"]
        )
        self.qp_progress.pack(anchor="w", padx=10, pady=(0, 10))
        self.qp_progress.set(0)  # Initially no queries
        
        # Last Activity
        la_frame = ctk.CTkFrame(status_grid, fg_color=THEME_DARK["card_bg"], corner_radius=5)
        la_frame.grid(row=0, column=3, sticky="ew", padx=5, pady=5)
        
        la_label = ctk.CTkLabel(
            la_frame,
            text="Last Activity",
            font=ctk.CTkFont(size=12),
            text_color=THEME_DARK["text_secondary"]
        )
        la_label.pack(anchor="w", padx=10, pady=(10, 0))
        
        self.la_status = ctk.CTkLabel(
            la_frame,
            text="--:--:--",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=THEME_DARK["text"]
        )
        self.la_status.pack(anchor="w", padx=10, pady=(0, 10))
        
        # Create a progress bar for activity
        self.la_progress = ctk.CTkProgressBar(
            la_frame,
            width=120,
            height=4,
            progress_color=THEME_DARK["warning"],
            fg_color=THEME_DARK["bg_light"]
        )
        self.la_progress.pack(anchor="w", padx=10, pady=(0, 10))
        self.la_progress.set(0)  # Initially no activity

    def reset_configuration(self):
        """Reset the configuration to default values."""
        # Ask for confirmation
        if self.ask_confirmation("Are you sure you want to reset all settings to defaults?", 
                                title="Reset Configuration", 
                                icon="warning"):
            try:
                # Create default configuration
                self.config = {
                    "theme": "cyberpunk",
                    "integration": {
                        "mode": "clipboard",
                        "file_path": "C:/dragon_query.txt",
                        "polling_interval": 0.5,
                        "command_prefix": "ask"
                    },
                    "browser": {
                        "window_title_pattern": "Chrome",
                        "typing_delay": 0.05,
                        "window_switch_delay": 0.5
                    },
                    "feedback": {
                        "audio_enabled": True,
                        "popup_enabled": True,
                        "log_queries": True,
                        "log_file": "queries.log"
                    },
                    "advanced": {
                        "max_retries": 3,
                        "retry_delay": 1.0,
                        "send_timeout": 10.0
                    },
                    "microphone": {
                        "device": list(self.mic_devices.keys())[0] if self.mic_devices else "Default",
                        "sensitivity": 0.5
                    },
                    "chatbots": {}
                }
                
                # Save the configuration directly to file
                try:
                    with open(self.config_path, "w") as f:
                        json.dump(self.config, f, indent=4)
                except Exception as e:
                    logger.error(f"Error saving config file: {e}")
                
                # Update the theme if needed
                if hasattr(self, 'current_theme') and self.current_theme != "cyberpunk":
                    self.current_theme = "cyberpunk"
                    # Update theme constants
                    global THEME_DARK, GRADIENTS
                    THEME_DARK = THEMES["cyberpunk"]["colors"]
                    GRADIENTS = THEMES["cyberpunk"]["gradients"]
                
                # Show success message
                self.update_status("Configuration reset to defaults", level="success")
                
            except Exception as e:
                logger.error(f"Error resetting configuration: {e}")
                self.update_status(f"Error resetting configuration: {str(e)}", level="error")

    def create_coordinate_finder_dialog(self):
        """Create a dialog for finding input coordinates for chatbots."""
        dialog = ctk.CTkToplevel(self.root)
        dialog.title("Coordinate Finder")
        dialog.geometry("500x400")
        dialog.resizable(False, False)
        dialog.grab_set()  # Make dialog modal
        
        # Set icon
        try:
            dialog.iconbitmap(os.path.join("src", "assets", "dragon_icon.ico"))
        except Exception:
            pass
        
        # Create a frame for the content
        content_frame = ctk.CTkFrame(dialog, fg_color=self.colors["bg_darker"])
        content_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Title
        title_label = ctk.CTkLabel(
            content_frame,
            )
            text="Coordinate Finder Tool",
            font=ctk.CTkFont(family="Roboto", size=18, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title_label.pack(pady=(0, 20))
        
        # Instructions
        instructions = (
            "1. Position your mouse cursor over the input field of the chatbot\n"
            "2. Press the Space key to capture the coordinates\n"
            "3. The coordinates will be automatically filled in the chatbot configuration"
        )
        
        instruction_label = ctk.CTkLabel(
            content_frame,
            text=instructions,
            font=ctk.CTkFont(family="Roboto", size=12),
            text_color=self.colors["text"],
            justify="left"
        )
        instruction_label.pack(pady=(0, 20), fill="x")
        
        # Current coordinates display
        coords_frame = ctk.CTkFrame(content_frame, fg_color=self.colors["card_bg"])
        coords_frame.pack(fill="x", padx=10, pady=10)
        
        coords_label = ctk.CTkLabel(
            coords_frame,
            text="Current Mouse Position:",
            font=ctk.CTkFont(family="Roboto", size=12),
            text_color=self.colors["text"]
        )
        coords_label.pack(pady=(10, 5))
        
        position_var = ctk.StringVar(value="X: 0, Y: 0")
        position_display = ctk.CTkLabel(
            coords_frame,
            textvariable=position_var,
            font=ctk.CTkFont(family="Roboto", size=14, weight="bold"),
            text_color=self.colors["accent"]
        )
        position_display.pack(pady=(0, 10))
        
        # Captured coordinates
        captured_frame = ctk.CTkFrame(content_frame, fg_color=self.colors["card_bg"])
        captured_frame.pack(fill="x", padx=10, pady=10)
        
        captured_label = ctk.CTkLabel(
            captured_frame,
            text="Captured Coordinates:",
            font=ctk.CTkFont(family="Roboto", size=12),
            text_color=self.colors["text"]
        )
        captured_label.pack(pady=(10, 5))
        
        captured_var = ctk.StringVar(value="Not captured yet")
        captured_display = ctk.CTkLabel(
            captured_frame,
            textvariable=captured_var,
            font=ctk.CTkFont(family="Roboto", size=14, weight="bold"),
            text_color=self.colors["success"]
        )
        captured_display.pack(pady=(0, 10))
        
        # X and Y entry fields for manual input
        entry_frame = ctk.CTkFrame(content_frame, fg_color=self.colors["card_bg"])
        entry_frame.pack(fill="x", padx=10, pady=10)
        
        # X coordinate
        x_frame = ctk.CTkFrame(entry_frame, fg_color="transparent")
        x_frame.pack(side="left", fill="x", expand=True, padx=10, pady=10)
        
        x_label = ctk.CTkLabel(
            x_frame,
            text="X Coordinate:",
            font=ctk.CTkFont(family="Roboto", size=12),
            text_color=self.colors["text"]
        )
        x_label.pack(pady=(0, 5), anchor="w")
        
        x_entry = ctk.CTkEntry(
            x_frame,
            placeholder_text="Enter X coordinate",
            border_color=self.colors["accent"],
            text_color=self.colors["text_bright"]
        )
        x_entry.pack(fill="x", pady=(0, 5))
        
        # Y coordinate
        y_frame = ctk.CTkFrame(entry_frame, fg_color="transparent")
        y_frame.pack(side="right", fill="x", expand=True, padx=10, pady=10)
        
        y_label = ctk.CTkLabel(
            y_frame,
            text="Y Coordinate:",
            font=ctk.CTkFont(family="Roboto", size=12),
            text_color=self.colors["text"]
        )
        y_label.pack(pady=(0, 5), anchor="w")
        
        y_entry = ctk.CTkEntry(
            y_frame,
            placeholder_text="Enter Y coordinate",
            border_color=self.colors["accent"],
            text_color=self.colors["text_bright"]
        )
        y_entry.pack(fill="x", pady=(0, 5))
        
        # Buttons
        button_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        button_frame.pack(fill="x", padx=10, pady=(20, 10))
        
        def cancel():
            dialog.destroy()
        
        def save_coordinates():
            try:
                x = int(x_entry.get()) if x_entry.get() else 0
                y = int(y_entry.get()) if y_entry.get() else 0
                self.coordinate_callback(x, y)
                dialog.destroy()
            except ValueError:
                self.show_notification(
                    "Invalid coordinates. Please enter valid numbers.",
                    title="Input Error",
                    level="error"
                )
        
        start_button = ctk.CTkButton(
            button_frame,
            text="Start Capturing",
            font=ctk.CTkFont(family="Roboto", size=12, weight="bold"),
            fg_color=self.colors["accent"],
            hover_color=self.colors["accent_hover"],
            command=lambda: start_capture()
        )
        start_button.pack(side="left", padx=5, pady=10, fill="x", expand=True)
        
        cancel_button = ctk.CTkButton(
            button_frame,
            text="Cancel",
            font=ctk.CTkFont(family="Roboto", size=12, weight="bold"),
            fg_color=self.colors["cancel_button"],
            hover_color=self.colors["cancel_hover"],
            command=cancel
        )
        cancel_button.pack(side="left", padx=5, pady=10, fill="x", expand=True)
        
        save_button = ctk.CTkButton(
            button_frame,
            text="Save Coordinates",
            font=ctk.CTkFont(family="Roboto", size=12, weight="bold"),
            fg_color=self.colors["success"],
            hover_color=self.colors["success_hover"],
            command=save_coordinates
        )
        save_button.pack(side="left", padx=5, pady=10, fill="x", expand=True)
        
        # Update position display
        def update_position():
            if dialog.winfo_exists():
                x, y = pyautogui.position()
                position_var.set(f"X: {x}, Y: {y}")
                dialog.after(100, update_position)
        
        # Function to start capturing
        def start_capture():
            nonlocal listener
            
            # Status label to show the tool is active
            status_var.set("Coordinate finder active - Press SPACE to capture")
            status_label.configure(text_color=self.colors["success"])
            
            # Focus dialog to receive keyboard events
            dialog.focus_force()
            
            # Start keyboard listener
            if listener is None:
                listener = keyboard.Listener(on_press=on_key_press)
                listener.start()
        
        # Handle key press
        def on_key_press(key):
            try:
                if key == keyboard.Key.space:
                    x, y = pyautogui.position()
                    captured_var.set(f"X: {x}, Y: {y}")
                    x_entry.delete(0, 'end')
                    x_entry.insert(0, str(x))
                    y_entry.delete(0, 'end')
                    y_entry.insert(0, str(y))
                    status_var.set("Coordinates captured! You can now save them.")
            except Exception as e:
                logger.error(f"Error capturing coordinates: {e}")
        
        # Status label
        status_var = ctk.StringVar(value="Click 'Start Capturing' to begin")
        status_label = ctk.CTkLabel(
            content_frame,
            textvariable=status_var,
            font=ctk.CTkFont(family="Roboto", size=12, weight="bold"),
            text_color=self.colors["text"]
        )
        status_label.pack(pady=(10, 0))
        
        # Create keyboard listener (will be started when the user clicks the button)
        listener = None
        
        # Start updating position
        update_position()
        
        # Set callback to update entries
        def set_coordinate_callback(callback):
            self.coordinate_callback = callback
        
        # Store the set_callback function to be accessed from outside
        dialog.set_coordinate_callback = set_coordinate_callback
        
        return dialog

    def find_input_position(self, x_entry, y_entry):
        """Open the coordinate finder dialog to capture input position."""
        try:
            # Import keyboard for coordinate finder
            import keyboard
            from pynput import keyboard as pynput_keyboard
            
            dialog = self.create_coordinate_finder_dialog()
            
            # Set the callback to update the entries when coordinates are captured
            def update_position_entries(x, y):
                x_entry.delete(0, 'end')
                x_entry.insert(0, str(x))
                y_entry.delete(0, 'end')
                y_entry.insert(0, str(y))
            
            dialog.set_coordinate_callback(update_position_entries)
            
        except ImportError:
            self.show_notification(
                "Coordinate finder requires pynput and keyboard libraries. Please install them first.",
                title="Missing Dependencies",
                level="error"
            )
        except Exception as e:
            logger.error(f"Error opening coordinate finder: {e}")
            self.show_notification(
                f"Error opening coordinate finder: {str(e)}",
                title="Error",
                level="error"
            )

    def test_whisper_connection(self):
        """Test connection to Whisper API."""
        if not WHISPER_AVAILABLE:
            self.show_notification(
                "Whisper integration module is not available. Install required dependencies.",
                title="Missing Dependencies",
                level="error"
            )
            if hasattr(self, 'whisper_test_status'):
                self.whisper_test_status.configure(
                    text="Module unavailable",
                    text_color=self.colors["error"]
                )
            return
        
        try:
            # Get API key from the entry field
            api_key = self.whisper_api_key_entry.get() if hasattr(self, 'whisper_api_key_entry') else None
            base_url = self.whisper_base_url_entry.get() if hasattr(self, 'whisper_base_url_entry') else None
            
            if not api_key:
                self.show_notification(
                    "Please enter your API key first.",
                    title="Missing API Key",
                    level="warning"
                )
                if hasattr(self, 'whisper_test_status'):
                    self.whisper_test_status.configure(
                        text="No API key provided",
                        text_color=self.colors["warning"]
                    )
                return
            
            # Update status
            if hasattr(self, 'whisper_test_status'):
                self.whisper_test_status.configure(
                    text="Testing connection...",
                    text_color=self.colors["text"]
                )
            
            # Create a temporary recognizer
            recognizer = WhisperRecognizer(api_key=api_key, base_url=base_url)
            
            # Save the config values
            self.config.setdefault("whisper", {})
            self.config["whisper"]["api_key"] = api_key
            self.config["whisper"]["base_url"] = base_url
            self.config["whisper"]["enabled"] = True
            
            if hasattr(self, 'whisper_enabled_switch'):
                enabled_value = self.whisper_enabled_switch.get()
                self.config["whisper"]["enabled"] = enabled_value == 1
            
            if hasattr(self, 'whisper_model_dropdown'):
                model_value = self.whisper_model_dropdown.get()
                self.config["whisper"]["model"] = model_value
                recognizer.model = model_value
            
            if hasattr(self, 'whisper_language_dropdown'):
                language_value = self.whisper_language_dropdown.get()
                self.config["whisper"]["language"] = language_value
                recognizer.language = language_value if language_value != "auto" else None
            
            # Try to initialize the client
            if recognizer.client:
                # Test by checking models or making a simple API call
                self.show_notification(
                    "Whisper API connection successful!",
                    title="Connection Test",
                    level="success"
                )
                if hasattr(self, 'whisper_test_status'):
                    self.whisper_test_status.configure(
                        text="Connection successful",
                        text_color=self.colors["success"]
                    )
                
                # Save configuration after successful test
                self.save_configuration()
            else:
                self.show_notification(
                    "Could not initialize Whisper client. Check your API key.",
                    title="Connection Test",
                    level="error"
                )
                if hasattr(self, 'whisper_test_status'):
                    self.whisper_test_status.configure(
                        text="Connection failed",
                        text_color=self.colors["error"]
                    )
        except Exception as e:
            self.show_notification(
                f"Error testing Whisper API: {str(e)}",
                title="Connection Test",
                level="error"
            )
            if hasattr(self, 'whisper_test_status'):
                self.whisper_test_status.configure(
                    text=f"Error: {str(e)[:30]}...",
                    text_color=self.colors["error"]
                )

def main():
    """Main function to run the application."""
    # Initialize logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler("dragon_voice.log"),
            logging.StreamHandler()
        ]
    )
    
    try:
        logger.info("Starting Dragon Voice GUI...")
        logger.info(f"Python version: {sys.version}")
        logger.info(f"Current directory: {os.getcwd()}")
        
        # Create the GUI
        app = DragonVoiceGUI()
        
        # Auto-start the voice assistant after a short delay
        app.root.after(2000, app.start_voice_assistant)
        
        # Start the main loop
        logger.info("Starting main loop...")
        app.root.mainloop()
        
    except Exception as e:
        logger.error(f"Error in main function: {e}", exc_info=True)
        try:
            import traceback
            error_msg = f"An error occurred while starting the application:\n\n{str(e)}\n\n{traceback.format_exc()}"
            messagebox.showerror("Error", error_msg)
        except:
            print(f"CRITICAL ERROR: {e}")
            print(traceback.format_exc())
        sys.exit(1)

if __name__ == "__main__":
    main()