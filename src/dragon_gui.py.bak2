#!/usr/bin/env python3
"""
Dragon Voice GUI - Main application interface for Dragon Voice Project
"""

from whisper_integration import WhisperRecognizer
import os
import sys
import json
import time
import logging
import webbrowser
import threading
from datetime import datetime
from pathlib import Path

# GUI libraries
import tkinter as tk
from tkinter import messagebox
import customtkinter as ctk
from PIL import Image, ImageTk

# System monitoring
import psutil
import platform

# Window management
import pygetwindow as gw
import pyautogui
import sounddevice as sd
import numpy as np
import tempfile
import os
import time
import threading

# Custom components
from synthesizer_bar import SynthesizerBar

# Try to import soundfile, but don't fail if it's not available
try:
    import soundfile as sf
    SOUNDFILE_AVAILABLE = True
except ImportError:
    SOUNDFILE_AVAILABLE = False
    print("Warning: soundfile module not found. Some audio features will be limited.")

# Configure logging
logging.basicConfig(
    level=logging.WARNING,  # Changed from INFO to WARNING
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("dragon_gui.log"),
        logging.StreamHandler()
    ]
)

# Constants
DEFAULT_CONFIG_PATH = "src/config.json"
ASSETS_DIR = os.path.join("src", "assets")

# Add Whisper integration


class DragonVoiceGUI:
    """
    Main GUI class for the Dragon Voice Project

    Provides a modern, feature-rich interface for controlling the voice assistant,
    managing chatbots, and configuring system settings.
    """

    def __init__(self, config_path=DEFAULT_CONFIG_PATH):
        """Initialize the DragonVoice GUI application"""
        logging.info("Initializing DragonVoiceGUI")
        logging.info("Initializing DragonVoice GUI")

        try:
            # Initialize logging
            self.setup_logging()

            # Initialize state variables
            self.recording_active = False
            self.continuous_recording = False  # Flag for continuous recording
            self.is_fullscreen = False

            # Create main application window
            self.app = ctk.CTk()
            self.app.title("DragonVoice")
            self.app.geometry("1200x800")
            self.app.minsize(900, 600)
            
            # Center window on screen
            screen_width = self.app.winfo_screenwidth()
            screen_height = self.app.winfo_screenheight()
            x = (screen_width - 1200) // 2
            y = (screen_height - 800) // 2
            self.app.geometry(f"1200x800+{x}+{y}")

            # Load configuration
            self.config_path = config_path
            self.config = self.load_config()
            logging.info(f"Configuration loaded from {config_path}")

            # Set up theme and colors
            self.setup_theme()

            # Initialize Whisper recognizer
            self.init_whisper_recognizer()

            # Set up UI components
            self.setup_ui()

            # Start system monitoring
            self.start_system_monitoring()

        except Exception as e:
            logging.error(f"Error initializing DragonVoiceGUI: {str(e)}")
            raise

    def setup_logging(self):
        """Set up logging configuration"""
        # Check if logging is already configured
        if not logging.getLogger().handlers:
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - %(message)s'
            )
        logging.info("Logging setup complete")

    def setup_theme(self):
        """Set up the theme and colors for the application"""
        # Set appearance mode
        ctk.set_appearance_mode("dark")

        # Define color schemes
        self.color_schemes = {
            "dark": {
                "bg_dark": "#1A1A2E",
                "bg_medium": "#16213E",
                "bg_light": "#0F3460",
                "accent_primary": "#E94560",
                "accent_secondary": "#0F52BA",
                "text_bright": "#FFFFFF",
                "text_normal": "#E0E0E0",
                "text_dim": "#A0A0A0",
                "status_green": "#4CAF50",
                "status_yellow": "#FFC107",
                "status_red": "#F44336",
                "status_blue": "#2196F3",
                "status_gray": "#757575"
            },
            "light": {
                "bg_dark": "#F0F0F0",
                "bg_medium": "#E0E0E0",
                "bg_light": "#D0D0D0",
                "accent_primary": "#E94560",
                "accent_secondary": "#0F52BA",
                "text_bright": "#000000",
                "text_normal": "#202020",
                "text_dim": "#505050",
                "status_green": "#4CAF50",
                "status_yellow": "#FFC107",
                "status_red": "#F44336",
                "status_blue": "#2196F3",
                "status_gray": "#757575"
            },
            "dragon": {
                "bg_dark": "#0A1931",
                "bg_medium": "#150E56",
                "bg_light": "#1A1A40",
                "accent_primary": "#D82148",
                "accent_secondary": "#6EBF8B",
                "text_bright": "#FFFFFF",
                "text_normal": "#E0E0E0",
                "text_dim": "#A0A0A0",
                "status_green": "#4CAF50",
                "status_yellow": "#FFC107",
                "status_red": "#F44336",
                "status_blue": "#2196F3",
                "status_gray": "#757575"
            }
        }

        # Set default color scheme
        self.colors = self.color_schemes["dragon"]

        # Define fonts
        self.fonts = {
            "header": ctk.CTkFont(family="Segoe UI", size=28, weight="bold"),
            "title": ctk.CTkFont(family="Segoe UI", size=20, weight="bold"),
            "subtitle": ctk.CTkFont(family="Segoe UI", size=16, weight="bold"),
            "normal": ctk.CTkFont(family="Segoe UI", size=14),
            "small": ctk.CTkFont(family="Segoe UI", size=12),
            "tiny": ctk.CTkFont(family="Segoe UI", size=10),
            "mono": ctk.CTkFont(family="Consolas", size=12),
            # Added the 'large' font definition
            "large": ctk.CTkFont(family="Segoe UI", size=18)
        }

    def init_whisper_recognizer(self):
        """Initialize the Whisper recognizer"""
        try:
            # Initialize API keys with default values
            self.openai_api_key = "j3ydNXEmQFyDKwl5mWxSzcvdZcTLJw1t"
            self.base_url = "https://api.deepinfra.com/v1/openai"
            
            # Initialize WhisperRecognizer with error handling
            if self.openai_api_key:
                self.whisper_recognizer = WhisperRecognizer(
                    api_key=self.openai_api_key,
                    base_url=self.base_url
                )
                # Initialize recording state
                self.recording_active = False
                self.continuous_recording = False
                self.audio_data = []
                logging.info("WhisperRecognizer initialized successfully")
            else:
                logging.warning("No OpenAI API key found, WhisperRecognizer not initialized")
                self.whisper_recognizer = None
        except Exception as e:
            logging.error(f"Failed to initialize WhisperRecognizer: {str(e)}")
            self.whisper_recognizer = None

    def setup_ui(self):
        """Set up the main UI components"""
        try:
            # Create the main container
            self.main_container = ctk.CTkFrame(
                self.app, fg_color="transparent")
            self.main_container.pack(fill="both", expand=True)

            # Create UI components in the correct order
            self.create_footer()  # Create footer first to ensure status_label exists
            self.create_header()
            self.create_tabs()

            # Start system monitoring
            self.start_system_monitoring()

            # Update status
            self.update_status("Application initialized successfully")

            # Log successful UI setup
            logging.info("UI setup completed successfully")

        except Exception as e:
            logging.error(f"Error setting up UI: {str(e)}", exc_info=True)
            # Show error in a messagebox if possible
            try:
                import tkinter.messagebox as messagebox
                messagebox.showerror(
                    "UI Setup Error",
                    f"Error setting up UI:\n{str(e)}")
            except BaseException:
                pass

    def create_header(self):
        """Create a modern application header with logo and controls"""
        # Create header frame with gradient background
        self.header_frame = ctk.CTkFrame(
            self.main_container,
            fg_color=self.colors["bg_dark"],
            corner_radius=0,
            height=90
        )
        self.header_frame.pack(fill="x", pady=0)
        self.header_frame.pack_propagate(False)

        # Create gradient effect for header
        self.header_canvas = ctk.CTkCanvas(
            self.header_frame,
            bg=self.colors["bg_dark"],
            highlightthickness=0,
            height=90
        )
        self.header_canvas.pack(fill="x", side="top")

        # Draw gradient
        def draw_gradient():
            width = self.header_canvas.winfo_width()
            if width <= 1:  # Not yet properly initialized
                self.app.after(100, draw_gradient)
                return

            height = 90
            # Create a more sophisticated gradient
            for i in range(width):
                # Calculate gradient position (0 to 1)
                pos = i / width

                # Create a gradient with accent color highlights
                if pos < 0.2:  # First section - dark to medium with accent hint
                    ratio = pos / 0.2
                    r1, g1, b1 = self.hex_to_rgb(self.colors["bg_dark"])
                    r2, g2, b2 = self.hex_to_rgb(self.colors["bg_medium"])
                    r3, g3, b3 = self.hex_to_rgb(self.colors["accent_primary"])

                    # Mix colors with a hint of accent
                    r = r1 + (r2 - r1) * ratio + (r3 - r1) * ratio * 0.1
                    g = g1 + (g2 - g1) * ratio + (g3 - g1) * ratio * 0.1
                    b = b1 + (b2 - b1) * ratio + (b3 - b1) * ratio * 0.1
                elif pos < 0.8:  # Middle section - medium to medium with subtle variation
                    ratio = (pos - 0.2) / 0.6
                    r1, g1, b1 = self.hex_to_rgb(self.colors["bg_medium"])
                    r2, g2, b2 = self.hex_to_rgb(
                        self._adjust_color_brightness(
                            self.colors["bg_medium"], 1.1))

                    r = r1 + (r2 - r1) * ratio
                    g = g1 + (g2 - g1) * ratio
                    b = b1 + (b2 - b1) * ratio
                else:  # Last section - medium to dark with accent hint
                    ratio = (pos - 0.8) / 0.2
                    r1, g1, b1 = self.hex_to_rgb(self.colors["bg_medium"])
                    r2, g2, b2 = self.hex_to_rgb(self.colors["bg_dark"])
                    r3, g3, b3 = self.hex_to_rgb(
                        self.colors["accent_secondary"])

                    # Mix colors with a hint of accent
                    r = r1 + (r2 - r1) * ratio + (r3 - r1) * ratio * 0.1
                    g = g1 + (g2 - g1) * ratio + (g3 - g1) * ratio * 0.1
                    b = b1 + (b2 - b1) * ratio + (b3 - b1) * ratio * 0.1

                color = f'#{int(r):02x}{int(g):02x}{int(b):02x}'
                self.header_canvas.create_line(i, 0, i, height, fill=color)

            # Add accent line at bottom with glow effect
            for i in range(3):
                alpha = 0.3 + (0.7 * (i / 2))  # Increasing opacity
                glow_color = self._adjust_color_brightness(
                    self.colors["accent_primary"], alpha)
            self.header_canvas.create_line(
                0, height - 3 + i, width, height - 3 + i,
                fill=glow_color,
                width=1
            )

        # Schedule gradient drawing
        self.app.after(100, draw_gradient)

        # Create a container for the header content
        header_content = ctk.CTkFrame(
            self.header_frame, fg_color="transparent")
        header_content.place(
            relx=0.5,
            rely=0.5,
            anchor="center",
            relwidth=1,
            relheight=0.8)

        # Left side - Logo and title
        logo_frame = ctk.CTkFrame(header_content, fg_color="transparent")
        logo_frame.pack(side="left", padx=(30, 0))

        # Try to load logo image if available
        try:
            logo_path = os.path.join("src", "assets", "dragon_logo.png")
            if os.path.exists(logo_path):
                logo_image = ctk.CTkImage(
                    light_image=Image.open(logo_path),
                    dark_image=Image.open(logo_path),
                    size=(40, 40)
                )
                logo_label = ctk.CTkLabel(
                    logo_frame,
                    image=logo_image,
                    text=""
                )
                logo_label.pack(side="left", padx=(0, 15))
        except Exception as e:
            logging.error(f"Failed to load logo: {str(e)}")

        # App title with modern styling
        title_label = ctk.CTkLabel(
            logo_frame,
            text="DragonVoice",
            font=self.fonts["header"],
            text_color=self.colors["text_bright"]
        )
        title_label.pack(side="left")

        # Version with pill background
        version_pill = ctk.CTkFrame(
            logo_frame,
            fg_color=self.colors["accent_primary"],
            corner_radius=12,
            height=24
        )
        version_pill.pack(side="left", padx=(10, 0), pady=(8, 0))

        version_label = ctk.CTkLabel(
            version_pill,
            text="v2.0",
            font=self.fonts["small"],
            text_color=self.colors["text_bright"]
        )
        version_label.pack(padx=10, pady=2)

        # Center - Status indicator
        status_frame = ctk.CTkFrame(header_content, fg_color="transparent")
        status_frame.pack(side="left", expand=True)

        # Right side - Controls
        controls_frame = ctk.CTkFrame(header_content, fg_color="transparent")
        controls_frame.pack(side="right", padx=(0, 30))

        # Microphone selector with improved styling
        mic_frame = ctk.CTkFrame(
            controls_frame,
            fg_color=self.colors["bg_light"],
            corner_radius=8
        )
        mic_frame.pack(side="left", padx=(0, 15), pady=5)

        mic_label = ctk.CTkLabel(
            mic_frame,
            text="Microphone:",
            font=self.fonts["small"],
            text_color=self.colors["text_normal"]
        )
        mic_label.pack(side="left", padx=(10, 5), pady=5)

        # Microphone dropdown
        self.mic_var = ctk.StringVar(value="Default Microphone")
        self.mic_dropdown = ctk.CTkOptionMenu(
            mic_frame,
            values=["Default Microphone"],
            variable=self.mic_var,
            width=150,
            dynamic_resizing=True,
            fg_color=self.colors["bg_medium"],
            button_color=self.colors["accent_primary"],
            button_hover_color=self.colors["accent_secondary"],
            dropdown_fg_color=self.colors["bg_medium"]
        )
        self.mic_dropdown.pack(side="left", padx=(0, 10), pady=5)

        # Theme toggle button
        theme_button = ctk.CTkButton(
            controls_frame,
            text="",
            width=36,
            height=36,
            corner_radius=10,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            text_color=self.colors["text_bright"],
            command=self.toggle_theme
        )
        theme_button.pack(side="left", padx=(0, 10))

        # Settings button
        settings_button = ctk.CTkButton(
            controls_frame,
            text="Settings",
            width=100,
            height=36,
            corner_radius=10,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            text_color=self.colors["text_bright"],
            command=self.show_settings
        )
        settings_button.pack(side="left", padx=(0, 10))

        # Help button
        help_button = ctk.CTkButton(
            controls_frame,
            text="Help",
            width=80,
            height=36,
            corner_radius=10,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            text_color=self.colors["text_bright"],
            command=self.show_help
        )
        help_button.pack(side="left")

        # Refresh microphone list
        self.refresh_mic_list()

    def hex_to_rgb(self, hex_color):
        """Convert hex color to RGB tuple"""
        hex_color = hex_color.lstrip('#')
        return tuple(int(hex_color[i:i + 2], 16) for i in (0, 2, 4))

    def show_settings(self):
        """Show the settings dialog"""
        # Switch to the Configuration tab
        self.tab_view.set("Configuration")

    def show_help(self):
        """Show the help dialog"""
        # Create a new top-level window
        help_window = ctk.CTkToplevel(self.app)
        help_window.title("DragonVoice Help")
        help_window.geometry("800x600")
        help_window.minsize(800, 600)
        help_window.grab_set()  # Make window modal

        # Set window icon
        if platform.system() == "Windows":
            try:
                icon_path = os.path.join(
                    os.path.dirname(
                        os.path.abspath(__file__)),
                    "assets",
                    "dragon_icon.ico")
                if os.path.exists(icon_path):
                    help_window.iconbitmap(icon_path)
            except Exception as e:
                print(f"Could not set help window icon: {e}")

        # Create tab view for help content
        help_tabs = ctk.CTkTabview(
            help_window,
            fg_color=self.colors["bg_dark"],
            segmented_button_fg_color=self.colors["bg_medium"],
            segmented_button_selected_color=self.colors["accent_primary"],
            segmented_button_selected_hover_color=self.colors["accent_secondary"],
            segmented_button_unselected_color=self.colors["bg_medium"],
            segmented_button_unselected_hover_color=self.colors["bg_light"])
        help_tabs.pack(fill="both", expand=True, padx=20, pady=20)

        # Add tabs
        help_tabs.add("Getting Started")
        help_tabs.add("Voice Commands")
        help_tabs.add("Chatbots")
        help_tabs.add("Troubleshooting")
        help_tabs.add("About")

        # Create content for each tab
        self.create_help_getting_started(help_tabs.tab("Getting Started"))
        self.create_help_voice_commands(help_tabs.tab("Voice Commands"))
        self.create_help_chatbots(help_tabs.tab("Chatbots"))
        self.create_help_troubleshooting(help_tabs.tab("Troubleshooting"))
        self.create_help_about(help_tabs.tab("About"))

        # Add close button at bottom
        button_frame = ctk.CTkFrame(help_window, fg_color="transparent")
        button_frame.pack(fill="x", padx=20, pady=(0, 20))

        close_button = ctk.CTkButton(
            button_frame,
            text="Close",
            command=help_window.destroy,
            width=100,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        close_button.pack(side="right")

    def create_footer(self):
        """Create the footer with status information"""
        # Create footer container
        self.footer = ctk.CTkFrame(
            self.app,
            fg_color=self.colors["bg_dark"],
            height=30
        )
        self.footer.pack(fill="x", side="bottom")
        self.footer.pack_propagate(False)

        # Create canvas for gradient background
        footer_canvas = ctk.CTkCanvas(
            self.footer,
            bg=self.colors["bg_dark"],
            highlightthickness=0,
            height=30
        )
        footer_canvas.pack(fill="x")

        # Draw gradient
        def draw_gradient():
            width = footer_canvas.winfo_width()
            if width <= 1:  # Not properly rendered yet
                self.app.after(100, draw_gradient)
                return

            height = 30
            # Create gradient from dark to slightly lighter
            for i in range(height):
                # Calculate color based on position
                r, g, b = self.hex_to_rgb(self.colors["bg_dark"])
                factor = i / height * 0.2  # Subtle gradient
                r = min(255, int(r + (255 - r) * factor))
                g = min(255, int(g + (255 - g) * factor))
                b = min(255, int(b + (255 - b) * factor))
                color = f'#{r:02x}{g:02x}{b:02x}'

                # Draw line
                footer_canvas.create_line(0, i, width, i, fill=color)

        # Schedule gradient drawing after the window is rendered
        self.app.after(100, draw_gradient)

        # Status label
        self.status_label = ctk.CTkLabel(
            footer_canvas,
            text="Ready",
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        self.status_label.place(relx=0.01, rely=0.5, anchor="w")

        # Version label
        version_label = ctk.CTkLabel(
            footer_canvas,
            text="DragonVoice v2.0",
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        version_label.place(relx=0.99, rely=0.5, anchor="e")

        # Log successful creation
        logging.info(
            "Footer created successfully with status_label initialized")

    def create_tabs(self):
        """Create the main tab view and tabs"""
        # Create the main tab container
        self.tab_container = ctk.CTkFrame(self.app, fg_color="transparent")
        self.tab_container.pack(
            fill="both",
            expand=True,
            padx=20,
            pady=(
                0,
                20))

        # Create the tab view
        self.tab_view = ctk.CTkTabview(
            self.tab_container,
            fg_color=self.colors["bg_dark"],
            segmented_button_fg_color=self.colors["bg_medium"],
            segmented_button_selected_color=self.colors["accent_primary"],
            segmented_button_selected_hover_color=self.colors["accent_secondary"],
            segmented_button_unselected_color=self.colors["bg_medium"],
            segmented_button_unselected_hover_color=self.colors["bg_light"])
        self.tab_view.pack(fill="both", expand=True)

        # Add tabs
        self.tab_view.add("Dashboard")
        self.tab_view.add("Chatbots")
        self.tab_view.add("History")
        self.tab_view.add("Configuration")
        self.tab_view.add("About")

        # Set default tab
        self.tab_view.set("Dashboard")

        # Create tab contents
        self.create_dashboard_tab()
        self.create_chatbots_tab()
        self.create_history_tab()
        self.create_config_tab()
        self.create_about_tab()

    def create_dashboard_tab(self):
        """Create the dashboard tab content"""
        # Main container with gradient background
        dashboard_container = ctk.CTkScrollableFrame(
            self.tab_view.tab("Dashboard"),
            fg_color="transparent"
        )
        dashboard_container.pack(fill="both", expand=True, padx=20, pady=0)  # Reduced top padding

        # Create a grid layout for dashboard widgets
        dashboard_container.columnconfigure(0, weight=2)
        dashboard_container.columnconfigure(1, weight=1)
        dashboard_container.rowconfigure(0, weight=1)
        dashboard_container.rowconfigure(1, weight=1)
        dashboard_container.rowconfigure(2, weight=1)

        # Status panel (top left)
        status_panel = self.create_status_panel(dashboard_container)
        status_panel.grid(row=0, column=0, sticky="nsew", padx=(0, 10), pady=(0, 10))

        # Voice assistant control panel (top right)
        control_panel = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=15,
            border_width=1,
            border_color=self.colors["bg_light"]
        )
        control_panel.grid(row=0, column=1, sticky="nsew", padx=(10, 0), pady=(0, 10))

        # Control panel header with icon
        control_header = ctk.CTkFrame(control_panel, fg_color="transparent", height=50)
        control_header.pack(fill="x", padx=20, pady=(15, 5))

        # Control panel title with icon
        control_title = ctk.CTkLabel(
            control_header,
            text="Voice Assistant",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        control_title.pack(side="left")

        # Start/Stop button with improved styling
        self.toggle_button = ctk.CTkButton(
            control_panel,
            text="Start Voice Assistant",
            command=self.toggle_voice_assistant,
            fg_color=self.colors["status_green"],
            hover_color=self._adjust_color_brightness(self.colors["status_green"], 0.8),
            height=60,
            corner_radius=10,
            font=self.fonts["subtitle"],
            border_width=1,
            border_color=self._adjust_color_brightness(self.colors["status_green"], 1.2)
        )
        self.toggle_button.pack(fill="x", padx=20, pady=15)
        
        # Recording buttons container
        recording_buttons_frame = ctk.CTkFrame(control_panel, fg_color="transparent")
        recording_buttons_frame.pack(fill="x", padx=20, pady=10)

        # Record button
        self.record_button = ctk.CTkButton(
            recording_buttons_frame,
            text="Record",
            command=self.start_manual_recording,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            height=40,
            width=150,
            corner_radius=10
        )
        self.record_button.pack(side="left", fill="x", expand=True, padx=(0, 5))

        # Stop Recording button
        self.stop_record_button = ctk.CTkButton(
            recording_buttons_frame,
            text="Stop Recording",
            command=self.stop_manual_recording,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            height=40,
            width=150,
            corner_radius=10,
            state="disabled"
        )
        self.stop_record_button.pack(side="right", fill="x", expand=True, padx=(5, 0))

        # Add synthesizer bar to show voice detection
        self.synth_bar = SynthesizerBar(control_panel, self.colors, self.fonts)

        # Microphone sensitivity slider
        sensitivity_frame = ctk.CTkFrame(
            control_panel,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        sensitivity_frame.pack(fill="x", padx=20, pady=10)

        sensitivity_label = ctk.CTkLabel(
            sensitivity_frame,
            text="Microphone Sensitivity",
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"]
        )
        sensitivity_label.pack(anchor="w", padx=15, pady=(10, 5))

        sensitivity_control = ctk.CTkFrame(sensitivity_frame, fg_color="transparent")
        sensitivity_control.pack(fill="x", padx=15, pady=(0, 10))

        self.sensitivity_var = ctk.DoubleVar(value=0.5)
        self.sensitivity_slider = ctk.CTkSlider(
            sensitivity_control,
            from_=0.1,
            to=1.0,
            variable=self.sensitivity_var,
            width=200,
            progress_color=self.colors["accent_primary"],
            button_color=self.colors["accent_secondary"],
            button_hover_color=self.colors["accent_primary"]
        )
        self.sensitivity_slider.pack(side="left", fill="x", expand=True, padx=(0, 10))

        self.sensitivity_value = ctk.CTkLabel(
            sensitivity_control,
            text=f"{int(self.sensitivity_var.get() * 100)}%",
            font=self.fonts["small"],
            width=40,
            text_color=self.colors["text_dim"]
        )
        self.sensitivity_value.pack(side="right")

        # Update sensitivity value when slider changes
        def update_sensitivity(*args):
            self.sensitivity_value.configure(text=f"{int(self.sensitivity_var.get() * 100)}%")
            if hasattr(self, 'gain_var'):
                self.gain_var.set(self.sensitivity_var.get())

        self.sensitivity_var.trace_add("write", update_sensitivity)
        
        # Initialize gain variable for level meter
        self.gain_var = ctk.DoubleVar(value=self.sensitivity_var.get())

        # Status indicator with improved styling
        status_frame = ctk.CTkFrame(
            control_panel,
            fg_color=self.colors["bg_light"],
            corner_radius=10,
            height=50
        )
        status_frame.pack(fill="x", padx=20, pady=10)
        status_frame.pack_propagate(False)

        status_label = ctk.CTkLabel(
            status_frame,
            text="Status: Idle",
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"]
        )
        status_label.pack(side="left", padx=15, pady=10)

        self.status_indicator = ctk.CTkFrame(
            status_frame,
            fg_color=self.colors["status_gray"],
            width=20,
            height=20,
            corner_radius=10
        )
        self.status_indicator.pack(side="right", padx=15)

        # Transcription section (middle)
        transcription_frame = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=15,
            border_width=1,
            border_color=self.colors["bg_light"]
        )
        transcription_frame.grid(row=1, column=0, columnspan=2, sticky="nsew", pady=(0, 10))
            
        # Transcription header
        transcription_header = ctk.CTkFrame(transcription_frame, fg_color="transparent", height=50)
        transcription_header.pack(fill="x", padx=20, pady=(15, 5))
        
        transcription_title = ctk.CTkLabel(
            transcription_header,
            text="📝 Transcription",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        transcription_title.pack(side="left")
        
        # Controls frame
        controls = ctk.CTkFrame(transcription_header, fg_color="transparent")
        controls.pack(side="right")
        
        # Clear button
        clear_button = ctk.CTkButton(
            controls,
            text="Clear",
            command=lambda: self.clear_transcription(),
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            width=80
        )
        clear_button.pack(side="right", padx=(0, 10))
        
        # Enter button
        self.enter_button = ctk.CTkButton(
            controls,
            text="Enter",
            command=self.process_transcription,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            width=100,
            state="disabled"
        )
        self.enter_button.pack(side="right")
        
        # Transcription display
        self.transcription_display = ctk.CTkTextbox(
            transcription_frame,
            fg_color=self.colors["bg_light"],
            text_color=self.colors["text_bright"],
            font=self.fonts["large"],
            corner_radius=10,
            border_width=1,
            border_color=self.colors["bg_light"],
            height=150
        )
        self.transcription_display.pack(fill="both", expand=True, padx=20, pady=(5, 20))
        
        # Configure text tags
        self.transcription_display._textbox.tag_configure("timestamp", foreground=self.colors["accent_secondary"])
        self.transcription_display._textbox.tag_configure("transcription", foreground=self.colors["text_bright"])
        
        # Add initial message
        self.transcription_display.configure(state="normal")
        self.transcription_display.insert("end", "Transcribed text will appear here...")
        self.transcription_display.configure(state="disabled")

        # Voice commands section (bottom)
        text_display_frame = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=15,
            border_width=1,
            border_color=self.colors["bg_light"]
        )
        text_display_frame.grid(row=2, column=0, columnspan=2, sticky="nsew")
                
        # Text display header
        text_header = ctk.CTkFrame(text_display_frame, fg_color="transparent", height=50)
        text_header.pack(fill="x", padx=20, pady=(15, 5))
        
        text_title = ctk.CTkLabel(
            text_header,
            text="🔊 Voice Commands",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        text_title.pack(side="left")
        
        # Clear button for text display
        clear_text_button = ctk.CTkButton(
            text_header,
            text="Clear",
            command=lambda: self.clear_text_display(),
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            width=80
        )
        clear_text_button.pack(side="right")
        
        # Text display area
        self.text_display = ctk.CTkTextbox(
            text_display_frame,
            fg_color=self.colors["bg_light"],
            text_color=self.colors["text_bright"],
            font=self.fonts["large"],
            corner_radius=10,
            border_width=1,
            border_color=self.colors["bg_light"],
            height=200
        )
        self.text_display.pack(fill="both", expand=True, padx=20, pady=(5, 20))
        
        # Configure text tags
        self.text_display._textbox.tag_configure("timestamp", foreground=self.colors["accent_secondary"])
        self.text_display._textbox.tag_configure("command", foreground=self.colors["accent_primary"])
        self.text_display._textbox.tag_configure("system", foreground=self.colors["status_blue"])
        
        # Add initial message
        self.text_display.configure(state="normal")
        self.text_display.insert("end", "Voice commands will appear here after starting the voice assistant...")
        self.text_display.configure(state="disabled")

        # Initialize monitor visualization
        self.app.after(500, self.refresh_monitor_visualization)

    def create_synthesizer_bar(self, parent):
        """Create a synthesizer bar to visualize voice detection"""
        # Use the new SynthesizerBar class if available
        try:
            from synthesizer_bar import SynthesizerBar
            self.synth_bar = SynthesizerBar(parent, self.colors, self.fonts)
            return
        except ImportError:
            logging.warning(
                "SynthesizerBar class not found, using fallback implementation")

        # Fallback implementation
        synth_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10,
            height=80
        )
        synth_frame.pack(fill="x", padx=20, pady=10)

        # Synthesizer label
        synth_label = ctk.CTkLabel(
            synth_frame,
            text="Voice Detection",
            font=self.fonts["normal"],
            text_color=self.colors["text_bright"]
        )
        synth_label.pack(anchor="w", padx=15, pady=(10, 5))

        # Create level meter canvas
        self.level_canvas = ctk.CTkCanvas(
            synth_frame,
            bg=self.colors["bg_dark"],
            highlightthickness=0,
            height=30
        )
        self.level_canvas.pack(fill="x", padx=15, pady=(0, 10))

        # Initialize level meter with zero level
        self.app.after(100, lambda: self._update_level_meter(0))

    def create_chatbots_tab(self):
        """Create the chatbots tab content"""
        # Main container
        chatbots_container = ctk.CTkFrame(
            self.tab_view.tab("Chatbots"),
            fg_color="transparent"
        )
        chatbots_container.pack(fill="both", expand=True, padx=20, pady=20)

        # Title and add button row
        title_frame = ctk.CTkFrame(chatbots_container, fg_color="transparent")
        title_frame.pack(fill="x", pady=(0, 15))

        # Title with icon
        title_label = ctk.CTkLabel(
            title_frame,
            text="Chatbot Management",
            font=ctk.CTkFont(size=24, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title_label.pack(side="left")

        # Add chatbot button
        add_button = ctk.CTkButton(
            title_frame,
            text="Add New Chatbot",
            command=self.show_add_chatbot_dialog,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            width=120
        )
        add_button.pack(side="right")

        # Search frame
        search_frame = ctk.CTkFrame(
            chatbots_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=10,
            height=50
        )
        search_frame.pack(fill="x", pady=(0, 15))
        search_frame.pack_propagate(False)

        # Search icon
        search_icon = ctk.CTkLabel(
            search_frame,
            text="🔍",
            font=ctk.CTkFont(size=16),
            width=30
        )
        search_icon.pack(side="left", padx=(15, 0))

        # Search entry
        self.search_var = ctk.StringVar()
        self.search_var.trace_add(
            "write", lambda *args: self.filter_chatbot_list())
        search_entry = ctk.CTkEntry(
            search_frame,
            placeholder_text="Search chatbots...",
            textvariable=self.search_var,
            border_width=0,
            fg_color="transparent",
            height=40
        )
        search_entry.pack(side="left", fill="x", expand=True, padx=10)

        # Chatbot list container
        self.chatbot_list_frame = ctk.CTkScrollableFrame(
            chatbots_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        self.chatbot_list_frame.pack(fill="both", expand=True)

        # Refresh chatbot list
        self.refresh_chatbots()

    def create_about_tab(self):
        """Create the about tab content"""
        # Main container
        about_container = ctk.CTkFrame(
            self.tab_view.tab("About"),
            fg_color="transparent"
        )
        about_container.pack(fill="both", expand=True, padx=20, pady=20)

        # Create a scrollable frame for the about content
        about_scroll = ctk.CTkScrollableFrame(
            about_container,
            fg_color="transparent"
        )
        about_scroll.pack(fill="both", expand=True)

        # Logo and title
        logo_frame = ctk.CTkFrame(about_scroll, fg_color="transparent")
        logo_frame.pack(fill="x", pady=(0, 20))

        # App title
        title_label = ctk.CTkLabel(
            logo_frame,
            text="DragonVoice",
            font=ctk.CTkFont(size=32, weight="bold"),
            text_color=self.colors["accent_primary"]
        )
        title_label.pack(pady=(0, 5))

        # Version
        version_label = ctk.CTkLabel(
            logo_frame,
            text="Version 2.0",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"]
        )
        version_label.pack()

        # Description
        description_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        description_frame.pack(fill="x", pady=10, padx=5)

        description_label = ctk.CTkLabel(
            description_frame,
            text="DragonVoice is an advanced voice assistant that integrates with multiple AI chatbots.\n"
            "It provides a seamless voice interface for interacting with AI models and controlling your computer.",
            font=ctk.CTkFont(
                size=14),
            text_color=self.colors["text_normal"],
            wraplength=600,
            justify="left")
        description_label.pack(padx=20, pady=20)

        # Features
        features_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        features_frame.pack(fill="x", pady=10, padx=5)

        features_title = ctk.CTkLabel(
            features_frame,
            text="Key Features",
            font=ctk.CTkFont(size=18, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        features_title.pack(anchor="w", padx=20, pady=(15, 10))

        features = [
            "🎤 Voice recognition with OpenAI Whisper",
            "🤖 Multiple AI chatbot integrations",
            "⌨️ System control through voice commands",
            "📊 Real-time system monitoring",
            "🎨 Customizable themes and appearance",
            "🔧 Advanced configuration options"
        ]

        for feature in features:
            feature_label = ctk.CTkLabel(
                features_frame,
                text=feature,
                font=ctk.CTkFont(size=14),
                text_color=self.colors["text_normal"],
                anchor="w"
            )
            feature_label.pack(anchor="w", padx=20, pady=5)

        # Credits
        credits_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        credits_frame.pack(fill="x", pady=10, padx=5)

        credits_title = ctk.CTkLabel(
            credits_frame,
            text="Credits",
            font=ctk.CTkFont(size=18, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        credits_title.pack(anchor="w", padx=20, pady=(15, 10))

        credits_label = ctk.CTkLabel(
            credits_frame,
            text="Developed by: DragonVoice Team\n"
                 "UI Framework: CustomTkinter\n"
                 "Voice Recognition: OpenAI Whisper\n"
                 "Special thanks to all contributors and testers",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            justify="left"
        )
        credits_label.pack(anchor="w", padx=20, pady=(0, 15))

        # Links
        links_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        links_frame.pack(fill="x", pady=10, padx=5)

        links_title = ctk.CTkLabel(
            links_frame,
            text="Links",
            font=ctk.CTkFont(size=18, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        links_title.pack(anchor="w", padx=20, pady=(15, 10))

        # Function to open links
        def open_link(url):
            import webbrowser
            webbrowser.open(url)

        # Website link
        website_button = ctk.CTkButton(
            links_frame,
            text="Visit Website",
            command=lambda: open_link("https://dragonvoice.ai"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        website_button.pack(anchor="w", padx=20, pady=5)

        # Documentation link
        docs_button = ctk.CTkButton(
            links_frame,
            text="Documentation",
            command=lambda: open_link("https://docs.dragonvoice.ai"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        docs_button.pack(anchor="w", padx=20, pady=5)

        # GitHub link
        github_button = ctk.CTkButton(
            links_frame,
            text="GitHub Repository",
            command=lambda: open_link("https://github.com/dragonvoice/dragonvoice"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"])
        github_button.pack(anchor="w", padx=20, pady=(5, 15))

    def create_settings_advanced_tab(self, parent):
        """Create the advanced settings tab content"""
        # Main container
        container = ctk.CTkFrame(parent, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)

        # Logging settings section
        logging_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        logging_frame.pack(fill="x", pady=(0, 15))

        # Section title
        logging_title = ctk.CTkLabel(
            logging_frame,
            text="Logging Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        logging_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Log level
        log_level_frame = ctk.CTkFrame(logging_frame, fg_color="transparent")
        log_level_frame.pack(fill="x", padx=15, pady=5)

        log_level_label = ctk.CTkLabel(
            log_level_frame,
            text="Log Level",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        log_level_label.pack(side="left")

        self.log_level_var = ctk.StringVar(value="INFO")
        log_level_dropdown = ctk.CTkOptionMenu(
            log_level_frame,
            values=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
            variable=self.log_level_var,
            width=200
        )
        log_level_dropdown.pack(side="left", padx=10)

        # Enable file logging
        file_logging_frame = ctk.CTkFrame(
            logging_frame, fg_color="transparent")
        file_logging_frame.pack(fill="x", padx=15, pady=5)

        file_logging_label = ctk.CTkLabel(
            file_logging_frame,
            text="File Logging",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        file_logging_label.pack(side="left")

        self.file_logging_var = ctk.BooleanVar(value=True)
        file_logging_switch = ctk.CTkSwitch(
            file_logging_frame,
            text="",
            variable=self.file_logging_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        file_logging_switch.pack(side="left", padx=10)

        # Performance settings section
        performance_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        performance_frame.pack(fill="x", pady=(0, 15))

        # Section title
        performance_title = ctk.CTkLabel(
            performance_frame,
            text="Performance Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        performance_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Hardware acceleration
        hardware_frame = ctk.CTkFrame(
            performance_frame, fg_color="transparent")
        hardware_frame.pack(fill="x", padx=15, pady=5)

        hardware_label = ctk.CTkLabel(
            hardware_frame,
            text="Hardware Acceleration",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        hardware_label.pack(side="left")

        self.hardware_var = ctk.BooleanVar(value=True)
        hardware_switch = ctk.CTkSwitch(
            hardware_frame,
            text="",
            variable=self.hardware_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        hardware_switch.pack(side="left", padx=10)

        # Thread count
        thread_frame = ctk.CTkFrame(performance_frame, fg_color="transparent")
        thread_frame.pack(fill="x", padx=15, pady=5)

        thread_label = ctk.CTkLabel(
            thread_frame,
            text="Worker Threads",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        thread_label.pack(side="left")

        self.thread_var = ctk.IntVar(value=4)
        thread_slider = ctk.CTkSlider(
            thread_frame,
            from_=1,
            to=16,
            number_of_steps=15,
            variable=self.thread_var,
            width=200
        )
        thread_slider.pack(side="left", padx=10)

        thread_value = ctk.CTkLabel(
            thread_frame,
            textvariable=self.thread_var,
            width=30
        )
        thread_value.pack(side="left", padx=5)

        # Memory limit
        memory_frame = ctk.CTkFrame(performance_frame, fg_color="transparent")
        memory_frame.pack(fill="x", padx=15, pady=5)

        memory_label = ctk.CTkLabel(
            memory_frame,
            text="Memory Limit (MB)",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        memory_label.pack(side="left")

        self.memory_var = ctk.IntVar(value=1024)
        memory_slider = ctk.CTkSlider(
            memory_frame,
            from_=256,
            to=4096,
            number_of_steps=15,
            variable=self.memory_var,
            width=200
        )
        memory_slider.pack(side="left", padx=10)

        memory_value = ctk.CTkLabel(
            memory_frame,
            textvariable=self.memory_var,
            width=50
        )
        memory_value.pack(side="left", padx=5)

        # Reset button
        reset_button = ctk.CTkButton(
            container,
            text="Reset to Defaults",
            command=lambda: self.reset_advanced_settings(),
            fg_color=self.colors["bg_medium"],
            hover_color=self.colors["bg_light"],
            width=150
        )
        reset_button.pack(anchor="e", pady=10)

        return container

    def reset_advanced_settings(self):
        """Reset advanced settings to defaults"""
        self.log_level_var.set("INFO")
        self.file_logging_var.set(True)
        self.hardware_var.set(True)
        self.thread_var.set(4)
        self.memory_var.set(1024)
        self.update_status("Advanced settings reset to defaults")

    def apply_theme(self, theme_name):
        """Apply the selected theme"""
        if theme_name in self.color_schemes:
            self.colors = self.color_schemes[theme_name]
            self.config["theme"] = theme_name
            self.save_configuration(show_notification=False)
            # Refresh UI with new theme
            self.setup_theme()
            self.refresh_ui()

    def show_add_chatbot_dialog(self):
        """Show dialog to add a new chatbot"""
        dialog = ctk.CTkToplevel(self.app)
        dialog.title("Add New Chatbot")
        dialog.geometry("400x500")
        dialog.transient(self.app)
        dialog.grab_set()

        # Create form fields
        name_label = ctk.CTkLabel(
            dialog,
            text="Chatbot Name",
            text_color=self.colors["text_bright"]
        )
        name_label.pack(anchor="w", padx=20, pady=(20, 0))

        name_entry = ctk.CTkEntry(dialog, width=360)
        name_entry.pack(anchor="w", padx=20, pady=(0, 10))

        type_label = ctk.CTkLabel(
            dialog,
            text="Chatbot Type",
            text_color=self.colors["text_bright"]
        )
        type_label.pack(anchor="w", padx=20, pady=(10, 0))

        type_var = ctk.StringVar(value="GPT")
        type_dropdown = ctk.CTkOptionMenu(
            dialog,
            values=["GPT", "Claude", "Gemini", "Custom"],
            variable=type_var,
            width=360
        )
        type_dropdown.pack(anchor="w", padx=20, pady=(0, 10))

        api_key_label = ctk.CTkLabel(
            dialog,
            text="API Key",
            text_color=self.colors["text_bright"]
        )
        api_key_label.pack(anchor="w", padx=20, pady=(10, 0))

        api_key_entry = ctk.CTkEntry(dialog, width=360, show="*")
        api_key_entry.pack(anchor="w", padx=20, pady=(0, 10))

        # Add chatbot button
        def add_chatbot():
            name = name_entry.get()
            chatbot_type = type_var.get()
            api_key = api_key_entry.get()

            if name and chatbot_type and api_key:
                # Add to config
                if "chatbots" not in self.config:
                    self.config["chatbots"] = {}

                self.config["chatbots"][name] = {
                    "type": chatbot_type,
                    "api_key": api_key,
                    "status": "Ready",
                    "color": self.colors["accent_primary"],
                    "icon": "🤖"
                }

                self.save_configuration()
                self.refresh_chatbot_list()
                dialog.destroy()
            else:
                # Show error
                error_label.configure(text="Please fill in all fields")

        add_button = ctk.CTkButton(
            dialog,
            text="Add Chatbot",
            command=add_chatbot,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        add_button.pack(anchor="center", pady=20)

        # Error label
        error_label = ctk.CTkLabel(
            dialog,
            text="",
            text_color=self.colors["error"]
        )
        error_label.pack(anchor="center")

    def refresh_chatbot_list(self):
        """Refresh the list of chatbots in settings"""
        # Clear existing items
        for widget in self.chatbot_list_frame.winfo_children():
            widget.destroy()

        # Add header
        header = ctk.CTkFrame(
            self.chatbot_list_frame,
            fg_color="transparent"
        )
        header.pack(fill="x", padx=15, pady=5)

        ctk.CTkLabel(
            header,
            text="Name",
            font=ctk.CTkFont(weight="bold"),
            text_color=self.colors["text_bright"],
            width=100
        ).pack(side="left")

        ctk.CTkLabel(
            header,
            text="Type",
            font=ctk.CTkFont(weight="bold"),
            text_color=self.colors["text_bright"],
            width=100
        ).pack(side="left")

        ctk.CTkLabel(
            header,
            text="Status",
            font=ctk.CTkFont(weight="bold"),
            text_color=self.colors["text_bright"],
            width=100
        ).pack(side="left")

        # Add chatbots
        for name, config in self.config.get("chatbots", {}).items():
            self.add_chatbot_list_item(name, config)

    def add_chatbot_list_item(self, name, config):
        """Add a single chatbot item to the list"""
        # Create item frame with hover effect
        item = ctk.CTkFrame(
            self.chatbot_list_frame,
            fg_color=self.colors["bg_dark"],
            corner_radius=10,
            height=70
        )
        item.pack(fill="x", padx=5, pady=5)
        item.pack_propagate(False)

        # Add hover effect
        def on_enter(e):
            item.configure(fg_color=self.colors["bg_light"])

        def on_leave(e):
            item.configure(fg_color=self.colors["bg_dark"])

        item.bind("<Enter>", on_enter)
        item.bind("<Leave>", on_leave)

        # Icon and name container
        info_frame = ctk.CTkFrame(
            item,
            fg_color="transparent"
        )
        info_frame.pack(side="left", fill="y", padx=10)

        # Icon with colored background
        icon_frame = ctk.CTkFrame(
            info_frame,
            fg_color=config.get("color", self.colors["accent_primary"]),
            width=40,
            height=40,
            corner_radius=20
        )
        icon_frame.pack(side="left", padx=(0, 10))
        icon_frame.pack_propagate(False)

        icon_label = ctk.CTkLabel(
            icon_frame,
            text=config.get("icon", "🤖"),
            font=ctk.CTkFont(size=20)
        )
        icon_label.place(relx=0.5, rely=0.5, anchor="center")

        # Name and type
        text_frame = ctk.CTkFrame(
            info_frame,
            fg_color="transparent"
        )
        text_frame.pack(side="left", fill="y")

        name_label = ctk.CTkLabel(
            text_frame,
            text=name,
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        name_label.pack(anchor="w")

        type_label = ctk.CTkLabel(
            text_frame,
            text=config.get("type", "Unknown"),
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        type_label.pack(anchor="w")

        # Status indicator
        status_color = self.colors["status_green"] if config.get(
            "status") == "Ready" else self.colors["status_red"]
        status_frame = ctk.CTkFrame(
            item,
            fg_color="transparent"
        )
        status_frame.pack(side="right", fill="y", padx=10)

        status_dot = ctk.CTkLabel(
            status_frame,
            text="●",
            font=ctk.CTkFont(size=20),
            text_color=status_color
        )
        status_dot.pack(side="right", padx=5)

        status_label = ctk.CTkLabel(
            status_frame,
            text=config.get("status", "Unknown"),
            font=ctk.CTkFont(size=12),
            text_color=status_color
        )
        status_label.pack(side="right")

        # Make the entire item clickable
        item.bind(
            "<Button-1>",
            lambda e: self.show_chatbot_settings(
                name,
                config))

    def delete_chatbot(self, name):
        """Delete a chatbot from the configuration"""
        if name in self.config.get("chatbots", {}):
            del self.config["chatbots"][name]
            self.save_configuration()
            self.refresh_chatbot_list()
            # Also refresh the dashboard
            self.add_sample_chatbot_cards()

    def run(self):
        """Run the application main loop"""
        try:
            # Log startup
            logging.info("Starting DragonVoice application")

            # Update status
            self.update_status("Application started successfully")

            # Start the main event loop
            self.app.mainloop()

        except Exception as e:
            logging.error(f"Error in main loop: {str(e)}")
            raise

    def create_help_getting_started(self, parent):
        """Create the getting started help content"""
        # Welcome section
        welcome_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        welcome_frame.pack(fill="x", padx=20, pady=10)

        welcome_label = ctk.CTkLabel(
            welcome_frame,
            text="Welcome to DragonVoice",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        welcome_label.pack(anchor="w", padx=15, pady=(10, 5))

        welcome_text = ctk.CTkTextbox(
            welcome_frame,
            height=100,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        welcome_text.pack(fill="x", padx=15, pady=(0, 10))
        welcome_text.insert(
            "1.0",
            """DragonVoice is a powerful voice-controlled interface for interacting with multiple AI chatbots. This guide will help you get started with the basic features and setup.""")
        welcome_text.configure(state="disabled")

        # Quick Start Guide
        quickstart_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        quickstart_frame.pack(fill="x", padx=20, pady=10)

        quickstart_label = ctk.CTkLabel(
            quickstart_frame,
            text="Quick Start Guide",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        quickstart_label.pack(anchor="w", padx=15, pady=(10, 5))

        steps_text = ctk.CTkTextbox(
            quickstart_frame,
            height=200,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        steps_text.pack(fill="x", padx=15, pady=(0, 10))
        steps_text.insert("1.0", """1. Configure Your Chatbots
• Click the Settings button (⚙️) in the top right
• Go to the Chatbots tab
• Click "Add New Chatbot" and enter your API keys

2. Start Voice Assistant
• Click the "Start Voice Assistant" button in the header
• Wait for the status to show "Ready"
• Say your wake word (default: "Hey Dragon")

3. Issue Commands
• After the wake word, speak your command
• Example: "Ask what are the latest treatments for hypertension"
• The command will be sent to the appropriate chatbot

4. View Responses
• Responses appear in the chatbot windows
• You can interact with multiple chatbots simultaneously
• Use voice commands to switch between chatbots""")
        steps_text.configure(state="disabled")

    def create_help_voice_commands(self, parent):
        """Create the voice commands help content"""
        # Available Commands
        commands_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        commands_frame.pack(fill="x", padx=20, pady=10)

        commands_label = ctk.CTkLabel(
            commands_frame,
            text="Available Voice Commands",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        commands_label.pack(anchor="w", padx=15, pady=(10, 5))

        commands_text = ctk.CTkTextbox(
            commands_frame,
            height=400,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        commands_text.pack(fill="x", padx=15, pady=(0, 10))
        commands_text.insert("1.0", """Basic Commands:
• "Hey Dragon" - Wake word to start listening
• "Ask [question]" - Send a question to the active chatbot
• "Switch to [chatbot name]" - Change the active chatbot
• "Stop listening" - Deactivate voice recognition
• "Clear chat" - Clear the current conversation

Chatbot Control:
• "New conversation" - Start a fresh chat session
• "Save conversation" - Save the current chat history
• "Load conversation" - Restore a previous chat session
• "Export as PDF" - Export the conversation to PDF

Window Management:
• "Maximize window" - Expand the current chatbot window
• "Minimize window" - Minimize the current chatbot window
• "Arrange windows" - Organize all chatbot windows
• "Close window" - Close the current chatbot window

System Commands:
• "Open settings" - Show the settings dialog
• "Show help" - Display this help window
• "Check status" - Report system status
• "Exit program" - Close DragonVoice

Tips:
• Speak clearly and at a normal pace
• Wait for the "Listening..." indicator
• You can customize the wake word in settings
• Commands are case-insensitive""")
        commands_text.configure(state="disabled")

    def create_help_chatbots(self, parent):
        """Create the chatbots help content"""
        # Chatbot Overview
        overview_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        overview_frame.pack(fill="x", padx=20, pady=10)

        overview_label = ctk.CTkLabel(
            overview_frame,
            text="Working with Chatbots",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        overview_label.pack(anchor="w", padx=15, pady=(10, 5))

        overview_text = ctk.CTkTextbox(
            overview_frame,
            height=300,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        overview_text.pack(fill="x", padx=15, pady=(0, 10))
        overview_text.insert(
            "1.0", """DragonVoice supports multiple AI chatbots, allowing you to:
• Interact with different AI models simultaneously
• Compare responses across different chatbots
• Use specialized models for specific tasks
• Maintain separate conversation contexts

Supported Chatbots:
1. GPT (OpenAI)
   • Requires OpenAI API key
   • Supports GPT-3.5 and GPT-4
   • Best for general knowledge and coding

2. Claude (Anthropic)
   • Requires Anthropic API key
   • Excellent for analysis and writing
   • Strong ethical considerations

3. Gemini (Google)
   • Requires Google API key
   • Good at mathematical reasoning
   • Supports image understanding

4. Custom Chatbots
   • Add your own API integrations
   • Configure custom endpoints
   • Define specialized behaviors

Setting Up Chatbots:
1. Obtain API keys from providers
2. Add chatbots in Settings > Chatbots
3. Configure any special parameters
4. Test the connection

Best Practices:
• Keep API keys secure
• Monitor usage and costs
• Regular backup conversations
• Update chatbot configs as needed""")
        overview_text.configure(state="disabled")

    def create_help_troubleshooting(self, parent):
        """Create the troubleshooting help content"""
        # Common Issues
        issues_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        issues_frame.pack(fill="x", padx=20, pady=10)

        issues_label = ctk.CTkLabel(
            issues_frame,
            text="Common Issues",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        issues_label.pack(anchor="w", padx=15, pady=(10, 5))

        issues_text = ctk.CTkTextbox(
            issues_frame,
            height=400,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        issues_text.pack(fill="x", padx=15, pady=(0, 10))
        issues_text.insert("1.0", """Voice Recognition Issues:
1. Microphone Not Detected
   • Check microphone connections
   • Verify Windows permissions
   • Select correct input device in settings
   • Try restarting the application

2. Poor Recognition Accuracy
   • Adjust microphone sensitivity
   • Reduce background noise
   • Speak clearly and at normal pace
   • Check for latest updates

Chatbot Connection Problems:
1. API Key Errors
   • Verify API key is valid
   • Check for sufficient credits
   • Ensure correct API endpoint
   • Look for error messages in logs

2. Slow Responses
   • Check internet connection
   • Verify server status
   • Adjust timeout settings
   • Consider upgrading API tier

Interface Issues:
1. Display Problems
   • Update graphics drivers
   • Check resolution settings
   • Try different theme
   • Restart application

2. Performance Issues
   • Close unused applications
   • Check CPU/memory usage
   • Reduce number of active chatbots
   • Clear conversation history

Getting Help:
• Check application logs
• Visit our support forum
• Submit bug reports
• Contact technical support""")
        issues_text.configure(state="disabled")

    def create_help_about(self, parent):
        """Create the about help content"""
        # About Information
        about_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        about_frame.pack(fill="x", padx=20, pady=10)

        # Logo/Icon placeholder
        logo_label = ctk.CTkLabel(
            about_frame,
            text="🐉",
            font=ctk.CTkFont(size=48),
            text_color=self.colors["accent_primary"]
        )
        logo_label.pack(anchor="center", pady=20)

        # App title
        title_label = ctk.CTkLabel(
            about_frame,
            text="DragonVoice",
            font=ctk.CTkFont(size=24, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title_label.pack(anchor="center")

        # Version
        version_label = ctk.CTkLabel(
            about_frame,
            text="Version 2.0",
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        version_label.pack(anchor="center", pady=(0, 20))

        # Description
        description_text = ctk.CTkTextbox(
            about_frame,
            height=100,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        description_text.pack(fill="x", padx=15, pady=(0, 10))
        description_text.insert(
            "1.0",
            """DragonVoice is a powerful voice-controlled interface for medical professionals to interact with multiple AI chatbots simultaneously. It provides a seamless way to access and compare AI insights while maintaining focus on patient care.""")
        description_text.configure(state="disabled")

        # Credits
        credits_label = ctk.CTkLabel(
            about_frame,
            text="Credits",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        credits_label.pack(anchor="w", padx=15, pady=(10, 5))

        credits_text = ctk.CTkTextbox(
            about_frame,
            height=100,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        credits_text.pack(fill="x", padx=15, pady=(0, 10))
        credits_text.insert("1.0", """• OpenAI Whisper - Speech Recognition
• CustomTkinter - GUI Framework
• Various AI Models - Chatbot Integration
• Open Source Community - Libraries and Tools

Special thanks to all contributors and users who have helped improve DragonVoice.""")
        credits_text.configure(state="disabled")

        # Links
        links_frame = ctk.CTkFrame(
            about_frame,
            fg_color="transparent"
        )
        links_frame.pack(fill="x", padx=15, pady=10)

        website_button = ctk.CTkButton(
            links_frame,
            text="Website",
            width=100,
            command=lambda: webbrowser.open("https://dragonvoice.ai")
        )
        website_button.pack(side="left", padx=5)

        docs_button = ctk.CTkButton(
            links_frame,
            text="Documentation",
            width=100,
            command=lambda: webbrowser.open("https://docs.dragonvoice.ai")
        )
        docs_button.pack(side="left", padx=5)

        github_button = ctk.CTkButton(
            links_frame,
            text="GitHub",
            width=100,
            command=lambda: webbrowser.open("https://github.com/dragonvoice")
        )
        github_button.pack(side="left", padx=5)

    def toggle_theme(self):
        """Toggle between light and dark themes"""
        try:
            # Get current appearance mode
            current_mode = ctk.get_appearance_mode()

            # Toggle mode
            new_mode = "Light" if current_mode == "Dark" else "Dark"
            ctk.set_appearance_mode(new_mode)

            # Update status
            self.update_status(f"Theme changed to {new_mode} mode")

        except Exception as e:
            logging.error(f"Error toggling theme: {str(e)}")
            self.update_status(f"Failed to toggle theme: {str(e)}", "error")

    def start_system_monitoring(self):
        """Start monitoring system resources"""
        try:
            # Initialize status variables if they don't exist
            if not hasattr(self, 'cpu_usage'):
                self.cpu_usage = 0
            if not hasattr(self, 'memory_usage'):
                self.memory_usage = 0
            if not hasattr(self, 'disk_usage'):
                self.disk_usage = 0
            if not hasattr(self, 'voice_status'):
                self.voice_status = "Idle"

            def update_system_info():
                try:
                    # Update CPU usage
                    self.cpu_usage = psutil.cpu_percent(interval=None)

                    # Update memory usage
                    memory = psutil.virtual_memory()
                    self.memory_usage = memory.percent

                    # Update disk usage
                    disk = psutil.disk_usage('/')
                    self.disk_usage = disk.percent

                    # Update status indicators if they exist
                    for i, (value, color) in enumerate([
                        (self.cpu_usage, self.get_resource_color(self.cpu_usage)),
                        (self.memory_usage, self.get_resource_color(self.memory_usage)),
                        (self.disk_usage, self.get_resource_color(self.disk_usage))
                    ]):
                        status_indicator = getattr(self, f'status_indicator_{i}', None)
                        status_value = getattr(self, f'status_value_{i}', None)
                        if status_indicator and status_value:
                            status_indicator.configure(fg_color=color)
                            status_value.configure(
                                text=f"{value:.1f}%",
                                text_color=self.colors["text_bright"]
                            )

                    # Update voice status
                    if hasattr(self, 'recording_active'):
                        voice_status = "Recording" if self.recording_active else "Idle"
                        status_color = self.colors["status_green"] if self.recording_active else self.colors["status_gray"]
                        
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=status_color)
                        if hasattr(self, 'status_value_3'):
                            self.status_value_3.configure(
                                text=voice_status,
                                text_color=self.colors["text_bright"]
                            )

                    # Schedule next update
                    self.app.after(1000, update_system_info)

                except Exception as e:
                    logging.error(f"Error updating system info: {str(e)}")
                    # Try again later
                    self.app.after(5000, update_system_info)

            # Start the update loop
            update_system_info()

        except Exception as e:
            logging.error(f"Error starting system monitoring: {str(e)}")

    def get_resource_color(self, value):
        """Get color based on resource usage percentage"""
        if value < 60:
            return self.colors["status_green"]  # Green for normal
        elif value < 80:
            return self.colors["status_yellow"]  # Yellow for warning
        else:
            return self.colors["status_red"]  # Red for critical

    def filter_chatbot_list(self):
        """Filter the chatbot list based on search text"""
        search_text = self.search_var.get().lower()

        # Clear existing items
        for widget in self.chatbot_list_frame.winfo_children():
            widget.destroy()

        # Add filtered chatbots
        for name, config in self.config.get("chatbots", {}).items():
            if search_text in name.lower():
                self.add_chatbot_list_item(name, config)

    def show_chatbot_settings(self, name, config):
        """Show settings for the selected chatbot"""
        # Update header
        self.selected_chatbot_label.configure(text=f"Settings: {name}")

        # Clear existing settings
        for widget in self.settings_content.winfo_children():
            widget.destroy()

        # Create settings sections
        sections = [
            ("General Settings", self.create_general_settings),
            ("API Configuration", self.create_api_settings),
            ("Model Settings", self.create_model_settings),
            ("Response Settings", self.create_response_settings),
            ("Advanced Options", self.create_advanced_settings)
        ]

        for title, create_func in sections:
            section = create_func(self.settings_content, name, config)
            section.pack(fill="x", padx=10, pady=5)

    def create_general_settings(self, parent, name, config):
        """Create general settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="General Settings",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # Display name
        name_frame = ctk.CTkFrame(frame, fg_color="transparent")
        name_frame.pack(fill="x", padx=15, pady=5)

        name_label = ctk.CTkLabel(
            name_frame,
            text="Display Name:",
            width=120,
            anchor="w"
        )
        name_label.pack(side="left")

        name_entry = ctk.CTkEntry(
            name_frame,
            width=200,
            placeholder_text="Enter display name"
        )
        name_entry.insert(0, name)
        name_entry.pack(side="left", padx=10)

        # Icon selection
        icon_frame = ctk.CTkFrame(frame, fg_color="transparent")
        icon_frame.pack(fill="x", padx=15, pady=5)

        icon_label = ctk.CTkLabel(
            icon_frame,
            text="Icon:",
            width=120,
            anchor="w"
        )
        icon_label.pack(side="left")

        icons = ["🤖", "🧠", "💡", "🔍", "💬", "🌐", "📚", "⚡"]
        icon_var = ctk.StringVar(value=config.get("icon", "🤖"))

        for icon in icons:
            btn = ctk.CTkButton(
                icon_frame,
                text=icon,
                width=40,
                height=40,
                corner_radius=20,
                fg_color=self.colors["bg_medium"] if icon != icon_var.get() else self.colors["accent_primary"],
                hover_color=self.colors["accent_secondary"],
                command=lambda i=icon: [
                    icon_var.set(i),
                    self.update_chatbot_config(
                        name,
                        "icon",
                        i)])
            btn.pack(side="left", padx=2)

        return frame

    def create_api_settings(self, parent, name, config):
        """Create API settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="API Configuration",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # API Key
        key_frame = ctk.CTkFrame(frame, fg_color="transparent")
        key_frame.pack(fill="x", padx=15, pady=5)

        key_label = ctk.CTkLabel(
            key_frame,
            text="API Key:",
            width=120,
            anchor="w"
        )
        key_label.pack(side="left")

        key_entry = ctk.CTkEntry(
            key_frame,
            width=300,
            placeholder_text="Enter API key",
            show="*"
        )
        key_entry.insert(0, config.get("api_key", ""))
        key_entry.pack(side="left", padx=10)

        show_key = ctk.CTkButton(
            key_frame, text="👁️", width=40, command=lambda: key_entry.configure(
                show="" if key_entry.cget("show") == "*" else "*"))
        show_key.pack(side="left")

        # API Endpoint
        endpoint_frame = ctk.CTkFrame(frame, fg_color="transparent")
        endpoint_frame.pack(fill="x", padx=15, pady=5)

        endpoint_label = ctk.CTkLabel(
            endpoint_frame,
            text="API Endpoint:",
            width=120,
            anchor="w"
        )
        endpoint_label.pack(side="left")

        endpoint_entry = ctk.CTkEntry(
            endpoint_frame,
            width=300,
            placeholder_text="Enter API endpoint"
        )
        endpoint_entry.insert(0, config.get("endpoint", ""))
        endpoint_entry.pack(side="left", padx=10)

        # Test connection button
        test_button = ctk.CTkButton(
            frame,
            text="Test Connection",
            command=lambda: self.test_chatbot_connection(name),
            fg_color=self.colors["accent_secondary"]
        )
        test_button.pack(anchor="e", padx=15, pady=10)

        return frame

    def create_model_settings(self, parent, name, config):
        """Create model settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="Model Settings",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # Model selection
        model_frame = ctk.CTkFrame(frame, fg_color="transparent")
        model_frame.pack(fill="x", padx=15, pady=5)

        model_label = ctk.CTkLabel(
            model_frame,
            text="Model:",
            width=120,
            anchor="w"
        )
        model_label.pack(side="left")

        models = {
            "GPT": ["gpt-4", "gpt-3.5-turbo", "gpt-3.5-turbo-16k"],
            "Claude": ["claude-2", "claude-instant"],
            "Gemini": ["gemini-pro", "gemini-pro-vision"],
            "Custom": ["custom-model"]
        }

        model_type = config.get("type", "GPT")
        model_var = ctk.StringVar(
            value=config.get(
                "model", models[model_type][0]))

        model_combo = ctk.CTkComboBox(
            model_frame,
            width=200,
            values=models[model_type],
            variable=model_var,
            state="readonly"
        )
        model_combo.pack(side="left", padx=10)

        # Temperature
        temp_frame = ctk.CTkFrame(frame, fg_color="transparent")
        temp_frame.pack(fill="x", padx=15, pady=5)

        temp_label = ctk.CTkLabel(
            temp_frame,
            text="Temperature:",
            width=120,
            anchor="w"
        )
        temp_label.pack(side="left")

        temp_var = ctk.DoubleVar(value=config.get("temperature", 0.7))
        temp_slider = ctk.CTkSlider(
            temp_frame,
            from_=0.0,
            to=2.0,
            variable=temp_var,
            width=200
        )
        temp_slider.pack(side="left", padx=10)

        temp_value = ctk.CTkLabel(
            temp_frame,
            textvariable=temp_var,
            width=50
        )
        temp_value.pack(side="left")

        return frame

    def create_response_settings(self, parent, name, config):
        """Create response settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="Response Settings",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # Max tokens
        tokens_frame = ctk.CTkFrame(frame, fg_color="transparent")
        tokens_frame.pack(fill="x", padx=15, pady=5)

        tokens_label = ctk.CTkLabel(
            tokens_frame,
            text="Max Tokens:",
            width=120,
            anchor="w"
        )
        tokens_label.pack(side="left")

        tokens_var = ctk.IntVar(value=config.get("max_tokens", 2000))
        tokens_slider = ctk.CTkSlider(
            tokens_frame,
            from_=100,
            to=4000,
            variable=tokens_var,
            width=200
        )
        tokens_slider.pack(side="left", padx=10)

        tokens_value = ctk.CTkLabel(
            tokens_frame,
            textvariable=tokens_var,
            width=50
        )
        tokens_value.pack(side="left")

        # Response format
        format_frame = ctk.CTkFrame(frame, fg_color="transparent")
        format_frame.pack(fill="x", padx=15, pady=5)

        format_label = ctk.CTkLabel(
            format_frame,
            text="Format:",
            width=120,
            anchor="w"
        )
        format_label.pack(side="left")

        format_var = ctk.StringVar(value=config.get("format", "markdown"))
        formats = ["markdown", "html", "plain"]

        format_combo = ctk.CTkComboBox(
            format_frame,
            width=200,
            values=formats,
            variable=format_var,
            state="readonly"
        )
        format_combo.pack(side="left", padx=10)

        return frame

    def create_advanced_settings(self, parent, name, config):
        """Create advanced settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="Advanced Options",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # System prompt
        prompt_label = ctk.CTkLabel(
            frame,
            text="System Prompt:",
            anchor="w"
        )
        prompt_label.pack(anchor="w", padx=15, pady=(5, 0))

        prompt_text = ctk.CTkTextbox(
            frame,
            height=100,
            wrap="word"
        )
        prompt_text.pack(fill="x", padx=15, pady=5)
        prompt_text.insert("1.0", config.get("system_prompt", ""))

        # Checkboxes
        options_frame = ctk.CTkFrame(frame, fg_color="transparent")
        options_frame.pack(fill="x", padx=15, pady=5)

        stream_var = ctk.BooleanVar(value=config.get("stream", True))
        stream_cb = ctk.CTkCheckBox(
            options_frame,
            text="Stream responses",
            variable=stream_var
        )
        stream_cb.pack(anchor="w")

        history_var = ctk.BooleanVar(value=config.get("keep_history", True))
        history_cb = ctk.CTkCheckBox(
            options_frame,
            text="Keep conversation history",
            variable=history_var
        )
        history_cb.pack(anchor="w", pady=5)

        # Action buttons
        buttons_frame = ctk.CTkFrame(frame, fg_color="transparent")
        buttons_frame.pack(fill="x", padx=15, pady=10)

        save_button = ctk.CTkButton(
            buttons_frame,
            text="Save Changes",
            command=lambda: self.save_chatbot_settings(name),
            fg_color=self.colors["accent_primary"]
        )
        save_button.pack(side="left", padx=5)

        delete_button = ctk.CTkButton(
            buttons_frame,
            text="Delete Chatbot",
            command=lambda: self.delete_chatbot(name),
            fg_color=self.colors["error"]
        )
        delete_button.pack(side="right", padx=5)

        return frame

    def refresh_chatbots(self):
        """Refresh the chatbot cards and status in the dashboard"""
        # Update the chatbot list in the dedicated chatbots tab if it exists
        if hasattr(
                self,
                'chatbot_list_frame') and self.chatbot_list_frame.winfo_exists():
            self.refresh_chatbot_list()

        # Update status
        self.update_status("Chatbots refreshed", "info")

        # Refresh the monitor visualization
        if hasattr(self, 'monitor_canvas'):
            self.refresh_monitor_visualization()

        return True

    def load_config(self) -> dict:
        """Load the configuration from the JSON file"""
        try:
            with open(self.config_path, "r") as f:
                config = json.load(f)
                logging.info("Configuration loaded successfully")
                return config
        except FileNotFoundError:
            logging.error(f"Configuration file not found: {self.config_path}")
            return {}
        except json.JSONDecodeError:
            logging.error(
                f"Invalid JSON in configuration file: {self.config_path}")
            return {}

    def toggle_voice_assistant(self):
        """Toggle the voice assistant on/off"""
        # Check if we're in recording mode
        if hasattr(self, 'recording_active') and self.recording_active:
            # Update button text and color
            if hasattr(self, 'toggle_button'):
                self.toggle_button.configure(
                    text="Start Voice Assistant",
                    fg_color=self.colors["status_green"]  # Green when off
                )

            # Stop recording and transcribe
            if self.stop_manual_recording():
                # Transcribe the recording
                self.transcribe_last_recording()
                # Disable continuous recording
                self.continuous_recording = False

            # Update status indicator
            if hasattr(self, 'status_indicator'):
                self.status_indicator.configure(
                    fg_color=self.colors["status_gray"])
                
            # Enable record button, disable stop button
            if hasattr(self, 'record_button'):
                self.record_button.configure(state="normal")
            if hasattr(self, 'stop_record_button'):
                self.stop_record_button.configure(state="disabled")
        else:
            # Update button text and color
            if hasattr(self, 'toggle_button'):
                self.toggle_button.configure(
                    text="Stop Voice Assistant",
                    fg_color=self.colors["status_red"]  # Red when recording
                )

            # Start recording
            success = self.start_manual_recording()
            if success:
                # Enable continuous recording
                self.continuous_recording = True
                self.recording_active = True

                # Update status indicator
                if hasattr(self, 'status_indicator'):
                    self.status_indicator.configure(
                        fg_color=self.colors["status_green"])
                        
                # Disable record button, enable stop button
                if hasattr(self, 'record_button'):
                    self.record_button.configure(state="disabled")
                if hasattr(self, 'stop_record_button'):
                    self.stop_record_button.configure(state="normal")

                if hasattr(self, 'text_display'):
                    # Update the text display to show that voice assistant is active
                    self.text_display.configure(state="normal")
                    timestamp = datetime.now().strftime("%H:%M:%S")

                    # Add system message with formatting
                    system_pos = self.text_display.index("end-1c")
                    self.text_display.insert(
                        "end", f"[{timestamp}] Voice Assistant activated. Speak now...\n\n")
                    self.text_display._textbox.tag_add(
                        "system", system_pos, self.text_display.index("end-2c"))

                    self.text_display.see("end")
                    self.text_display.configure(state="disabled")
                    # Update status
                    self.update_status(
                        "Voice Assistant activated. Speak now...",
                        log_level="info")

    def start_manual_recording(self):
        """Start manual recording"""
        if not hasattr(self, 'whisper_recognizer') or self.whisper_recognizer is None:
            self.update_status("Whisper recognizer not initialized", log_level="error")
            return False

        try:
            # Get the selected microphone device if available
            device_id = None
            if hasattr(self, 'mic_device_var') and self.mic_device_var.get() != "Default":
                # Extract device ID from the selection string
                device_str = self.mic_device_var.get()
                if ":" in device_str:
                    device_id = int(device_str.split(":")[0].strip())
            
            # Log the device being used
            logging.info(f"Started recording audio with device_id: {device_id}")
            
            # Start recording with the selected device
            self.whisper_recognizer.start_recording(device=device_id)
            self.recording_active = True

            # Start level meter animation
            self.animate_level_meter()

            # Update UI
            if hasattr(self, 'toggle_button'):
                self.toggle_button.configure(text="Stop Voice Assistant")
                
            # Update status
            self.update_status("Voice Assistant activated. Speak now...", log_level="info")
            return True
        except Exception as e:
            self.update_status(f"Failed to start recording: {str(e)}", log_level="error")
            return False

    def stop_manual_recording(self):
        """Stop recording audio manually"""
        if not hasattr(self, 'whisper_recognizer'):
            self.update_status(
                "Whisper recognizer not initialized",
                log_level="error")
            return False

        try:
            # Stop recording
            success = self.whisper_recognizer.stop_recording()
            if success:
                self.update_status("Recording stopped", log_level="info")
                # Update UI to show stopped state
                self.toggle_button.configure(
                    text="Start Voice Assistant",
                    fg_color=self.colors["status_green"]
                )
                # Enable record button, disable stop button
                if hasattr(self, 'record_button'):
                    self.record_button.configure(state="normal")
                if hasattr(self, 'stop_record_button'):
                    self.stop_record_button.configure(state="disabled")
                
                # Stop level meter animation
                self.recording_active = False

                # Update text display to show that voice assistant is stopped
                if hasattr(self, 'text_display'):
                    self.text_display.configure(state="normal")
                    timestamp = datetime.now().strftime("%H:%M:%S")

                    # Add system message with formatting
                    system_pos = self.text_display.index("end-1c")
                    self.text_display.insert(
                        "end", f"[{timestamp}] Voice Assistant stopped.\n\n")
                    self.text_display._textbox.tag_add(
                        "system", system_pos, self.text_display.index("end-2c"))

                    self.text_display.see("end")
                    self.text_display.configure(state="disabled")

                # Transcribe the recording
                self.transcribe_last_recording()

                return True
            else:
                self.update_status("No recording to stop", log_level="warning")
                return False
        except Exception as e:
            self.update_status(
                f"Error stopping recording: {str(e)}",
                log_level="error")
            return False

    def transcribe_last_recording(self):
        """Transcribe the last recording using Whisper API"""
        try:
            # Check if whisper recognizer is initialized
            if not hasattr(self, 'whisper_recognizer') or self.whisper_recognizer is None:
                self.update_status("Whisper recognizer not initialized")
                logging.warning("Attempted to transcribe without initialized recognizer")
                return
                
            # Save audio to file and check if we have audio data
            if not hasattr(self, 'audio_data') or self.audio_data is None or len(self.audio_data) == 0:
                self.update_status("No audio data available for transcription")
                logging.warning("No audio data available for transcription")
                return
                
            # Update status
            self.update_status("Transcribing audio...")
            
            # Transcribe the audio
            transcription = self.whisper_recognizer.transcribe_audio(self.audio_data)
            
            if transcription:
                # Update status
                self.update_status(f"Transcription successful: {transcription[:30]}...")
                
                # Add to transcription display
                self.add_to_transcription(transcription)
                
                # Add to voice commands display
                self.add_to_text_display(transcription)
                
                # Auto-start recording if continuous mode is enabled
                if self.continuous_recording:
                    self.start_manual_recording()
            else:
                self.update_status("Transcription failed or returned empty result")
                logging.warning("Transcription failed or returned empty result")
                
        except Exception as e:
            self.update_status(f"Error during transcription: {str(e)}")
            logging.error(f"Error during transcription: {str(e)}", exc_info=True)
            
        # Disable the transcribe button after transcription
        if hasattr(self, 'transcribe_button'):
            self.transcribe_button.configure(state="disabled")

    def animate_level_meter(self):
        """Animate the microphone level meter during recording"""
        if not hasattr(self, 'recording_active') or not self.recording_active:
            # Even when not recording, update with zero level to show the meter
            if hasattr(self, 'synth_bar'):
                self.synth_bar.update(0)
            return

        try:
            # Get the latest audio data if available
            if hasattr(self, 'whisper_recognizer') and self.whisper_recognizer.audio_data:
                latest_chunk = self.whisper_recognizer.audio_data[-1]
                
                # Calculate volume (RMS)
                volume = np.sqrt(np.mean(latest_chunk**2))
                
                # Apply sensitivity/gain from the slider
                if hasattr(self, 'sensitivity_var'):
                    # Apply a logarithmic scaling for more natural sensitivity control
                    sensitivity = self.sensitivity_var.get()
                    volume = volume * (np.exp(sensitivity * 2) - 1)
                
                # Add noise floor threshold to filter out background noise
                noise_floor = 0.01  # Adjust this value based on testing
                if volume < noise_floor:
                    volume = 0
                
                # Scale for visualization (0-100) with more moderate scaling
                volume = min(100, volume * 150)  # Reduced from 300 to 150

                # Update the level meter
                if hasattr(self, 'synth_bar'):
                    self.synth_bar.update(volume)
                
                # Update voice status indicator
                if hasattr(self, 'status_value_3'):
                    if volume > 70:  # High volume
                        self.status_value_3.configure(text="Speaking")
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=self.colors["status_red"])
                    elif volume > 30:  # Medium volume
                        self.status_value_3.configure(text="Active")
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=self.colors["status_yellow"])
                    else:  # Low/no volume
                        self.status_value_3.configure(text="Listening")
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=self.colors["status_green"])
            else:
                # If no audio data, show no activity
                if hasattr(self, 'synth_bar'):
                    self.synth_bar.update(0)
            
            # Continue animation if recording is still active
            if self.recording_active:
                self.app.after(50, self.animate_level_meter)  # Faster updates for smoother animation
                
        except Exception as e:
            logging.error(f"Error in level meter animation: {str(e)}")
            # Try to continue animation despite error
            if hasattr(self, 'recording_active') and self.recording_active:
                self.app.after(100, self.animate_level_meter)

    def refresh_monitor_visualization(self):
        """Update the system monitor visualization"""
        try:
            # Check if monitor_canvas exists
            if not hasattr(self, 'monitor_canvas'):
                logging.warning("monitor_canvas not initialized yet")
                return

            # Clear previous visualization
            self.monitor_canvas.delete("all")

            # Get system metrics
            import psutil
            cpu_percent = psutil.cpu_percent()
            memory_percent = psutil.virtual_memory().percent
            disk_percent = psutil.disk_usage('/').percent

            # Canvas dimensions
            width = self.monitor_canvas.winfo_width()
            height = self.monitor_canvas.winfo_height()

            # Ensure we have valid dimensions
            if width <= 1 or height <= 1:
                # Canvas not properly sized yet, schedule another update
                self.app.after(1000, self.refresh_monitor_visualization)
                return

            # Bar width and spacing
            bar_width = width / 4
            spacing = width / 12

            # Draw CPU bar
            cpu_color = self.get_resource_color(cpu_percent)
            cpu_height = (cpu_percent / 100) * height
            self.monitor_canvas.create_rectangle(
                spacing, height - cpu_height,
                spacing + bar_width, height,
                fill=cpu_color, outline=""
            )
            self.monitor_canvas.create_text(
                spacing + bar_width / 2, height - cpu_height - 15,
                text=f"CPU\n{cpu_percent}%",
                fill=self.colors["text_bright"],
                font=("Helvetica", 10, "bold"),
                justify="center"
            )

            # Draw Memory bar
            mem_color = self.get_resource_color(memory_percent)
            mem_height = (memory_percent / 100) * height
            self.monitor_canvas.create_rectangle(
                spacing * 2 + bar_width, height - mem_height,
                spacing * 2 + bar_width * 2, height,
                fill=mem_color, outline=""
            )
            self.monitor_canvas.create_text(
                spacing * 2 + bar_width * 1.5, height - mem_height - 15,
                text=f"RAM\n{memory_percent}%",
                fill=self.colors["text_bright"],
                font=("Helvetica", 10, "bold"),
                justify="center"
            )

            # Draw Disk bar
            disk_color = self.get_resource_color(disk_percent)
            disk_height = (disk_percent / 100) * height
            self.monitor_canvas.create_rectangle(
                spacing * 3 + bar_width * 2, height - disk_height,
                spacing * 3 + bar_width * 3, height,
                fill=disk_color, outline=""
            )
            self.monitor_canvas.create_text(
                spacing * 3 + bar_width * 2.5, height - disk_height - 15,
                text=f"Disk\n{disk_percent}%",
                fill=self.colors["text_bright"],
                font=("Helvetica", 10, "bold"),
                justify="center"
            )

            # Schedule next update
            self.app.after(2000, self.refresh_monitor_visualization)

        except Exception as e:
            logging.error(f"Error updating monitor visualization: {str(e)}")
            # Try again later
            self.app.after(5000, self.refresh_monitor_visualization)

    def update_status(self, message, log_level="info"):
        """Update the status message in the footer"""
        try:
            # Log the message with appropriate level
            if log_level == "info":
                logging.info(message)
            elif log_level == "warning":
                logging.warning(message)
            elif log_level == "error":
                logging.error(message)

            # Check if status_label exists before updating
            if hasattr(self, 'status_label') and self.status_label is not None:
                self.status_label.configure(text=message)
            else:
                logging.warning(
                    "Status label not initialized yet, can't update status")

        except Exception as e:
            logging.error(f"Error updating status: {str(e)}")
            # Don't raise the exception to avoid crashing the app

    def _adjust_color_brightness(self, hex_color, factor):
        """Adjust the brightness of a hex color"""
        # Convert hex to RGB
        r, g, b = self.hex_to_rgb(hex_color)
        
        # Adjust brightness
        r = max(0, min(255, int(r * factor)))
        g = max(0, min(255, int(g * factor)))
        b = max(0, min(255, int(b * factor)))
        
        # Convert back to hex
        return f'#{r:02x}{g:02x}{b:02x}'
        
    def clear_transcription(self):
        """Clear the transcription display"""
        self.transcription_display.configure(state="normal")
        self.transcription_display.delete("1.0", "end")
        self.transcription_display.insert("end", "Transcribed text will appear here...")
        self.transcription_display.configure(state="disabled")
        self.enter_button.configure(state="disabled")
        
    def clear_text_display(self):
        """Clear the text display"""
        self.text_display.configure(state="normal")
        self.text_display.delete("1.0", "end")
        self.text_display.insert("end", "Voice commands will appear here after starting the voice assistant...")
        self.text_display.configure(state="disabled")

    def toggle_fullscreen(self):
        """Toggle fullscreen mode for the application window"""
        try:
            # Track fullscreen state
            if not hasattr(self, 'is_fullscreen'):
                self.is_fullscreen = False

            # Toggle state
            self.is_fullscreen = not self.is_fullscreen

            # Apply the change
            self.app.attributes("-fullscreen", self.is_fullscreen)

            # Update status
            status = "Fullscreen mode enabled" if self.is_fullscreen else "Fullscreen mode disabled"
            self.update_status(status)

        except Exception as e:
            logging.error(f"Error toggling fullscreen: {str(e)}")
            self.update_status(
                f"Failed to toggle fullscreen: {str(e)}", "error")

    def create_settings_general_tab(self, parent):
        """Create the general settings tab content"""
        # Main container
        container = ctk.CTkFrame(parent, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)

        # Interface settings section
        interface_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        interface_frame.pack(fill="x", pady=(0, 15))

        # Section title
        interface_title = ctk.CTkLabel(
            interface_frame,
            text="Interface Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        interface_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Language setting
        language_frame = ctk.CTkFrame(interface_frame, fg_color="transparent")
        language_frame.pack(fill="x", padx=15, pady=5)

        language_label = ctk.CTkLabel(
            language_frame,
            text="Interface Language",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        language_label.pack(side="left")

        self.language_var = ctk.StringVar(value="English")
        language_dropdown = ctk.CTkOptionMenu(
            language_frame,
            values=[
                "English",
                "Spanish",
                "French",
                "German",
                "Chinese",
                "Japanese"],
            variable=self.language_var,
            width=200)
        language_dropdown.pack(side="left", padx=10)

        # Startup settings section
        startup_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        startup_frame.pack(fill="x", pady=(0, 15))

        # Section title
        startup_title = ctk.CTkLabel(
            startup_frame,
            text="Startup Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        startup_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Auto-start setting
        autostart_frame = ctk.CTkFrame(startup_frame, fg_color="transparent")
        autostart_frame.pack(fill="x", padx=15, pady=5)

        autostart_label = ctk.CTkLabel(
            autostart_frame,
            text="Start with Windows",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        autostart_label.pack(side="left")

        self.autostart_var = ctk.BooleanVar(value=False)
        autostart_switch = ctk.CTkSwitch(
            autostart_frame,
            text="",
            variable=self.autostart_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        autostart_switch.pack(side="left", padx=10)

        # Start minimized setting
        minimized_frame = ctk.CTkFrame(startup_frame, fg_color="transparent")
        minimized_frame.pack(fill="x", padx=15, pady=5)

        minimized_label = ctk.CTkLabel(
            minimized_frame,
            text="Start Minimized",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        minimized_label.pack(side="left")

        self.minimized_var = ctk.BooleanVar(value=False)
        minimized_switch = ctk.CTkSwitch(
            minimized_frame,
            text="",
            variable=self.minimized_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        minimized_switch.pack(side="left", padx=10)

        # Auto-activate voice assistant
        autoactivate_frame = ctk.CTkFrame(
            startup_frame, fg_color="transparent")
        autoactivate_frame.pack(fill="x", padx=15, pady=5)

        autoactivate_label = ctk.CTkLabel(
            autoactivate_frame,
            text="Auto-activate Voice Assistant",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        autoactivate_label.pack(side="left")

        self.autoactivate_var = ctk.BooleanVar(value=False)
        autoactivate_switch = ctk.CTkSwitch(
            autoactivate_frame,
            text="",
            variable=self.autoactivate_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        autoactivate_switch.pack(side="left", padx=10)

        return container

    def create_settings_appearance_tab(self, parent):
        """Create the appearance settings tab content"""
        # Main container
        container = ctk.CTkFrame(parent, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)

        # Theme settings section
        theme_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        theme_frame.pack(fill="x", pady=(0, 15))

        # Section title
        theme_title = ctk.CTkLabel(
            theme_frame,
            text="Theme Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        theme_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Theme selection
        theme_selection_frame = ctk.CTkFrame(
            theme_frame, fg_color="transparent")
        theme_selection_frame.pack(fill="x", padx=15, pady=5)

        theme_label = ctk.CTkLabel(
            theme_selection_frame,
            text="Color Theme",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        theme_label.pack(side="left")

        self.theme_var = ctk.StringVar(value="medical")
        theme_dropdown = ctk.CTkOptionMenu(
            theme_selection_frame,
            values=["medical", "midnight", "cyberpunk"],
            variable=self.theme_var,
            width=200,
            command=self.apply_theme
        )
        theme_dropdown.pack(side="left", padx=10)

        # Appearance mode
        appearance_frame = ctk.CTkFrame(theme_frame, fg_color="transparent")
        appearance_frame.pack(fill="x", padx=15, pady=5)

        appearance_label = ctk.CTkLabel(
            appearance_frame,
            text="Appearance Mode",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        appearance_label.pack(side="left")

        self.appearance_var = ctk.StringVar(value="Dark")
        appearance_dropdown = ctk.CTkOptionMenu(
            appearance_frame,
            values=["Dark", "Light", "System"],
            variable=self.appearance_var,
            width=200,
            command=lambda value: ctk.set_appearance_mode(value)
        )
        appearance_dropdown.pack(side="left", padx=10)

        # Font settings section
        font_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        font_frame.pack(fill="x", pady=(0, 15))

        # Section title
        font_title = ctk.CTkLabel(
            font_frame,
            text="Font Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        font_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Font size
        font_size_frame = ctk.CTkFrame(font_frame, fg_color="transparent")
        font_size_frame.pack(fill="x", padx=15, pady=5)

        font_size_label = ctk.CTkLabel(
            font_size_frame,
            text="Font Size",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        font_size_label.pack(side="left")

        self.font_size_var = ctk.IntVar(value=12)
        font_size_slider = ctk.CTkSlider(
            font_size_frame,
            from_=8,
            to=16,
            number_of_steps=8,
            variable=self.font_size_var,
            width=200
        )
        font_size_slider.pack(side="left", padx=10)

        font_size_value = ctk.CTkLabel(
            font_size_frame,
            textvariable=self.font_size_var,
            width=30
        )
        font_size_value.pack(side="left", padx=5)

        # Preview section
        preview_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        preview_frame.pack(fill="x", pady=(0, 15))

        # Section title
        preview_title = ctk.CTkLabel(
            preview_frame,
            text="Theme Preview",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        preview_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Preview content
        preview_content = ctk.CTkFrame(
            preview_frame,
            fg_color=self.colors["bg_medium"],
            corner_radius=5,
            height=100
        )
        preview_content.pack(fill="x", padx=15, pady=(0, 15))
        preview_content.pack_propagate(False)

        preview_label = ctk.CTkLabel(
            preview_content,
            text="Sample Text",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"]
        )
        preview_label.pack(anchor="center", pady=10)

        preview_button = ctk.CTkButton(
            preview_content,
            text="Sample Button",
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            width=150
        )
        preview_button.pack(anchor="center")

        return container

    def create_settings_voice_tab(self, parent):
        """Create the voice settings tab content"""
        # Main container with gradient background
        container = ctk.CTkFrame(parent, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)

        # Microphone settings section
        mic_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        mic_frame.pack(fill="x", pady=(0, 15))

        # Section title
        mic_title = ctk.CTkLabel(
            mic_frame,
            text="Microphone Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        mic_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Microphone selection
        mic_selection_frame = ctk.CTkFrame(mic_frame, fg_color="transparent")
        mic_selection_frame.pack(fill="x", padx=15, pady=5)

        mic_label = ctk.CTkLabel(
            mic_selection_frame,
            text="Input Device",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        mic_label.pack(side="left")

        # Create a frame for the dropdown and refresh button
        mic_dropdown_frame = ctk.CTkFrame(
            mic_selection_frame, fg_color="transparent")
        mic_dropdown_frame.pack(side="left", fill="x", expand=True)

        # Microphone dropdown
        self.mic_var = ctk.StringVar(value="Default Microphone")
        self.mic_dropdown = ctk.CTkOptionMenu(
            mic_dropdown_frame,
            values=["Default Microphone"],
            variable=self.mic_var,
            width=200
        )
        self.mic_dropdown.pack(side="left", padx=(0, 10))

        # Refresh button
        refresh_button = ctk.CTkButton(
            mic_dropdown_frame,
            text="Refresh",
            command=self.refresh_mic_list,
            fg_color=self.colors["bg_medium"],
            hover_color=self.colors["bg_light"],
            width=80
        )
        refresh_button.pack(side="left")

        # Microphone level visualization
        level_frame = ctk.CTkFrame(mic_frame, fg_color="transparent")
        level_frame.pack(fill="x", padx=15, pady=5)

        level_label = ctk.CTkLabel(
            level_frame,
            text="Input Level",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        level_label.pack(side="left")

        # Level meter canvas
        self.level_canvas = ctk.CTkCanvas(
            level_frame,
            height=24,
            width=200,
            bg=self.colors["bg_dark"],
            highlightthickness=0
        )
        self.level_canvas.pack(side="left", padx=10)

        # Test microphone button
        test_button = ctk.CTkButton(
            level_frame,
            text="Test",
            command=self.test_microphone,
            fg_color=self.colors["accent_secondary"],
            hover_color=self.colors["accent_primary"],
            width=80
        )
        test_button.pack(side="left")

        # Advanced microphone settings
        advanced_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        advanced_frame.pack(fill="x", pady=(0, 15))

        # Section title
        advanced_title = ctk.CTkLabel(
            advanced_frame,
            text="Advanced Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        advanced_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Input gain
        gain_frame = ctk.CTkFrame(advanced_frame, fg_color="transparent")
        gain_frame.pack(fill="x", padx=15, pady=5)

        gain_label = ctk.CTkLabel(
            gain_frame,
            text="Input Gain",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        gain_label.pack(side="left")

        self.gain_var = ctk.DoubleVar(value=1.0)
        gain_slider = ctk.CTkSlider(
            gain_frame,
            from_=0.1,
            to=2.0,
            variable=self.gain_var,
            width=200
        )
        gain_slider.pack(side="left", padx=10)

        gain_value = ctk.CTkLabel(
            gain_frame,
            text=f"{self.gain_var.get():.1f}",
            width=30
        )
        gain_value.pack(side="left", padx=5)

        # Noise threshold
        threshold_frame = ctk.CTkFrame(advanced_frame, fg_color="transparent")
        threshold_frame.pack(fill="x", padx=15, pady=5)

        threshold_label = ctk.CTkLabel(
            threshold_frame,
            text="Noise Threshold",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        threshold_label.pack(side="left")

        self.threshold_var = ctk.DoubleVar(value=0.2)
        threshold_slider = ctk.CTkSlider(
            threshold_frame,
            from_=0.0,
            to=0.5,
            variable=self.threshold_var,
            width=200
        )
        threshold_slider.pack(side="left", padx=10)

        threshold_value = ctk.CTkLabel(
            threshold_frame,
            text=f"{self.threshold_var.get():.2f}",
            width=30
        )
        threshold_value.pack(side="left", padx=5)

        # Echo cancellation
        echo_frame = ctk.CTkFrame(advanced_frame, fg_color="transparent")
        echo_frame.pack(fill="x", padx=15, pady=5)

        echo_label = ctk.CTkLabel(
            echo_frame,
            text="Echo Cancellation",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        echo_label.pack(side="left")

        self.echo_var = ctk.BooleanVar(value=True)
        echo_switch = ctk.CTkSwitch(
            echo_frame,
            text="",
            variable=self.echo_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        echo_switch.pack(side="left", padx=10)

        # Noise reduction
        noise_frame = ctk.CTkFrame(advanced_frame, fg_color="transparent")
        noise_frame.pack(fill="x", padx=15, pady=5)

        noise_label = ctk.CTkLabel(
            noise_frame,
            text="Noise Reduction",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        noise_label.pack(side="left")

        self.noise_var = ctk.BooleanVar(value=True)
        noise_switch = ctk.CTkSwitch(
            noise_frame,
            text="",
            variable=self.noise_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        noise_switch.pack(side="left", padx=10)

        # Initialize microphone list
        self.refresh_mic_list()

        return container

    def refresh_mic_list(self):
        """Refresh the list of available microphones."""
        try:
            devices = sd.query_devices()
            input_devices = []

            # Add a default option
            input_devices.append("Default Microphone")

            # Add all input devices with their IDs for easier identification
            for i, device in enumerate(devices):
                if device['max_input_channels'] > 0:
                    input_devices.append(f"{device['name']} (ID: {i})")

            # Update dropdown
            self.mic_dropdown.configure(values=input_devices)

            # Set default selection
            if input_devices:
                self.mic_var.set(input_devices[0])

            # Update status
            self.update_status(f"Found {len(input_devices)-1} input devices")

        except Exception as e:
            logging.error(f"Error refreshing microphone list: {str(e)}")
            self.update_status("Failed to refresh microphone list", "error")
            # Ensure at least the default option is available
            self.mic_dropdown.configure(values=["Default Microphone"])
            self.mic_var.set("Default Microphone")

    def test_microphone(self):
        """Test the selected microphone by recording and playing back audio."""
        try:
            device_str = self.mic_var.get()
            device_id = None

            # Extract device ID if it's not the default microphone
            if device_str != "Default Microphone":
                try:
                    device_id = int(device_str.split("ID: ")[1].strip(")"))
                    logging.info(f"Testing microphone with ID: {device_id}")
                except Exception as e:
                    logging.error(f"Error parsing device ID: {str(e)}")
                    device_id = None
                    logging.info("Using default microphone instead")

            # Create a modern dialog to show recording status
            dialog = ctk.CTkToplevel(self.app)
            dialog.title("Microphone Test")
            dialog.geometry("400x300")
            dialog.resizable(False, False)
            dialog.transient(self.app)
            dialog.grab_set()

            # Set dialog theme
            dialog.configure(fg_color=self.colors["bg_medium"])

            # Center the dialog
            dialog.update_idletasks()
            width = dialog.winfo_width()
            height = dialog.winfo_height()
            x = (dialog.winfo_screenwidth() // 2) - (width // 2)
            y = (dialog.winfo_screenheight() // 2) - (height // 2)
            dialog.geometry(f"{width}x{height}+{x}+{y}")

            # Title with icon
            title_frame = ctk.CTkFrame(dialog, fg_color="transparent")
            title_frame.pack(fill="x", padx=20, pady=(20, 10))

            title_label = ctk.CTkLabel(
                title_frame,
                text="Microphone Test",
                font=ctk.CTkFont(size=20, weight="bold"),
                text_color=self.colors["text_bright"]
            )
            title_label.pack(side="left")

            # Status label with modern styling
            status_frame = ctk.CTkFrame(
                dialog, fg_color=self.colors["bg_light"], corner_radius=10)
            status_frame.pack(fill="x", padx=20, pady=10)

            status_label = ctk.CTkLabel(
                status_frame,
                text="Initializing microphone test...",
                font=ctk.CTkFont(size=14),
                text_color=self.colors["text_bright"],
                wraplength=350
            )
            status_label.pack(pady=15, padx=15)

            # Progress bar with custom styling
            progress_frame = ctk.CTkFrame(dialog, fg_color="transparent")
            progress_frame.pack(fill="x", padx=20, pady=5)

            progress_label = ctk.CTkLabel(
                progress_frame,
                text="Progress:",
                font=ctk.CTkFont(size=12),
                text_color=self.colors["text_normal"]
            )
            progress_label.pack(anchor="w")

            progress = ctk.CTkProgressBar(
                progress_frame,
                width=360,
                height=15,
                corner_radius=5,
                fg_color=self.colors["bg_dark"],
                progress_color=self.colors["accent_primary"]
            )
            progress.pack(pady=5)
            progress.set(0)

            # Level meter with improved visualization
            level_frame = ctk.CTkFrame(dialog, fg_color="transparent")
            level_frame.pack(fill="x", padx=20, pady=5)

            level_label = ctk.CTkLabel(
                level_frame,
                text="Audio Level:",
                font=ctk.CTkFont(size=12),
                text_color=self.colors["text_normal"]
            )
            level_label.pack(anchor="w")

            meter_bg = ctk.CTkFrame(
                level_frame,
                fg_color=self.colors["bg_dark"],
                height=30,
                width=360,
                corner_radius=5
            )
            meter_bg.pack(pady=5)

            level_indicator = ctk.CTkFrame(
                meter_bg,
                fg_color=self.colors["accent_primary"],
                height=30,
                width=1,
                corner_radius=5
            )
            level_indicator.place(x=0, y=0)

            level_text = ctk.CTkLabel(
                meter_bg,
                text="0%",
                font=ctk.CTkFont(size=12, weight="bold"),
                text_color=self.colors["text_bright"]
            )
            level_text.place(relx=0.5, rely=0.5, anchor="center")

            # Button frame
            button_frame = ctk.CTkFrame(dialog, fg_color="transparent")
            button_frame.pack(fill="x", padx=20, pady=(15, 20))

            # Cancel button
            cancel_button = ctk.CTkButton(
                button_frame,
                text="Cancel",
                command=dialog.destroy,
                fg_color=self.colors["bg_light"],
                hover_color=self.colors["bg_medium"],
                text_color=self.colors["text_normal"],
                width=100
            )
            cancel_button.pack(side="left", padx=(0, 10))

            # Close button (initially disabled)
            close_button = ctk.CTkButton(
                button_frame,
                text="Close",
                command=dialog.destroy,
                state="disabled",
                fg_color=self.colors["accent_primary"],
                hover_color=self.colors["accent_secondary"],
                width=100
            )
            close_button.pack(side="right")

            # Get device info
            try:
                device_info = sd.query_devices(device_id)
                samplerate = int(device_info['default_samplerate'])

                # Show device info in status
                status_label.configure(
                    text=f"Testing: {device_info['name']}\nPlease speak now to test your microphone.")
            except Exception as e:
                status_label.configure(
                    text=f"Error: {str(e)}\nCould not initialize the selected microphone.")
                close_button.configure(state="normal")
                return

            # Duration of recording
            duration = 5  # seconds

            # Function to update progress
            def update_progress(current, total):
                progress.set(current / total)
                progress_label.configure(
                    text=f"Progress: {int(current/total*100)}%")
                dialog.update()

            # Function to update level indicator
            def update_level(volume):
                # Scale volume (0-1) to width
                width = min(360, int(volume * 360))
                level_indicator.configure(width=width)

                # Update color based on level
                if volume < 0.3:
                    level_indicator.configure(
                        fg_color=self.colors["status_green"])
                elif volume < 0.7:
                    level_indicator.configure(
                        fg_color=self.colors["status_yellow"])
                else:
                    level_indicator.configure(
                        fg_color=self.colors["status_red"])

                # Update text
                level_text.configure(text=f"{int(volume * 100)}%")
                dialog.update()

            # Function to record audio
            def record_audio():
                status_label.configure(
                    text=f"Recording from: {device_info['name']}\nPlease speak now...")

                # Create array to store audio data
                audio_data = []

                # Start time
                start_time = time.time()

                # Callback function for audio stream
                def audio_callback(indata, frames, time_info, status):
                    if status:
                        logging.warning(f"Audio status: {status}")

                    # Copy audio data
                    audio_data.append(indata.copy())

                    # Calculate volume level (RMS)
                    volume = np.sqrt(np.mean(indata**2))

                    # Apply gain if available
                    if hasattr(self, 'gain_var'):
                        volume *= self.gain_var.get()

                    # Update level indicator
                    dialog.after(0, lambda: update_level(min(1.0, volume * 2)))

                    # Update progress
                    elapsed = time.time() - start_time
                    if elapsed < duration:
                        dialog.after(
                            0, lambda: update_progress(
                                elapsed, duration))

                # Start audio stream
                try:
                    with sd.InputStream(
                        device=device_id,
                        channels=1,
                        callback=audio_callback,
                        samplerate=samplerate,
                        blocksize=int(samplerate * 0.1)  # 100ms blocks
                    ):
                        # Wait for duration
                        sd.sleep(int(duration * 1000))
                except Exception as e:
                    error_msg = f"Error recording: {str(e)}"
                    logging.error(error_msg)
                    status_label.configure(text=error_msg)
                    close_button.configure(state="normal")
                    return None

                # Combine all audio chunks
                if audio_data:
                    return np.concatenate(audio_data)
                return None

            # Function to play audio
            def play_audio(audio_data):
                status_label.configure(text="Playing back recording...")
                progress.set(0)

                try:
                    # Start time
                    start_time = time.time()

                    # Play audio
                    sd.play(audio_data, samplerate)

                    # Update progress during playback
                    def update_playback_progress():
                        elapsed = time.time() - start_time
                        if elapsed < duration and not dialog.winfo_exists():
                            return

                        if elapsed < duration:
                            update_progress(elapsed, duration)
                            dialog.after(100, update_playback_progress)
                        else:
                            progress.set(1.0)
                
                    # Start the progress update
                    update_playback_progress()
                except Exception as e:
                    logging.error(f"Error playing audio: {str(e)}")
                    status_label.configure(text=f"Error playing audio: {str(e)}")


class DragonVoiceGUI:
    """
    Main GUI class for the Dragon Voice Project

    Provides a modern, feature-rich interface for controlling the voice assistant,
    managing chatbots, and configuring system settings.
    """

    def __init__(self, config_path=DEFAULT_CONFIG_PATH):
        """Initialize the DragonVoice GUI application"""
        logging.info("Initializing DragonVoiceGUI")
        logging.info("Initializing DragonVoice GUI")

        try:
            # Initialize logging
            self.setup_logging()

            # Initialize state variables
            self.recording_active = False
            self.continuous_recording = False  # Flag for continuous recording
            self.is_fullscreen = False

            # Create main application window
            self.app = ctk.CTk()
            self.app.title("DragonVoice")
            self.app.geometry("1200x800")
            self.app.minsize(900, 600)
            
            # Center window on screen
            screen_width = self.app.winfo_screenwidth()
            screen_height = self.app.winfo_screenheight()
            x = (screen_width - 1200) // 2
            y = (screen_height - 800) // 2
            self.app.geometry(f"1200x800+{x}+{y}")

            # Load configuration
            self.config_path = config_path
            self.config = self.load_config()
            logging.info(f"Configuration loaded from {config_path}")

            # Set up theme and colors
            self.setup_theme()

            # Initialize Whisper recognizer
            self.init_whisper_recognizer()

            # Set up UI components
            self.setup_ui()

            # Start system monitoring
            self.start_system_monitoring()

        except Exception as e:
            logging.error(f"Error initializing DragonVoiceGUI: {str(e)}")
            raise

    def setup_logging(self):
        """Set up logging configuration"""
        # Check if logging is already configured
        if not logging.getLogger().handlers:
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - %(message)s'
            )
        logging.info("Logging setup complete")

    def setup_theme(self):
        """Set up the theme and colors for the application"""
        # Set appearance mode
        ctk.set_appearance_mode("dark")

        # Define color schemes
        self.color_schemes = {
            "dark": {
                "bg_dark": "#1A1A2E",
                "bg_medium": "#16213E",
                "bg_light": "#0F3460",
                "accent_primary": "#E94560",
                "accent_secondary": "#0F52BA",
                "text_bright": "#FFFFFF",
                "text_normal": "#E0E0E0",
                "text_dim": "#A0A0A0",
                "status_green": "#4CAF50",
                "status_yellow": "#FFC107",
                "status_red": "#F44336",
                "status_blue": "#2196F3",
                "status_gray": "#757575"
            },
            "light": {
                "bg_dark": "#F0F0F0",
                "bg_medium": "#E0E0E0",
                "bg_light": "#D0D0D0",
                "accent_primary": "#E94560",
                "accent_secondary": "#0F52BA",
                "text_bright": "#000000",
                "text_normal": "#202020",
                "text_dim": "#505050",
                "status_green": "#4CAF50",
                "status_yellow": "#FFC107",
                "status_red": "#F44336",
                "status_blue": "#2196F3",
                "status_gray": "#757575"
            },
            "dragon": {
                "bg_dark": "#0A1931",
                "bg_medium": "#150E56",
                "bg_light": "#1A1A40",
                "accent_primary": "#D82148",
                "accent_secondary": "#6EBF8B",
                "text_bright": "#FFFFFF",
                "text_normal": "#E0E0E0",
                "text_dim": "#A0A0A0",
                "status_green": "#4CAF50",
                "status_yellow": "#FFC107",
                "status_red": "#F44336",
                "status_blue": "#2196F3",
                "status_gray": "#757575"
            }
        }

        # Set default color scheme
        self.colors = self.color_schemes["dragon"]

        # Define fonts
        self.fonts = {
            "header": ctk.CTkFont(family="Segoe UI", size=28, weight="bold"),
            "title": ctk.CTkFont(family="Segoe UI", size=20, weight="bold"),
            "subtitle": ctk.CTkFont(family="Segoe UI", size=16, weight="bold"),
            "normal": ctk.CTkFont(family="Segoe UI", size=14),
            "small": ctk.CTkFont(family="Segoe UI", size=12),
            "tiny": ctk.CTkFont(family="Segoe UI", size=10),
            "mono": ctk.CTkFont(family="Consolas", size=12),
            # Added the 'large' font definition
            "large": ctk.CTkFont(family="Segoe UI", size=18)
        }

    def init_whisper_recognizer(self):
        """Initialize the Whisper recognizer"""
        try:
            # Initialize API keys with default values
            self.openai_api_key = "j3ydNXEmQFyDKwl5mWxSzcvdZcTLJw1t"
            self.base_url = "https://api.deepinfra.com/v1/openai"
            
            # Initialize WhisperRecognizer with error handling
            if self.openai_api_key:
                self.whisper_recognizer = WhisperRecognizer(
                    api_key=self.openai_api_key,
                    base_url=self.base_url
                )
                # Initialize recording state
                self.recording_active = False
                self.continuous_recording = False
                self.audio_data = []
                logging.info("WhisperRecognizer initialized successfully")
            else:
                logging.warning("No OpenAI API key found, WhisperRecognizer not initialized")
                self.whisper_recognizer = None
        except Exception as e:
            logging.error(f"Failed to initialize WhisperRecognizer: {str(e)}")
            self.whisper_recognizer = None

    def setup_ui(self):
        """Set up the main UI components"""
        try:
            # Create the main container
            self.main_container = ctk.CTkFrame(
                self.app, fg_color="transparent")
            self.main_container.pack(fill="both", expand=True)

            # Create UI components in the correct order
            self.create_footer()  # Create footer first to ensure status_label exists
            self.create_header()
            self.create_tabs()

            # Start system monitoring
            self.start_system_monitoring()

            # Update status
            self.update_status("Application initialized successfully")

            # Log successful UI setup
            logging.info("UI setup completed successfully")

        except Exception as e:
            logging.error(f"Error setting up UI: {str(e)}", exc_info=True)
            # Show error in a messagebox if possible
            try:
                import tkinter.messagebox as messagebox
                messagebox.showerror(
                    "UI Setup Error",
                    f"Error setting up UI:\n{str(e)}")
            except BaseException:
                pass

    def create_header(self):
        """Create a modern application header with logo and controls"""
        # Create header frame with gradient background
        self.header_frame = ctk.CTkFrame(
            self.main_container,
            fg_color=self.colors["bg_dark"],
            corner_radius=0,
            height=90
        )
        self.header_frame.pack(fill="x", pady=0)
        self.header_frame.pack_propagate(False)

        # Create gradient effect for header
        self.header_canvas = ctk.CTkCanvas(
            self.header_frame,
            bg=self.colors["bg_dark"],
            highlightthickness=0,
            height=90
        )
        self.header_canvas.pack(fill="x", side="top")

        # Draw gradient
        def draw_gradient():
            width = self.header_canvas.winfo_width()
            if width <= 1:  # Not yet properly initialized
                self.app.after(100, draw_gradient)
                return

            height = 90
            # Create a more sophisticated gradient
            for i in range(width):
                # Calculate gradient position (0 to 1)
                pos = i / width

                # Create a gradient with accent color highlights
                if pos < 0.2:  # First section - dark to medium with accent hint
                    ratio = pos / 0.2
                    r1, g1, b1 = self.hex_to_rgb(self.colors["bg_dark"])
                    r2, g2, b2 = self.hex_to_rgb(self.colors["bg_medium"])
                    r3, g3, b3 = self.hex_to_rgb(self.colors["accent_primary"])

                    # Mix colors with a hint of accent
                    r = r1 + (r2 - r1) * ratio + (r3 - r1) * ratio * 0.1
                    g = g1 + (g2 - g1) * ratio + (g3 - g1) * ratio * 0.1
                    b = b1 + (b2 - b1) * ratio + (b3 - b1) * ratio * 0.1
                elif pos < 0.8:  # Middle section - medium to medium with subtle variation
                    ratio = (pos - 0.2) / 0.6
                    r1, g1, b1 = self.hex_to_rgb(self.colors["bg_medium"])
                    r2, g2, b2 = self.hex_to_rgb(
                        self._adjust_color_brightness(
                            self.colors["bg_medium"], 1.1))

                    r = r1 + (r2 - r1) * ratio
                    g = g1 + (g2 - g1) * ratio
                    b = b1 + (b2 - b1) * ratio
                else:  # Last section - medium to dark with accent hint
                    ratio = (pos - 0.8) / 0.2
                    r1, g1, b1 = self.hex_to_rgb(self.colors["bg_medium"])
                    r2, g2, b2 = self.hex_to_rgb(self.colors["bg_dark"])
                    r3, g3, b3 = self.hex_to_rgb(
                        self.colors["accent_secondary"])

                    # Mix colors with a hint of accent
                    r = r1 + (r2 - r1) * ratio + (r3 - r1) * ratio * 0.1
                    g = g1 + (g2 - g1) * ratio + (g3 - g1) * ratio * 0.1
                    b = b1 + (b2 - b1) * ratio + (b3 - b1) * ratio * 0.1

                color = f'#{int(r):02x}{int(g):02x}{int(b):02x}'
                self.header_canvas.create_line(i, 0, i, height, fill=color)

            # Add accent line at bottom with glow effect
            for i in range(3):
                alpha = 0.3 + (0.7 * (i / 2))  # Increasing opacity
                glow_color = self._adjust_color_brightness(
                    self.colors["accent_primary"], alpha)
            self.header_canvas.create_line(
                0, height - 3 + i, width, height - 3 + i,
                fill=glow_color,
                width=1
            )

        # Schedule gradient drawing
        self.app.after(100, draw_gradient)

        # Create a container for the header content
        header_content = ctk.CTkFrame(
            self.header_frame, fg_color="transparent")
        header_content.place(
            relx=0.5,
            rely=0.5,
            anchor="center",
            relwidth=1,
            relheight=0.8)

        # Left side - Logo and title
        logo_frame = ctk.CTkFrame(header_content, fg_color="transparent")
        logo_frame.pack(side="left", padx=(30, 0))

        # Try to load logo image if available
        try:
            logo_path = os.path.join("src", "assets", "dragon_logo.png")
            if os.path.exists(logo_path):
                logo_image = ctk.CTkImage(
                    light_image=Image.open(logo_path),
                    dark_image=Image.open(logo_path),
                    size=(40, 40)
                )
                logo_label = ctk.CTkLabel(
                    logo_frame,
                    image=logo_image,
                    text=""
                )
                logo_label.pack(side="left", padx=(0, 15))
        except Exception as e:
            logging.error(f"Failed to load logo: {str(e)}")

        # App title with modern styling
        title_label = ctk.CTkLabel(
            logo_frame,
            text="DragonVoice",
            font=self.fonts["header"],
            text_color=self.colors["text_bright"]
        )
        title_label.pack(side="left")

        # Version with pill background
        version_pill = ctk.CTkFrame(
            logo_frame,
            fg_color=self.colors["accent_primary"],
            corner_radius=12,
            height=24
        )
        version_pill.pack(side="left", padx=(10, 0), pady=(8, 0))

        version_label = ctk.CTkLabel(
            version_pill,
            text="v2.0",
            font=self.fonts["small"],
            text_color=self.colors["text_bright"]
        )
        version_label.pack(padx=10, pady=2)

        # Center - Status indicator
        status_frame = ctk.CTkFrame(header_content, fg_color="transparent")
        status_frame.pack(side="left", expand=True)

        # Right side - Controls
        controls_frame = ctk.CTkFrame(header_content, fg_color="transparent")
        controls_frame.pack(side="right", padx=(0, 30))

        # Microphone selector with improved styling
        mic_frame = ctk.CTkFrame(
            controls_frame,
            fg_color=self.colors["bg_light"],
            corner_radius=8
        )
        mic_frame.pack(side="left", padx=(0, 15), pady=5)

        mic_label = ctk.CTkLabel(
            mic_frame,
            text="Microphone:",
            font=self.fonts["small"],
            text_color=self.colors["text_normal"]
        )
        mic_label.pack(side="left", padx=(10, 5), pady=5)

        # Microphone dropdown
        self.mic_var = ctk.StringVar(value="Default Microphone")
        self.mic_dropdown = ctk.CTkOptionMenu(
            mic_frame,
            values=["Default Microphone"],
            variable=self.mic_var,
            width=150,
            dynamic_resizing=True,
            fg_color=self.colors["bg_medium"],
            button_color=self.colors["accent_primary"],
            button_hover_color=self.colors["accent_secondary"],
            dropdown_fg_color=self.colors["bg_medium"]
        )
        self.mic_dropdown.pack(side="left", padx=(0, 10), pady=5)

        # Theme toggle button
        theme_button = ctk.CTkButton(
            controls_frame,
            text="",
            width=36,
            height=36,
            corner_radius=10,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            text_color=self.colors["text_bright"],
            command=self.toggle_theme
        )
        theme_button.pack(side="left", padx=(0, 10))

        # Settings button
        settings_button = ctk.CTkButton(
            controls_frame,
            text="Settings",
            width=100,
            height=36,
            corner_radius=10,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            text_color=self.colors["text_bright"],
            command=self.show_settings
        )
        settings_button.pack(side="left", padx=(0, 10))

        # Help button
        help_button = ctk.CTkButton(
            controls_frame,
            text="Help",
            width=80,
            height=36,
            corner_radius=10,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            text_color=self.colors["text_bright"],
            command=self.show_help
        )
        help_button.pack(side="left")

        # Refresh microphone list
        self.refresh_mic_list()

    def hex_to_rgb(self, hex_color):
        """Convert hex color to RGB tuple"""
        hex_color = hex_color.lstrip('#')
        return tuple(int(hex_color[i:i + 2], 16) for i in (0, 2, 4))

    def show_settings(self):
        """Show the settings dialog"""
        # Switch to the Configuration tab
        self.tab_view.set("Configuration")

    def show_help(self):
        """Show the help dialog"""
        # Create a new top-level window
        help_window = ctk.CTkToplevel(self.app)
        help_window.title("DragonVoice Help")
        help_window.geometry("800x600")
        help_window.minsize(800, 600)
        help_window.grab_set()  # Make window modal

        # Set window icon
        if platform.system() == "Windows":
            try:
                icon_path = os.path.join(
                    os.path.dirname(
                        os.path.abspath(__file__)),
                    "assets",
                    "dragon_icon.ico")
                if os.path.exists(icon_path):
                    help_window.iconbitmap(icon_path)
            except Exception as e:
                print(f"Could not set help window icon: {e}")

        # Create tab view for help content
        help_tabs = ctk.CTkTabview(
            help_window,
            fg_color=self.colors["bg_dark"],
            segmented_button_fg_color=self.colors["bg_medium"],
            segmented_button_selected_color=self.colors["accent_primary"],
            segmented_button_selected_hover_color=self.colors["accent_secondary"],
            segmented_button_unselected_color=self.colors["bg_medium"],
            segmented_button_unselected_hover_color=self.colors["bg_light"])
        help_tabs.pack(fill="both", expand=True, padx=20, pady=20)

        # Add tabs
        help_tabs.add("Getting Started")
        help_tabs.add("Voice Commands")
        help_tabs.add("Chatbots")
        help_tabs.add("Troubleshooting")
        help_tabs.add("About")

        # Create content for each tab
        self.create_help_getting_started(help_tabs.tab("Getting Started"))
        self.create_help_voice_commands(help_tabs.tab("Voice Commands"))
        self.create_help_chatbots(help_tabs.tab("Chatbots"))
        self.create_help_troubleshooting(help_tabs.tab("Troubleshooting"))
        self.create_help_about(help_tabs.tab("About"))

        # Add close button at bottom
        button_frame = ctk.CTkFrame(help_window, fg_color="transparent")
        button_frame.pack(fill="x", padx=20, pady=(0, 20))

        close_button = ctk.CTkButton(
            button_frame,
            text="Close",
            command=help_window.destroy,
            width=100,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        close_button.pack(side="right")

    def create_footer(self):
        """Create the footer with status information"""
        # Create footer container
        self.footer = ctk.CTkFrame(
            self.app,
            fg_color=self.colors["bg_dark"],
            height=30
        )
        self.footer.pack(fill="x", side="bottom")
        self.footer.pack_propagate(False)

        # Create canvas for gradient background
        footer_canvas = ctk.CTkCanvas(
            self.footer,
            bg=self.colors["bg_dark"],
            highlightthickness=0,
            height=30
        )
        footer_canvas.pack(fill="x")

        # Draw gradient
        def draw_gradient():
            width = footer_canvas.winfo_width()
            if width <= 1:  # Not properly rendered yet
                self.app.after(100, draw_gradient)
                return

            height = 30
            # Create gradient from dark to slightly lighter
            for i in range(height):
                # Calculate color based on position
                r, g, b = self.hex_to_rgb(self.colors["bg_dark"])
                factor = i / height * 0.2  # Subtle gradient
                r = min(255, int(r + (255 - r) * factor))
                g = min(255, int(g + (255 - g) * factor))
                b = min(255, int(b + (255 - b) * factor))
                color = f'#{r:02x}{g:02x}{b:02x}'

                # Draw line
                footer_canvas.create_line(0, i, width, i, fill=color)

        # Schedule gradient drawing after the window is rendered
        self.app.after(100, draw_gradient)

        # Status label
        self.status_label = ctk.CTkLabel(
            footer_canvas,
            text="Ready",
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        self.status_label.place(relx=0.01, rely=0.5, anchor="w")

        # Version label
        version_label = ctk.CTkLabel(
            footer_canvas,
            text="DragonVoice v2.0",
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        version_label.place(relx=0.99, rely=0.5, anchor="e")

        # Log successful creation
        logging.info(
            "Footer created successfully with status_label initialized")

    def create_tabs(self):
        """Create the main tab view and tabs"""
        # Create the main tab container
        self.tab_container = ctk.CTkFrame(self.app, fg_color="transparent")
        self.tab_container.pack(
            fill="both",
            expand=True,
            padx=20,
            pady=(
                0,
                20))

        # Create the tab view
        self.tab_view = ctk.CTkTabview(
            self.tab_container,
            fg_color=self.colors["bg_dark"],
            segmented_button_fg_color=self.colors["bg_medium"],
            segmented_button_selected_color=self.colors["accent_primary"],
            segmented_button_selected_hover_color=self.colors["accent_secondary"],
            segmented_button_unselected_color=self.colors["bg_medium"],
            segmented_button_unselected_hover_color=self.colors["bg_light"])
        self.tab_view.pack(fill="both", expand=True)

        # Add tabs
        self.tab_view.add("Dashboard")
        self.tab_view.add("Chatbots")
        self.tab_view.add("History")
        self.tab_view.add("Configuration")
        self.tab_view.add("About")

        # Set default tab
        self.tab_view.set("Dashboard")

        # Create tab contents
        self.create_dashboard_tab()
        self.create_chatbots_tab()
        self.create_history_tab()
        self.create_config_tab()
        self.create_about_tab()

    def create_dashboard_tab(self):
        """Create the dashboard tab content"""
        # Main container with gradient background
        dashboard_container = ctk.CTkScrollableFrame(
            self.tab_view.tab("Dashboard"),
            fg_color="transparent"
        )
        dashboard_container.pack(fill="both", expand=True, padx=20, pady=0)  # Reduced top padding

        # Create a grid layout for dashboard widgets
        dashboard_container.columnconfigure(0, weight=2)
        dashboard_container.columnconfigure(1, weight=1)
        dashboard_container.rowconfigure(0, weight=1)
        dashboard_container.rowconfigure(1, weight=1)
        dashboard_container.rowconfigure(2, weight=1)

        # Status panel (top left)
        status_panel = self.create_status_panel(dashboard_container)
        status_panel.grid(row=0, column=0, sticky="nsew", padx=(0, 10), pady=(0, 10))

        # Voice assistant control panel (top right)
        control_panel = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=15,
            border_width=1,
            border_color=self.colors["bg_light"]
        )
        control_panel.grid(row=0, column=1, sticky="nsew", padx=(10, 0), pady=(0, 10))

        # Control panel header with icon
        control_header = ctk.CTkFrame(control_panel, fg_color="transparent", height=50)
        control_header.pack(fill="x", padx=20, pady=(15, 5))

        # Control panel title with icon
        control_title = ctk.CTkLabel(
            control_header,
            text="Voice Assistant",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        control_title.pack(side="left")

        # Start/Stop button with improved styling
        self.toggle_button = ctk.CTkButton(
            control_panel,
            text="Start Voice Assistant",
            command=self.toggle_voice_assistant,
            fg_color=self.colors["status_green"],
            hover_color=self._adjust_color_brightness(self.colors["status_green"], 0.8),
            height=60,
            corner_radius=10,
            font=self.fonts["subtitle"],
            border_width=1,
            border_color=self._adjust_color_brightness(self.colors["status_green"], 1.2)
        )
        self.toggle_button.pack(fill="x", padx=20, pady=15)
        
        # Recording buttons container
        recording_buttons_frame = ctk.CTkFrame(control_panel, fg_color="transparent")
        recording_buttons_frame.pack(fill="x", padx=20, pady=10)

        # Record button
        self.record_button = ctk.CTkButton(
            recording_buttons_frame,
            text="Record",
            command=self.start_manual_recording,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            height=40,
            width=150,
            corner_radius=10
        )
        self.record_button.pack(side="left", fill="x", expand=True, padx=(0, 5))

        # Stop Recording button
        self.stop_record_button = ctk.CTkButton(
            recording_buttons_frame,
            text="Stop Recording",
            command=self.stop_manual_recording,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            height=40,
            width=150,
            corner_radius=10,
            state="disabled"
        )
        self.stop_record_button.pack(side="right", fill="x", expand=True, padx=(5, 0))

        # Add synthesizer bar to show voice detection
        self.synth_bar = SynthesizerBar(control_panel, self.colors, self.fonts)

        # Microphone sensitivity slider
        sensitivity_frame = ctk.CTkFrame(
            control_panel,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        sensitivity_frame.pack(fill="x", padx=20, pady=10)

        sensitivity_label = ctk.CTkLabel(
            sensitivity_frame,
            text="Microphone Sensitivity",
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"]
        )
        sensitivity_label.pack(anchor="w", padx=15, pady=(10, 5))

        sensitivity_control = ctk.CTkFrame(sensitivity_frame, fg_color="transparent")
        sensitivity_control.pack(fill="x", padx=15, pady=(0, 10))

        self.sensitivity_var = ctk.DoubleVar(value=0.5)
        self.sensitivity_slider = ctk.CTkSlider(
            sensitivity_control,
            from_=0.1,
            to=1.0,
            variable=self.sensitivity_var,
            width=200,
            progress_color=self.colors["accent_primary"],
            button_color=self.colors["accent_secondary"],
            button_hover_color=self.colors["accent_primary"]
        )
        self.sensitivity_slider.pack(side="left", fill="x", expand=True, padx=(0, 10))

        self.sensitivity_value = ctk.CTkLabel(
            sensitivity_control,
            text=f"{int(self.sensitivity_var.get() * 100)}%",
            font=self.fonts["small"],
            width=40,
            text_color=self.colors["text_dim"]
        )
        self.sensitivity_value.pack(side="right")

        # Update sensitivity value when slider changes
        def update_sensitivity(*args):
            self.sensitivity_value.configure(text=f"{int(self.sensitivity_var.get() * 100)}%")
            if hasattr(self, 'gain_var'):
                self.gain_var.set(self.sensitivity_var.get())

        self.sensitivity_var.trace_add("write", update_sensitivity)
        
        # Initialize gain variable for level meter
        self.gain_var = ctk.DoubleVar(value=self.sensitivity_var.get())

        # Status indicator with improved styling
        status_frame = ctk.CTkFrame(
            control_panel,
            fg_color=self.colors["bg_light"],
            corner_radius=10,
            height=50
        )
        status_frame.pack(fill="x", padx=20, pady=10)
        status_frame.pack_propagate(False)

        status_label = ctk.CTkLabel(
            status_frame,
            text="Status: Idle",
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"]
        )
        status_label.pack(side="left", padx=15, pady=10)

        self.status_indicator = ctk.CTkFrame(
            status_frame,
            fg_color=self.colors["status_gray"],
            width=20,
            height=20,
            corner_radius=10
        )
        self.status_indicator.pack(side="right", padx=15)

        # Transcription section (middle)
        transcription_frame = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=15,
            border_width=1,
            border_color=self.colors["bg_light"]
        )
        transcription_frame.grid(row=1, column=0, columnspan=2, sticky="nsew", pady=(0, 10))
            
        # Transcription header
        transcription_header = ctk.CTkFrame(transcription_frame, fg_color="transparent", height=50)
        transcription_header.pack(fill="x", padx=20, pady=(15, 5))
        
        transcription_title = ctk.CTkLabel(
            transcription_header,
            text="📝 Transcription",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        transcription_title.pack(side="left")
        
        # Controls frame
        controls = ctk.CTkFrame(transcription_header, fg_color="transparent")
        controls.pack(side="right")
        
        # Clear button
        clear_button = ctk.CTkButton(
            controls,
            text="Clear",
            command=lambda: self.clear_transcription(),
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            width=80
        )
        clear_button.pack(side="right", padx=(0, 10))
        
        # Enter button
        self.enter_button = ctk.CTkButton(
            controls,
            text="Enter",
            command=self.process_transcription,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            width=100,
            state="disabled"
        )
        self.enter_button.pack(side="right")
        
        # Transcription display
        self.transcription_display = ctk.CTkTextbox(
            transcription_frame,
            fg_color=self.colors["bg_light"],
            text_color=self.colors["text_bright"],
            font=self.fonts["large"],
            corner_radius=10,
            border_width=1,
            border_color=self.colors["bg_light"],
            height=150
        )
        self.transcription_display.pack(fill="both", expand=True, padx=20, pady=(5, 20))
        
        # Configure text tags
        self.transcription_display._textbox.tag_configure("timestamp", foreground=self.colors["accent_secondary"])
        self.transcription_display._textbox.tag_configure("transcription", foreground=self.colors["text_bright"])
        
        # Add initial message
        self.transcription_display.configure(state="normal")
        self.transcription_display.insert("end", "Transcribed text will appear here...")
        self.transcription_display.configure(state="disabled")

        # Voice commands section (bottom)
        text_display_frame = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=15,
            border_width=1,
            border_color=self.colors["bg_light"]
        )
        text_display_frame.grid(row=2, column=0, columnspan=2, sticky="nsew")
                
        # Text display header
        text_header = ctk.CTkFrame(text_display_frame, fg_color="transparent", height=50)
        text_header.pack(fill="x", padx=20, pady=(15, 5))
        
        text_title = ctk.CTkLabel(
            text_header,
            text="🔊 Voice Commands",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        text_title.pack(side="left")
        
        # Clear button for text display
        clear_text_button = ctk.CTkButton(
            text_header,
            text="Clear",
            command=lambda: self.clear_text_display(),
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            width=80
        )
        clear_text_button.pack(side="right")
        
        # Text display area
        self.text_display = ctk.CTkTextbox(
            text_display_frame,
            fg_color=self.colors["bg_light"],
            text_color=self.colors["text_bright"],
            font=self.fonts["large"],
            corner_radius=10,
            border_width=1,
            border_color=self.colors["bg_light"],
            height=200
        )
        self.text_display.pack(fill="both", expand=True, padx=20, pady=(5, 20))
        
        # Configure text tags
        self.text_display._textbox.tag_configure("timestamp", foreground=self.colors["accent_secondary"])
        self.text_display._textbox.tag_configure("command", foreground=self.colors["accent_primary"])
        self.text_display._textbox.tag_configure("system", foreground=self.colors["status_blue"])
        
        # Add initial message
        self.text_display.configure(state="normal")
        self.text_display.insert("end", "Voice commands will appear here after starting the voice assistant...")
        self.text_display.configure(state="disabled")

        # Initialize monitor visualization
        self.app.after(500, self.refresh_monitor_visualization)

    def create_synthesizer_bar(self, parent):
        """Create a synthesizer bar to visualize voice detection"""
        # Use the new SynthesizerBar class if available
        try:
            from synthesizer_bar import SynthesizerBar
            self.synth_bar = SynthesizerBar(parent, self.colors, self.fonts)
            return
        except ImportError:
            logging.warning(
                "SynthesizerBar class not found, using fallback implementation")

        # Fallback implementation
        synth_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10,
            height=80
        )
        synth_frame.pack(fill="x", padx=20, pady=10)

        # Synthesizer label
        synth_label = ctk.CTkLabel(
            synth_frame,
            text="Voice Detection",
            font=self.fonts["normal"],
            text_color=self.colors["text_bright"]
        )
        synth_label.pack(anchor="w", padx=15, pady=(10, 5))

        # Create level meter canvas
        self.level_canvas = ctk.CTkCanvas(
            synth_frame,
            bg=self.colors["bg_dark"],
            highlightthickness=0,
            height=30
        )
        self.level_canvas.pack(fill="x", padx=15, pady=(0, 10))

        # Initialize level meter with zero level
        self.app.after(100, lambda: self._update_level_meter(0))

    def create_chatbots_tab(self):
        """Create the chatbots tab content"""
        # Main container
        chatbots_container = ctk.CTkFrame(
            self.tab_view.tab("Chatbots"),
            fg_color="transparent"
        )
        chatbots_container.pack(fill="both", expand=True, padx=20, pady=20)

        # Title and add button row
        title_frame = ctk.CTkFrame(chatbots_container, fg_color="transparent")
        title_frame.pack(fill="x", pady=(0, 15))

        # Title with icon
        title_label = ctk.CTkLabel(
            title_frame,
            text="Chatbot Management",
            font=ctk.CTkFont(size=24, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title_label.pack(side="left")

        # Add chatbot button
        add_button = ctk.CTkButton(
            title_frame,
            text="Add New Chatbot",
            command=self.show_add_chatbot_dialog,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            width=120
        )
        add_button.pack(side="right")

        # Search frame
        search_frame = ctk.CTkFrame(
            chatbots_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=10,
            height=50
        )
        search_frame.pack(fill="x", pady=(0, 15))
        search_frame.pack_propagate(False)

        # Search icon
        search_icon = ctk.CTkLabel(
            search_frame,
            text="🔍",
            font=ctk.CTkFont(size=16),
            width=30
        )
        search_icon.pack(side="left", padx=(15, 0))

        # Search entry
        self.search_var = ctk.StringVar()
        self.search_var.trace_add(
            "write", lambda *args: self.filter_chatbot_list())
        search_entry = ctk.CTkEntry(
            search_frame,
            placeholder_text="Search chatbots...",
            textvariable=self.search_var,
            border_width=0,
            fg_color="transparent",
            height=40
        )
        search_entry.pack(side="left", fill="x", expand=True, padx=10)

        # Chatbot list container
        self.chatbot_list_frame = ctk.CTkScrollableFrame(
            chatbots_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        self.chatbot_list_frame.pack(fill="both", expand=True)

        # Refresh chatbot list
        self.refresh_chatbots()

    def create_about_tab(self):
        """Create the about tab content"""
        # Main container
        about_container = ctk.CTkFrame(
            self.tab_view.tab("About"),
            fg_color="transparent"
        )
        about_container.pack(fill="both", expand=True, padx=20, pady=20)

        # Create a scrollable frame for the about content
        about_scroll = ctk.CTkScrollableFrame(
            about_container,
            fg_color="transparent"
        )
        about_scroll.pack(fill="both", expand=True)

        # Logo and title
        logo_frame = ctk.CTkFrame(about_scroll, fg_color="transparent")
        logo_frame.pack(fill="x", pady=(0, 20))

        # App title
        title_label = ctk.CTkLabel(
            logo_frame,
            text="DragonVoice",
            font=ctk.CTkFont(size=32, weight="bold"),
            text_color=self.colors["accent_primary"]
        )
        title_label.pack(pady=(0, 5))

        # Version
        version_label = ctk.CTkLabel(
            logo_frame,
            text="Version 2.0",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"]
        )
        version_label.pack()

        # Description
        description_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        description_frame.pack(fill="x", pady=10, padx=5)

        description_label = ctk.CTkLabel(
            description_frame,
            text="DragonVoice is an advanced voice assistant that integrates with multiple AI chatbots.\n"
            "It provides a seamless voice interface for interacting with AI models and controlling your computer.",
            font=ctk.CTkFont(
                size=14),
            text_color=self.colors["text_normal"],
            wraplength=600,
            justify="left")
        description_label.pack(padx=20, pady=20)

        # Features
        features_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        features_frame.pack(fill="x", pady=10, padx=5)

        features_title = ctk.CTkLabel(
            features_frame,
            text="Key Features",
            font=ctk.CTkFont(size=18, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        features_title.pack(anchor="w", padx=20, pady=(15, 10))

        features = [
            "🎤 Voice recognition with OpenAI Whisper",
            "🤖 Multiple AI chatbot integrations",
            "⌨️ System control through voice commands",
            "📊 Real-time system monitoring",
            "🎨 Customizable themes and appearance",
            "🔧 Advanced configuration options"
        ]

        for feature in features:
            feature_label = ctk.CTkLabel(
                features_frame,
                text=feature,
                font=ctk.CTkFont(size=14),
                text_color=self.colors["text_normal"],
                anchor="w"
            )
            feature_label.pack(anchor="w", padx=20, pady=5)

        # Credits
        credits_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        credits_frame.pack(fill="x", pady=10, padx=5)

        credits_title = ctk.CTkLabel(
            credits_frame,
            text="Credits",
            font=ctk.CTkFont(size=18, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        credits_title.pack(anchor="w", padx=20, pady=(15, 10))

        credits_label = ctk.CTkLabel(
            credits_frame,
            text="Developed by: DragonVoice Team\n"
                 "UI Framework: CustomTkinter\n"
                 "Voice Recognition: OpenAI Whisper\n"
                 "Special thanks to all contributors and testers",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            justify="left"
        )
        credits_label.pack(anchor="w", padx=20, pady=(0, 15))

        # Links
        links_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        links_frame.pack(fill="x", pady=10, padx=5)

        links_title = ctk.CTkLabel(
            links_frame,
            text="Links",
            font=ctk.CTkFont(size=18, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        links_title.pack(anchor="w", padx=20, pady=(15, 10))

        # Function to open links
        def open_link(url):
            import webbrowser
            webbrowser.open(url)

        # Website link
        website_button = ctk.CTkButton(
            links_frame,
            text="Visit Website",
            command=lambda: open_link("https://dragonvoice.ai"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        website_button.pack(anchor="w", padx=20, pady=5)

        # Documentation link
        docs_button = ctk.CTkButton(
            links_frame,
            text="Documentation",
            command=lambda: open_link("https://docs.dragonvoice.ai"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        docs_button.pack(anchor="w", padx=20, pady=5)

        # GitHub link
        github_button = ctk.CTkButton(
            links_frame,
            text="GitHub Repository",
            command=lambda: open_link("https://github.com/dragonvoice/dragonvoice"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"])
        github_button.pack(anchor="w", padx=20, pady=(5, 15))

    def create_settings_advanced_tab(self, parent):
        """Create the advanced settings tab content"""
        # Main container
        container = ctk.CTkFrame(parent, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)

        # Logging settings section
        logging_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        logging_frame.pack(fill="x", pady=(0, 15))

        # Section title
        logging_title = ctk.CTkLabel(
            logging_frame,
            text="Logging Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        logging_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Log level
        log_level_frame = ctk.CTkFrame(logging_frame, fg_color="transparent")
        log_level_frame.pack(fill="x", padx=15, pady=5)

        log_level_label = ctk.CTkLabel(
            log_level_frame,
            text="Log Level",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        log_level_label.pack(side="left")

        self.log_level_var = ctk.StringVar(value="INFO")
        log_level_dropdown = ctk.CTkOptionMenu(
            log_level_frame,
            values=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
            variable=self.log_level_var,
            width=200
        )
        log_level_dropdown.pack(side="left", padx=10)

        # Enable file logging
        file_logging_frame = ctk.CTkFrame(
            logging_frame, fg_color="transparent")
        file_logging_frame.pack(fill="x", padx=15, pady=5)

        file_logging_label = ctk.CTkLabel(
            file_logging_frame,
            text="File Logging",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        file_logging_label.pack(side="left")

        self.file_logging_var = ctk.BooleanVar(value=True)
        file_logging_switch = ctk.CTkSwitch(
            file_logging_frame,
            text="",
            variable=self.file_logging_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        file_logging_switch.pack(side="left", padx=10)

        # Performance settings section
        performance_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        performance_frame.pack(fill="x", pady=(0, 15))

        # Section title
        performance_title = ctk.CTkLabel(
            performance_frame,
            text="Performance Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        performance_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Hardware acceleration
        hardware_frame = ctk.CTkFrame(
            performance_frame, fg_color="transparent")
        hardware_frame.pack(fill="x", padx=15, pady=5)

        hardware_label = ctk.CTkLabel(
            hardware_frame,
            text="Hardware Acceleration",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        hardware_label.pack(side="left")

        self.hardware_var = ctk.BooleanVar(value=True)
        hardware_switch = ctk.CTkSwitch(
            hardware_frame,
            text="",
            variable=self.hardware_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        hardware_switch.pack(side="left", padx=10)

        # Thread count
        thread_frame = ctk.CTkFrame(performance_frame, fg_color="transparent")
        thread_frame.pack(fill="x", padx=15, pady=5)

        thread_label = ctk.CTkLabel(
            thread_frame,
            text="Worker Threads",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        thread_label.pack(side="left")

        self.thread_var = ctk.IntVar(value=4)
        thread_slider = ctk.CTkSlider(
            thread_frame,
            from_=1,
            to=16,
            number_of_steps=15,
            variable=self.thread_var,
            width=200
        )
        thread_slider.pack(side="left", padx=10)

        thread_value = ctk.CTkLabel(
            thread_frame,
            textvariable=self.thread_var,
            width=30
        )
        thread_value.pack(side="left", padx=5)

        # Memory limit
        memory_frame = ctk.CTkFrame(performance_frame, fg_color="transparent")
        memory_frame.pack(fill="x", padx=15, pady=5)

        memory_label = ctk.CTkLabel(
            memory_frame,
            text="Memory Limit (MB)",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        memory_label.pack(side="left")

        self.memory_var = ctk.IntVar(value=1024)
        memory_slider = ctk.CTkSlider(
            memory_frame,
            from_=256,
            to=4096,
            number_of_steps=15,
            variable=self.memory_var,
            width=200
        )
        memory_slider.pack(side="left", padx=10)

        memory_value = ctk.CTkLabel(
            memory_frame,
            textvariable=self.memory_var,
            width=50
        )
        memory_value.pack(side="left", padx=5)

        # Reset button
        reset_button = ctk.CTkButton(
            container,
            text="Reset to Defaults",
            command=lambda: self.reset_advanced_settings(),
            fg_color=self.colors["bg_medium"],
            hover_color=self.colors["bg_light"],
            width=150
        )
        reset_button.pack(anchor="e", pady=10)

        return container

    def reset_advanced_settings(self):
        """Reset advanced settings to defaults"""
        self.log_level_var.set("INFO")
        self.file_logging_var.set(True)
        self.hardware_var.set(True)
        self.thread_var.set(4)
        self.memory_var.set(1024)
        self.update_status("Advanced settings reset to defaults")

    def apply_theme(self, theme_name):
        """Apply the selected theme"""
        if theme_name in self.color_schemes:
            self.colors = self.color_schemes[theme_name]
            self.config["theme"] = theme_name
            self.save_configuration(show_notification=False)
            # Refresh UI with new theme
            self.setup_theme()
            self.refresh_ui()

    def show_add_chatbot_dialog(self):
        """Show dialog to add a new chatbot"""
        dialog = ctk.CTkToplevel(self.app)
        dialog.title("Add New Chatbot")
        dialog.geometry("400x500")
        dialog.transient(self.app)
        dialog.grab_set()

        # Create form fields
        name_label = ctk.CTkLabel(
            dialog,
            text="Chatbot Name",
            text_color=self.colors["text_bright"]
        )
        name_label.pack(anchor="w", padx=20, pady=(20, 0))

        name_entry = ctk.CTkEntry(dialog, width=360)
        name_entry.pack(anchor="w", padx=20, pady=(0, 10))

        type_label = ctk.CTkLabel(
            dialog,
            text="Chatbot Type",
            text_color=self.colors["text_bright"]
        )
        type_label.pack(anchor="w", padx=20, pady=(10, 0))

        type_var = ctk.StringVar(value="GPT")
        type_dropdown = ctk.CTkOptionMenu(
            dialog,
            values=["GPT", "Claude", "Gemini", "Custom"],
            variable=type_var,
            width=360
        )
        type_dropdown.pack(anchor="w", padx=20, pady=(0, 10))

        api_key_label = ctk.CTkLabel(
            dialog,
            text="API Key",
            text_color=self.colors["text_bright"]
        )
        api_key_label.pack(anchor="w", padx=20, pady=(10, 0))

        api_key_entry = ctk.CTkEntry(dialog, width=360, show="*")
        api_key_entry.pack(anchor="w", padx=20, pady=(0, 10))

        # Add chatbot button
        def add_chatbot():
            name = name_entry.get()
            chatbot_type = type_var.get()
            api_key = api_key_entry.get()

            if name and chatbot_type and api_key:
                # Add to config
                if "chatbots" not in self.config:
                    self.config["chatbots"] = {}

                self.config["chatbots"][name] = {
                    "type": chatbot_type,
                    "api_key": api_key,
                    "status": "Ready",
                    "color": self.colors["accent_primary"],
                    "icon": "🤖"
                }

                self.save_configuration()
                self.refresh_chatbot_list()
                dialog.destroy()
            else:
                # Show error
                error_label.configure(text="Please fill in all fields")

        add_button = ctk.CTkButton(
            dialog,
            text="Add Chatbot",
            command=add_chatbot,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        add_button.pack(anchor="center", pady=20)

        # Error label
        error_label = ctk.CTkLabel(
            dialog,
            text="",
            text_color=self.colors["error"]
        )
        error_label.pack(anchor="center")

    def refresh_chatbot_list(self):
        """Refresh the list of chatbots in settings"""
        # Clear existing items
        for widget in self.chatbot_list_frame.winfo_children():
            widget.destroy()

        # Add header
        header = ctk.CTkFrame(
            self.chatbot_list_frame,
            fg_color="transparent"
        )
        header.pack(fill="x", padx=15, pady=5)

        ctk.CTkLabel(
            header,
            text="Name",
            font=ctk.CTkFont(weight="bold"),
            text_color=self.colors["text_bright"],
            width=100
        ).pack(side="left")

        ctk.CTkLabel(
            header,
            text="Type",
            font=ctk.CTkFont(weight="bold"),
            text_color=self.colors["text_bright"],
            width=100
        ).pack(side="left")

        ctk.CTkLabel(
            header,
            text="Status",
            font=ctk.CTkFont(weight="bold"),
            text_color=self.colors["text_bright"],
            width=100
        ).pack(side="left")

        # Add chatbots
        for name, config in self.config.get("chatbots", {}).items():
            self.add_chatbot_list_item(name, config)

    def add_chatbot_list_item(self, name, config):
        """Add a single chatbot item to the list"""
        # Create item frame with hover effect
        item = ctk.CTkFrame(
            self.chatbot_list_frame,
            fg_color=self.colors["bg_dark"],
            corner_radius=10,
            height=70
        )
        item.pack(fill="x", padx=5, pady=5)
        item.pack_propagate(False)

        # Add hover effect
        def on_enter(e):
            item.configure(fg_color=self.colors["bg_light"])

        def on_leave(e):
            item.configure(fg_color=self.colors["bg_dark"])

        item.bind("<Enter>", on_enter)
        item.bind("<Leave>", on_leave)

        # Icon and name container
        info_frame = ctk.CTkFrame(
            item,
            fg_color="transparent"
        )
        info_frame.pack(side="left", fill="y", padx=10)

        # Icon with colored background
        icon_frame = ctk.CTkFrame(
            info_frame,
            fg_color=config.get("color", self.colors["accent_primary"]),
            width=40,
            height=40,
            corner_radius=20
        )
        icon_frame.pack(side="left", padx=(0, 10))
        icon_frame.pack_propagate(False)

        icon_label = ctk.CTkLabel(
            icon_frame,
            text=config.get("icon", "🤖"),
            font=ctk.CTkFont(size=20)
        )
        icon_label.place(relx=0.5, rely=0.5, anchor="center")

        # Name and type
        text_frame = ctk.CTkFrame(
            info_frame,
            fg_color="transparent"
        )
        text_frame.pack(side="left", fill="y")

        name_label = ctk.CTkLabel(
            text_frame,
            text=name,
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        name_label.pack(anchor="w")

        type_label = ctk.CTkLabel(
            text_frame,
            text=config.get("type", "Unknown"),
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        type_label.pack(anchor="w")

        # Status indicator
        status_color = self.colors["status_green"] if config.get(
            "status") == "Ready" else self.colors["status_red"]
        status_frame = ctk.CTkFrame(
            item,
            fg_color="transparent"
        )
        status_frame.pack(side="right", fill="y", padx=10)

        status_dot = ctk.CTkLabel(
            status_frame,
            text="●",
            font=ctk.CTkFont(size=20),
            text_color=status_color
        )
        status_dot.pack(side="right", padx=5)

        status_label = ctk.CTkLabel(
            status_frame,
            text=config.get("status", "Unknown"),
            font=ctk.CTkFont(size=12),
            text_color=status_color
        )
        status_label.pack(side="right")

        # Make the entire item clickable
        item.bind(
            "<Button-1>",
            lambda e: self.show_chatbot_settings(
                name,
                config))

    def delete_chatbot(self, name):
        """Delete a chatbot from the configuration"""
        if name in self.config.get("chatbots", {}):
            del self.config["chatbots"][name]
            self.save_configuration()
            self.refresh_chatbot_list()
            # Also refresh the dashboard
            self.add_sample_chatbot_cards()

    def run(self):
        """Run the application main loop"""
        try:
            # Log startup
            logging.info("Starting DragonVoice application")

            # Update status
            self.update_status("Application started successfully")

            # Start the main event loop
            self.app.mainloop()

        except Exception as e:
            logging.error(f"Error in main loop: {str(e)}")
            raise

    def create_help_getting_started(self, parent):
        """Create the getting started help content"""
        # Welcome section
        welcome_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        welcome_frame.pack(fill="x", padx=20, pady=(20, 10))

        welcome_label = ctk.CTkLabel(
            welcome_frame,
            text="Welcome to Dragon Voice",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        welcome_label.pack(anchor="w", padx=20, pady=10)

        welcome_text = ctk.CTkTextbox(
            welcome_frame,
            wrap="word",
            fg_color="transparent",
            text_color=self.colors["text_dim"],
            border_width=0,
            activate_scrollbars=False
        )
        welcome_text.insert(
            "0.0",
            "Dragon Voice is a powerful voice assistant application that allows you to interact with various AI models, control your computer, and more. This guide will help you get started with the basic features of the application."
        )
        welcome_text.configure(state="disabled")
        welcome_text.pack(fill="both", padx=20, pady=(0, 10))

        # Getting started steps
        steps_frame = ctk.CTkFrame(
            parent,
            fg_color="transparent"
        )
        steps_frame.pack(fill="x", padx=20, pady=(0, 20))

        # Step 1: Configure Chatbots
        step1_frame = ctk.CTkFrame(
            steps_frame,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )
        step1_frame.pack(fill="x", padx=10, pady=10)

        step1_label = ctk.CTkLabel(
            step1_frame,
            text="Step 1: Configure Chatbots",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        step1_label.pack(anchor="w", padx=20, pady=10)

        step1_text = ctk.CTkTextbox(
            step1_frame,
            wrap="word",
            fg_color="transparent",
            text_color=self.colors["text_dim"],
            border_width=0,
            activate_scrollbars=False
        )
        step1_text.insert(
            "0.0",
            "1. Go to the 'Settings' tab.\n2. Click on 'Add Chatbot' to add a new chatbot.\n3. Fill in the required information (Name, Type, API Key).\n4. Click 'Add Chatbot' to save the configuration.\n5. Repeat the process to add more chatbots if needed."
        )
        step1_text.configure(state="disabled")
        step1_text.pack(fill="both", padx=20, pady=(0, 10))

        # Step 2: Use Voice Commands
        step2_frame = ctk.CTkFrame(
            steps_frame,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )
        step2_frame.pack(fill="x", padx=10, pady=10)

        step2_label = ctk.CTkLabel(
            step2_frame,
            text="Step 2: Use Voice Commands",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        step2_label.pack(anchor="w", padx=20, pady=10)

        step2_text = ctk.CTkTextbox(
            step2_frame,
            wrap="word",
            fg_color="transparent",
            text_color=self.colors["text_dim"],
            border_width=0,
            activate_scrollbars=False
        )
        step2_text.insert(
            "0.0",
            "1. Go to the 'Dashboard' tab.\n2. Click on 'Start Voice Assistant' to activate the voice recognition.\n3. Speak your command clearly and wait for the response.\n4. Click 'Stop Voice Assistant' to deactivate the voice recognition."
        )
        step2_text.configure(state="disabled")
        step2_text.pack(fill="both", padx=20, pady=(0, 10))

        # Step 3: Explore Additional Features
        step3_frame = ctk.CTkFrame(
            steps_frame,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )
        step3_frame.pack(fill="x", padx=10, pady=10)

        step3_label = ctk.CTkLabel(
            step3_frame,
            text="Step 3: Explore Additional Features",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        step3_label.pack(anchor="w", padx=20, pady=10)

        step3_text = ctk.CTkTextbox(
            step3_frame,
            wrap="word",
            fg_color="transparent",
            text_color=self.colors["text_dim"],
            border_width=0,
            activate_scrollbars=False
        )
        step3_text.insert(
            "0.0",
            "1. Experiment with the 'History' tab to view and manage your conversation history.\n2. Customize the application's appearance and behavior in the 'Settings' tab.\n3. Access additional help and resources in the 'About' tab."
        )
        step3_text.configure(state="disabled")
        step3_text.pack(fill="both", padx=20, pady=(0, 10))

    def create_help_about(self, parent):
        """Create the about help content"""
        # About section
        about_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        about_frame.pack(fill="x", padx=20, pady=(20, 10))

        about_label = ctk.CTkLabel(
            about_frame,
            text="About Dragon Voice",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        about_label.pack(anchor="w", padx=20, pady=10)

        about_text = ctk.CTkTextbox(
            about_frame,
            wrap="word",
            fg_color="transparent",
            text_color=self.colors["text_dim"],
            border_width=0,
            activate_scrollbars=False
        )
        about_text.insert(
            "0.0",
            "Dragon Voice is an open-source voice assistant application developed by the Dragon Voice Project. It is built using Python and various libraries and frameworks, including:

• CustomTkinter - GUI Framework
• Various AI Models - Chatbot Integration
• Open Source Community - Libraries and Tools

Special thanks to all contributors and users who have helped improve DragonVoice."
        )
        about_text.configure(state="disabled")
        about_text.pack(fill="both", padx=20, pady=(0, 10))

        # Links
        links_frame = ctk.CTkFrame(
            parent,
            fg_color="transparent"
        )
        links_frame.pack(fill="x", padx=20, pady=(0, 20))

        # GitHub link
        github_frame = ctk.CTkFrame(
            links_frame,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )
        github_frame.pack(fill="x", padx=10, pady=10)

        github_label = ctk.CTkLabel(
            github_frame,
            text="GitHub Repository",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        github_label.pack(anchor="w", padx=20, pady=10)

        github_link = ctk.CTkLabel(
            github_frame,
            text="https://github.com/DragonVoiceProject/DragonVoice",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["accent_primary"]
        )
        github_link.pack(anchor="w", padx=20, pady=(0, 10))
        github_link.bind(
            "<Button-1>",
            lambda e: webbrowser.open_new(
                "https://github.com/DragonVoiceProject/DragonVoice"))

        # Documentation link
        docs_frame = ctk.CTkFrame(
            links_frame,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )
        docs_frame.pack(fill="x", padx=10, pady=10)

        docs_label = ctk.CTkLabel(
            docs_frame,
            text="Documentation",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        docs_label.pack(anchor="w", padx=20, pady=10)

        docs_link = ctk.CTkLabel(
            docs_frame,
            text="https://dragonvoiceproject.github.io/DragonVoice/",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["accent_primary"]
        )
        docs_link.pack(anchor="w", padx=20, pady=(0, 10))
        docs_link.bind(
            "<Button-1>",
            lambda e: webbrowser.open_new(
                "https://dragonvoiceproject.github.io/DragonVoice/"))

        # Credits
        credits_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        credits_frame.pack(fill="x", padx=20, pady=(20, 10))

        credits_label = ctk.CTkLabel(
            credits_frame,
            text="Credits",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        credits_label.pack(anchor="w", padx=20, pady=10)

        credits_text = ctk.CTkTextbox(
            credits_frame,
            wrap="word",
            fg_color="transparent",
            text_color=self.colors["text_dim"],
            border_width=0,
            activate_scrollbars=False
        )
        credits_text.insert(
            "0.0",
            "Dragon Voice is an open-source project developed by the Dragon Voice Project. The following individuals have contributed to the project:

• [Your Name] - Project Lead, Developer
• [Contributor 1] - Developer
• [Contributor 2] - Designer
• [Contributor 3] - Tester

Special thanks to all contributors and users who have helped improve DragonVoice."
        )
        credits_text.configure(state="disabled")
        credits_text.pack(fill="both", padx=20, pady=(0, 10))

    def create_help_troubleshooting(self, parent):
        """Create the troubleshooting help content"""
        # Troubleshooting section
        troubleshooting_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        troubleshooting_frame.pack(fill="x", padx=20, pady=(20, 10))

        troubleshooting_label = ctk.CTkLabel(
            troubleshooting_frame,
            text="Troubleshooting",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        troubleshooting_label.pack(anchor="w", padx=20, pady=10)

        troubleshooting_text = ctk.CTkTextbox(
            troubleshooting_frame,
            wrap="word",
            fg_color="transparent",
            text_color=self.colors["text_dim"],
            border_width=0,
            activate_scrollbars=False
        )
        troubleshooting_text.insert(
            "0.0",
            "If you encounter any issues or errors while using Dragon Voice, please try the following troubleshooting steps:

1. **Check System Requirements**: Ensure that your system meets the minimum requirements for running Dragon Voice.
2. **Update Dragon Voice**: Make sure you are using the latest version of Dragon Voice.
3. **Check Microphone Permissions**: Ensure that Dragon Voice has the necessary permissions to access your microphone.
4. **Check Internet Connection**: A stable internet connection is required for some features of Dragon Voice.
5. **Review Log Files**: Check the log files for any error messages that might provide clues about the issue.
6. **Seek Community Support**: If you are still experiencing problems, don't hesitate to seek help from the Dragon Voice community or report the issue on the GitHub repository.

If you continue to experience issues after trying these troubleshooting steps, please provide detailed information about the problem, including any error messages or screenshots, when seeking further assistance."
        )
        troubleshooting_text.configure(state="disabled")
        troubleshooting_text.pack(fill="both", padx=20, pady=(0, 10))

    def create_help_faq(self, parent):
        """Create the FAQ help content"""
        # FAQ section
        faq_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        faq_frame.pack(fill="x", padx=20, pady=(20, 10))

        faq_label = ctk.CTkLabel(
            faq_frame,
            text="Frequently Asked Questions",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        faq_label.pack(anchor="w", padx=20, pady=10)

        faq_text = ctk.CTkTextbox(
            faq_frame,
            wrap="word",
            fg_color="transparent",
            text_color=self.colors["text_dim"],
            border_width=0,
            activate_scrollbars=False
        )
        faq_text.insert(
            "0.0",
            "Q: How do I add a new chatbot?\nA: Go to the 'Settings' tab, click on 'Add Chatbot', fill in the required information, and click 'Add Chatbot'.\n\n"
            "Q: Can I use Dragon Voice with multiple chatbots at the same time?\nA: Yes, you can add multiple chatbots and switch between them as needed.\n\n"
            "Q: How do I change the appearance of Dragon Voice?\nA: Go to the 'Settings' tab and customize the theme and color scheme according to your preferences.\n\n"
            "Q: Can I use Dragon Voice offline?\nA: Some features of Dragon Voice require an internet connection, but you can still use basic voice commands offline.\n\n"
            "Q: How do I report a bug or issue?\nA: If you encounter any issues or bugs, please report them on the GitHub repository or seek help from the Dragon Voice community."
        )
        faq_text.configure(state="disabled")
        faq_text.pack(fill="both", padx=20, pady=(0, 10))

    def create_help_tab(self):
        """Create the help tab content"""
        # Main container with gradient background
        help_container = ctk.CTkScrollableFrame(
            self.tabs_frame,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )
        help_container.pack(fill="both", expand=True)

        # Help sections
        self.create_help_getting_started(help_container)
        self.create_help_about(help_container)
        self.create_help_troubleshooting(help_container)
        self.create_help_faq(help_container)

    def create_history_tab(self):
        """Create the history tab content"""
        # Main container with gradient background
        history_container = ctk.CTkScrollableFrame(
            self.tabs_frame,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )
        history_container.pack(fill="both", expand=True)

        # History content goes here

    def create_config_tab(self):
        """Create the configuration tab content"""
        # Main container with gradient background
        config_container = ctk.CTkScrollableFrame(
            self.tabs_frame,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )
        config_container.pack(fill="both", expand=True)

        # Configuration content goes here

    def create_about_tab(self):
        """Create the about tab content"""
        # Main container with gradient background
        about_container = ctk.CTkScrollableFrame(
            self.tabs_frame,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )
        about_container.pack(fill="both", expand=True)

        # About content goes here

    def create_tabs(self):
        """Create the main tabs for the application"""
        # Tabs container
        self.tabs_frame = ctk.CTkFrame(
            self.app,
            fg_color="transparent"
        )
        self.tabs_frame.pack(fill="both", expand=True)

        # Tab names
        tab_names = ["Dashboard", "History", "Settings", "Help", "About"]

        # Tab layout
        self.tab_layout = ctk.CTkTabview(
            self.tabs_frame,
            fg_color="transparent",
            segmented_button_fg_color=self.colors["accent_primary"],
            segmented_button_selected_color=self.colors["accent_secondary"],
            segmented_button_selected_hover_color=self.colors["accent_secondary"],
            segmented_button_unselected_color=self.colors["bg_dark"],
            segmented_button_unselected_hover_color=self.colors["bg_light"]
        )
        self.tab_layout.pack(fill="both", expand=True)

        # Create tabs
        for tab_name in tab_names:
            self.tab_layout.add(tab_name)
            self.tab_layout.tab(tab_name).configure(
                fg_color=self.colors["bg_dark"])

        # Tab content
        self.create_dashboard_tab()
        self.create_history_tab()
        self.create_config_tab()
        self.create_help_tab()
        self.create_about_tab()

    def create_dashboard_tab(self):
        """Create the dashboard tab content"""
        # Main container with gradient background
        dashboard_container = ctk.CTkScrollableFrame(
            self.tab_layout.tab("Dashboard"),
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )
        dashboard_container.pack(fill="both", expand=True)

        # System status section
        system_status_frame = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        system_status_frame.pack(fill="x", padx=20, pady=(20, 10))

        system_status_label = ctk.CTkLabel(
            system_status_frame,
            text="System Status",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        system_status_label.pack(anchor="w", padx=20, pady=10)

        # CPU usage
        cpu_frame = ctk.CTkFrame(
            system_status_frame,
            fg_color="transparent"
        )
        cpu_frame.pack(fill="x", padx=20, pady=(0, 10))

        cpu_label = ctk.CTkLabel(
            cpu_frame,
            text="CPU Usage",
            font=ctk.CTkFont(size=16),
            text_color=self.colors["text_dim"]
        )
        cpu_label.pack(side="left")

        self.cpu_progress = ctk.CTkProgressBar(
            cpu_frame,
            orientation="horizontal",
            mode="determinate",
            progress_color=self.colors["accent_primary"]
        )
        self.cpu_progress.pack(side="right", fill="x", expand=True, padx=10)

        # Memory usage
        memory_frame = ctk.CTkFrame(
            system_status_frame,
            fg_color="transparent"
        )
        memory_frame.pack(fill="x", padx=20, pady=(0, 10))

        memory_label = ctk.CTkLabel(
            memory_frame,
            text="Memory Usage",
            font=ctk.CTkFont(size=16),
            text_color=self.colors["text_dim"]
        )
        memory_label.pack(side="left")

        self.memory_progress = ctk.CTkProgressBar(
            memory_frame,
            orientation="horizontal",
            mode="determinate",
            progress_color=self.colors["accent_primary"]
        )
        self.memory_progress.pack(side="right", fill="x", expand=True, padx=10)

        # Disk space
        disk_frame = ctk.CTkFrame(
            system_status_frame,
            fg_color="transparent"
        )
        disk_frame.pack(fill="x", padx=20, pady=(0, 10))

        disk_label = ctk.CTkLabel(
            disk_frame,
            text="Disk Space",
            font=ctk.CTkFont(size=16),
            text_color=self.colors["text_dim"]
        )
        disk_label.pack(side="left")

        self.disk_progress = ctk.CTkProgressBar(
            disk_frame,
            orientation="horizontal",
            mode="determinate",
            progress_color=self.colors["accent_primary"]
        )
        self.disk_progress.pack(side="right", fill="x", expand=True, padx=10)

        # Voice assistant section
        voice_assistant_frame = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        voice_assistant_frame.pack(fill="x", padx=20, pady=(20, 10))

        voice_assistant_label = ctk.CTkLabel(
            voice_assistant_frame,
            text="Voice Assistant",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        voice_assistant_label.pack(anchor="w", padx=20, pady=10)

        # Voice assistant controls
        controls_frame = ctk.CTkFrame(
            voice_assistant_frame,
            fg_color="transparent"
        )
        controls_frame.pack(fill="x", padx=20, pady=(0, 10))

        # Toggle button
        self.toggle_button = ctk.CTkButton(
            controls_frame,
            text="Start Voice Assistant",
            command=self.toggle_voice_assistant,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        self.toggle_button.pack(side="left", padx=(0, 10))

        # Record button
        self.record_button = ctk.CTkButton(
            controls_frame,
            text="Record",
            command=self.start_manual_recording,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        self.record_button.pack(side="left", padx=(0, 10))

        # Stop button
        self.stop_button = ctk.CTkButton(
            controls_frame,
            text="Stop Recording",
            command=self.stop_manual_recording,
            fg_color=self.colors["status_red"],
            hover_color=self.colors["status_red_dark"]
        )
        self.stop_button.pack(side="left")

        # Voice detection display
        voice_detection_frame = ctk.CTkFrame(
            voice_assistant_frame,
            fg_color="transparent"
        )
        voice_detection_frame.pack(fill="x", padx=20, pady=(0, 10))

        voice_detection_label = ctk.CTkLabel(
            voice_detection_frame,
            text="Voice Detection",
            font=ctk.CTkFont(size=16),
            text_color=self.colors["text_dim"]
        )
        voice_detection_label.pack(side="left")

        self.voice_detection_indicator = ctk.CTkLabel(
            voice_detection_frame,
            text="",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        self.voice_detection_indicator.pack(side="right")

        # Microphone sensitivity
        sensitivity_frame = ctk.CTkFrame(
            voice_assistant_frame,
            fg_color="transparent"
        )
        sensitivity_frame.pack(fill="x", padx=20, pady=(0, 10))

        sensitivity_label = ctk.CTkLabel(
            sensitivity_frame,
            text="Microphone Sensitivity",
            font=ctk.CTkFont(size=16),
            text_color=self.colors["text_dim"]
        )
        sensitivity_label.pack(side="left")

        self.gain_var = ctk.DoubleVar(value=0.5)
        self.gain_slider = ctk.CTkSlider(
            sensitivity_frame,
            from_=0.1,
            to=1.0,
            number_of_steps=9,
            variable=self.gain_var,
            command=self.update_gain
        )
        self.gain_slider.pack(side="right", fill="x", expand=True, padx=10)

        self.gain_percentage = ctk.CTkLabel(
            sensitivity_frame,
            text="50%",
            font=ctk.CTkFont(size=16),
            text_color=self.colors["text_dim"]
        )
        self.gain_percentage.pack(side="right")

        # Transcription section
        transcription_frame = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        transcription_frame.pack(fill="x", padx=20, pady=(20, 10))

        transcription_label = ctk.CTkLabel(
            transcription_frame,
            text="Transcription",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        transcription_label.pack(anchor="w", padx=20, pady=10)

        # Transcription display
        self.transcription_display = ctk.CTkTextbox(
            transcription_frame,
            wrap="word",
            fg_color="transparent",
            text_color=self.colors["text_dim"],
            border_width=0,
            activate_scrollbars=False
        )
        self.transcription_display.pack(fill="both", padx=20, pady=(0, 10))

        # Transcription controls
        transcription_controls_frame = ctk.CTkFrame(
            transcription_frame,
            fg_color="transparent"
        )
        transcription_controls_frame.pack(fill="x", padx=20, pady=(0, 10))

        self.clear_button = ctk.CTkButton(
            transcription_controls_frame,
            text="Clear",
            command=self.clear_transcription,
            fg_color=self.colors["bg_dark"],
            hover_color=self.colors["bg_light"]
        )
        self.clear_button.pack(side="left", padx=(0, 10))

        self.enter_button = ctk.CTkButton(
            transcription_controls_frame,
            text="Enter",
            command=self.process_transcription,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        self.enter_button.pack(side="left")

        # Text display
        text_display_frame = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        text_display_frame.pack(fill="x", padx=20, pady=(20, 10))

        text_display_label = ctk.CTkLabel(
            text_display_frame,
            text="Text Display",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        text_display_label.pack(anchor="w", padx=20, pady=10)

        # Text display area
        self.text_display = ctk.CTkTextbox(
            text_display_frame,
            wrap="word",
            fg_color="transparent",
            text_color=self.colors["text_dim"],
            border_width=0,
            activate_scrollbars=False
        )
        self.text_display.pack(fill="both", padx=20, pady=(0, 10))

        # Text display controls
        text_display_controls_frame = ctk.CTkFrame(
            text_display_frame,
            fg_color="transparent"
        )
        text_display_controls_frame.pack(fill="x", padx=20, pady=(0, 10))

        self.clear_text_button = ctk.CTkButton(
            text_display_controls_frame,
            text="Clear",
            command=self.clear_text_display,
            fg_color=self.colors["bg_dark"],
            hover_color=self.colors["bg_light"]
        )
        self.clear_text_button.pack(side="left", padx=(0, 10))

        self.send_button = ctk.CTkButton(
            text_display_controls_frame,
            text="Send",
            command=self.send_to_chatbots,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        self.send_button.pack(side="left")

        # Sample chatbot cards
        self.add_sample_chatbot_cards()

        # Start system status updates
        self.update_system_status()

    def add_sample_chatbot_cards(self):
        """Add sample chatbot cards to the dashboard"""
        # Sample chatbot data
        sample_chatbots = [
            {"name": "Chatbot 1", "type": "GPT", "status": "Ready"},
            {"name": "Chatbot 2", "type": "Claude", "status": "Offline"},
            {"name": "Chatbot 3", "type": "Gemini", "status": "Busy"}
        ]

        # Add chatbot cards
        for chatbot in sample_chatbots:
            self.add_chatbot_card(chatbot["name"], chatbot["type"], chatbot["status"])

    def add_chatbot_card(self, name, chatbot_type, status):
        """Add a chatbot card to the dashboard"""
        # Chatbot card frame
        chatbot_card = ctk.CTkFrame(
            self.tabs_frame,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )
        chatbot_card.pack(fill="x", padx=20, pady=(0, 10))

        # Chatbot info
        info_frame = ctk.CTkFrame(
            chatbot_card,
            fg_color="transparent"
        )
        info_frame.pack(side="left", fill="y", padx=10)

        # Chatbot icon
        icon_frame = ctk.CTkFrame(
            info_frame,
            fg_color=self.colors["accent_primary"],
            width=40,
            height=40,
            corner_radius=20
        )
        icon_frame.pack(side="left", padx=(0, 10))
        icon_frame.pack_propagate(False)

        icon_label = ctk.CTkLabel(
            icon_frame,
            text="🤖",
            font=ctk.CTkFont(size=20)
        )
        icon_label.place(relx=0.5, rely=0.5, anchor="center")

        # Chatbot name and type
        text_frame = ctk.CTkFrame(
            info_frame,
            fg_color="transparent"
        )
        text_frame.pack(side="left", fill="y")

        name_label = ctk.CTkLabel(
            text_frame,
            text=name,
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        name_label.pack(anchor="w")

        type_label = ctk.CTkLabel(
            text_frame,
            text=chatbot_type,
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        type_label.pack(anchor="w")

        # Status indicator
        status_color = self.colors["status_green"] if status == "Ready" else self.colors["status_red"]
        status_frame = ctk.CTkFrame(
            chatbot_card,
            fg_color="transparent"
        )
        status_frame.pack(side="right", fill="y", padx=10)

        status_dot = ctk.CTkLabel(
            status_frame,
            text="●",
            font=ctk.CTkFont(size=20),
            text_color=status_color
        )
        status_dot.pack(side="right", padx=5)

        status_label = ctk.CTkLabel(
            status_frame,
            text=status,
            font=ctk.CTkFont(size=12),
            text_color=status_color
        )
        status_label.pack(side="right")

    def update_system_status(self):
        """Update system status information"""
        # CPU usage
        cpu_percent = psutil.cpu_percent(interval=1)
        self.cpu_progress.set(cpu_percent / 100)

        # Memory usage
        memory_info = psutil.virtual_memory()
        memory_percent = memory_info.percent
        self.memory_progress.set(memory_percent / 100)

        # Disk space
        disk_info = psutil.disk_usage('/')
        disk_percent = disk_info.percent
        self.disk_progress.set(disk_percent / 100)

        # Schedule next update
        self.app.after(1000, self.update_system_status)

    def toggle_voice_assistant(self):
        """Toggle voice assistant on/off"""
        if not hasattr(self, 'recording_active') or not self.recording_active:
            self.start_voice_assistant()
        else:
            self.stop_voice_assistant()

    def start_voice_assistant(self):
        """Start voice assistant"""
        self.toggle_button.configure(
            text="Stop Voice Assistant",
            fg_color=self.colors["status_red"],
            hover_color=self.colors["status_red_dark"]
        )
        self.record_button.configure(state="normal")
        self.stop_button.configure(state="disabled")
        self.recording_active = True
        self.animate_level_meter()

    def stop_voice_assistant(self):
        """Stop voice assistant"""
        self.toggle_button.configure(
            text="Start Voice Assistant",
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        self.record_button.configure(state="disabled")
        self.stop_button.configure(state="disabled")
        self.recording_active = False
        self.voice_detection_indicator.configure(text="")

    def start_manual_recording(self):
        """Start manual recording"""
        self.record_button.configure(state="disabled")
        self.stop_button.configure(state="normal")
        self.recording_active = True
        self.animate_level_meter()
        self.init_whisper_recognizer()
        self.whisper_recognizer.start_recording()

    def stop_manual_recording(self):
        """Stop manual recording"""
        self.record_button.configure(state="normal")
        self.stop_button.configure(state="disabled")
        self.recording_active = False
        self.voice_detection_indicator.configure(text="")
        self.whisper_recognizer.stop_recording()
        self.transcribe_last_recording()

    def animate_level_meter(self):
        """Animate the microphone level meter during recording"""
        if not hasattr(self, 'recording_active') or not self.recording_active:
            # Even when not recording, update with zero level to show the meter
            self.voice_detection_indicator.configure(text="")
            return

        # Get microphone level
        level = self.whisper_recognizer.get_microphone_level()

        # Update level indicator
        self.voice_detection_indicator.configure(text=f"Level: {level:.2f}")

        # Schedule next update
        self.app.after(100, self.animate_level_meter)

    def init_whisper_recognizer(self):
        """Initialize the WhisperRecognizer"""
        self.whisper_recognizer = WhisperRecognizer(
            model="openai/whisper-large-v3-turbo",
            api_key="j3ydNXEmQFyDKwl5mWxSzcvdZcTLJw1t",
            base_url="https://api.deepinfra.com/v1/openai",
            language="en",
            prompt="The audio is a conversation between two people",
            response_format="json",
            temperature=0,
            timestamp_granularities=["segment"]
        )

    def transcribe_last_recording(self):
        """Transcribe the last recording"""
        try:
            # Get the last recording file path
            last_recording_file = self.whisper_recognizer.get_last_recording_file()

            # Transcribe the recording
            transcription = self.whisper_recognizer.transcribe(last_recording_file)

            # Update the transcription display
            self.transcription_display.delete("1.0", "end")
            self.transcription_display.insert("1.0", transcription)

            # Enable the Enter button
            self.enter_button.configure(state="normal")

        except Exception as e:
            logging.error(f"Error transcribing last recording: {str(e)}")
            self.update_status(f"Error transcribing last recording: {str(e)}")

    def clear_transcription(self):
        """Clear the transcription display"""
        self.transcription_display.delete("1.0", "end")
        self.enter_button.configure(state="disabled")

    def process_transcription(self):
        """Process the transcription"""
        transcription = self.transcription_display.get("1.0", "end").strip()
        if transcription:
            self.add_to_text_display(transcription)
            self.clear_transcription()

    def add_to_text_display(self, text):
        """Add text to the text display"""
        self.text_display.insert("end", text + "\n")

    def clear_text_display(self):
        """Clear the text display"""
        self.text_display.delete("1.0", "end")

    def send_to_chatbots(self):
        """Send the text to chatbots"""
        text = self.text_display.get("1.0", "end").strip()
        if text:
            # Implement chatbot interaction here
            pass

    def update_gain(self, value):
        """Update the microphone gain"""
        self.gain_percentage.configure(text=f"{int(value * 100)}%")
        if hasattr(self, 'whisper_recognizer'):
            self.whisper_recognizer.set_gain(value)

#!/usr/bin/env python3
"""
Dragon Voice GUI - Main application interface for Dragon Voice Project
"""

from whisper_integration import WhisperRecognizer
import os
import sys
import json
import time
import logging
import webbrowser
import threading
from datetime import datetime
from pathlib import Path

# GUI libraries
import tkinter as tk
from tkinter import messagebox
import customtkinter as ctk
from PIL import Image, ImageTk

# System monitoring
import psutil
import platform

# Window management
import pygetwindow as gw
import pyautogui
import sounddevice as sd
import numpy as np
import tempfile
import os
import time
import threading

# Custom components
from synthesizer_bar import SynthesizerBar

# Try to import soundfile, but don't fail if it's not available
try:
    import soundfile as sf
    SOUNDFILE_AVAILABLE = True
except ImportError:
    SOUNDFILE_AVAILABLE = False
    print("Warning: soundfile module not found. Some audio features will be limited.")

# Configure logging
logging.basicConfig(
    level=logging.WARNING,  # Changed from INFO to WARNING
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("dragon_gui.log"),
        logging.StreamHandler()
    ]
)

# Constants
DEFAULT_CONFIG_PATH = "src/config.json"
ASSETS_DIR = os.path.join("src", "assets")

# Add Whisper integration


class DragonVoiceGUI:
    """
    Main GUI class for the Dragon Voice Project

    Provides a modern, feature-rich interface for controlling the voice assistant,
    managing chatbots, and configuring system settings.
    """

    def __init__(self, config_path=DEFAULT_CONFIG_PATH):
        """Initialize the DragonVoice GUI application"""
        logging.info("Initializing DragonVoiceGUI")
        logging.info("Initializing DragonVoice GUI")

        try:
            # Initialize logging
            self.setup_logging()

            # Initialize state variables
            self.recording_active = False
            self.continuous_recording = False  # Flag for continuous recording
            self.is_fullscreen = False

            # Create main application window
            self.app = ctk.CTk()
            self.app.title("DragonVoice")
            self.app.geometry("1200x800")
            self.app.minsize(900, 600)
            
            # Center window on screen
            screen_width = self.app.winfo_screenwidth()
            screen_height = self.app.winfo_screenheight()
            x = (screen_width - 1200) // 2
            y = (screen_height - 800) // 2
            self.app.geometry(f"1200x800+{x}+{y}")

            # Load configuration
            self.config_path = config_path
            self.config = self.load_config()
            logging.info(f"Configuration loaded from {config_path}")

            # Set up theme and colors
            self.setup_theme()

            # Initialize Whisper recognizer
            self.init_whisper_recognizer()

            # Set up UI components
            self.setup_ui()

            # Start system monitoring
            self.start_system_monitoring()

        except Exception as e:
            logging.error(f"Error initializing DragonVoiceGUI: {str(e)}")
            raise

    def setup_logging(self):
        """Set up logging configuration"""
        # Check if logging is already configured
        if not logging.getLogger().handlers:
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - %(message)s'
            )
        logging.info("Logging setup complete")

    def setup_theme(self):
        """Set up the theme and colors for the application"""
        # Set appearance mode
        ctk.set_appearance_mode("dark")

        # Define color schemes
        self.color_schemes = {
            "dark": {
                "bg_dark": "#1A1A2E",
                "bg_medium": "#16213E",
                "bg_light": "#0F3460",
                "accent_primary": "#E94560",
                "accent_secondary": "#0F52BA",
                "text_bright": "#FFFFFF",
                "text_normal": "#E0E0E0",
                "text_dim": "#A0A0A0",
                "status_green": "#4CAF50",
                "status_yellow": "#FFC107",
                "status_red": "#F44336",
                "status_blue": "#2196F3",
                "status_gray": "#757575"
            },
            "light": {
                "bg_dark": "#F0F0F0",
                "bg_medium": "#E0E0E0",
                "bg_light": "#D0D0D0",
                "accent_primary": "#E94560",
                "accent_secondary": "#0F52BA",
                "text_bright": "#000000",
                "text_normal": "#202020",
                "text_dim": "#505050",
                "status_green": "#4CAF50",
                "status_yellow": "#FFC107",
                "status_red": "#F44336",
                "status_blue": "#2196F3",
                "status_gray": "#757575"
            },
            "dragon": {
                "bg_dark": "#0A1931",
                "bg_medium": "#150E56",
                "bg_light": "#1A1A40",
                "accent_primary": "#D82148",
                "accent_secondary": "#6EBF8B",
                "text_bright": "#FFFFFF",
                "text_normal": "#E0E0E0",
                "text_dim": "#A0A0A0",
                "status_green": "#4CAF50",
                "status_yellow": "#FFC107",
                "status_red": "#F44336",
                "status_blue": "#2196F3",
                "status_gray": "#757575"
            }
        }

        # Set default color scheme
        self.colors = self.color_schemes["dragon"]

        # Define fonts
        self.fonts = {
            "header": ctk.CTkFont(family="Segoe UI", size=28, weight="bold"),
            "title": ctk.CTkFont(family="Segoe UI", size=20, weight="bold"),
            "subtitle": ctk.CTkFont(family="Segoe UI", size=16, weight="bold"),
            "normal": ctk.CTkFont(family="Segoe UI", size=14),
            "small": ctk.CTkFont(family="Segoe UI", size=12),
            "tiny": ctk.CTkFont(family="Segoe UI", size=10),
            "mono": ctk.CTkFont(family="Consolas", size=12),
            # Added the 'large' font definition
            "large": ctk.CTkFont(family="Segoe UI", size=18)
        }

    def init_whisper_recognizer(self):
        """Initialize the Whisper recognizer"""
        try:
            # Initialize API keys with default values
            self.openai_api_key = "j3ydNXEmQFyDKwl5mWxSzcvdZcTLJw1t"
            self.base_url = "https://api.deepinfra.com/v1/openai"
            
            # Initialize WhisperRecognizer with error handling
            if self.openai_api_key:
                self.whisper_recognizer = WhisperRecognizer(
                    api_key=self.openai_api_key,
                    base_url=self.base_url
                )
                # Initialize recording state
                self.recording_active = False
                self.continuous_recording = False
                self.audio_data = []
                logging.info("WhisperRecognizer initialized successfully")
            else:
                logging.warning("No OpenAI API key found, WhisperRecognizer not initialized")
                self.whisper_recognizer = None
        except Exception as e:
            logging.error(f"Failed to initialize WhisperRecognizer: {str(e)}")
            self.whisper_recognizer = None

    def setup_ui(self):
        """Set up the main UI components"""
        try:
            # Create the main container
            self.main_container = ctk.CTkFrame(
                self.app, fg_color="transparent")
            self.main_container.pack(fill="both", expand=True)

            # Create UI components in the correct order
            self.create_footer()  # Create footer first to ensure status_label exists
            self.create_header()
            self.create_tabs()

            # Start system monitoring
            self.start_system_monitoring()

            # Update status
            self.update_status("Application initialized successfully")

            # Log successful UI setup
            logging.info("UI setup completed successfully")

        except Exception as e:
            logging.error(f"Error setting up UI: {str(e)}", exc_info=True)
            # Show error in a messagebox if possible
            try:
                import tkinter.messagebox as messagebox
                messagebox.showerror(
                    "UI Setup Error",
                    f"Error setting up UI:\n{str(e)}")
            except BaseException:
                pass

    def create_header(self):
        """Create a modern application header with logo and controls"""
        # Create header frame with gradient background
        self.header_frame = ctk.CTkFrame(
            self.main_container,
            fg_color=self.colors["bg_dark"],
            corner_radius=0,
            height=90
        )
        self.header_frame.pack(fill="x", pady=0)
        self.header_frame.pack_propagate(False)

        # Create gradient effect for header
        self.header_canvas = ctk.CTkCanvas(
            self.header_frame,
            bg=self.colors["bg_dark"],
            highlightthickness=0,
            height=90
        )
        self.header_canvas.pack(fill="x", side="top")

        # Draw gradient
        def draw_gradient():
            width = self.header_canvas.winfo_width()
            if width <= 1:  # Not yet properly initialized
                self.app.after(100, draw_gradient)
                return

            height = 90
            # Create a more sophisticated gradient
            for i in range(width):
                # Calculate gradient position (0 to 1)
                pos = i / width

                # Create a gradient with accent color highlights
                if pos < 0.2:  # First section - dark to medium with accent hint
                    ratio = pos / 0.2
                    r1, g1, b1 = self.hex_to_rgb(self.colors["bg_dark"])
                    r2, g2, b2 = self.hex_to_rgb(self.colors["bg_medium"])
                    r3, g3, b3 = self.hex_to_rgb(self.colors["accent_primary"])

                    # Mix colors with a hint of accent
                    r = r1 + (r2 - r1) * ratio + (r3 - r1) * ratio * 0.1
                    g = g1 + (g2 - g1) * ratio + (g3 - g1) * ratio * 0.1
                    b = b1 + (b2 - b1) * ratio + (b3 - b1) * ratio * 0.1
                elif pos < 0.8:  # Middle section - medium to medium with subtle variation
                    ratio = (pos - 0.2) / 0.6
                    r1, g1, b1 = self.hex_to_rgb(self.colors["bg_medium"])
                    r2, g2, b2 = self.hex_to_rgb(
                        self._adjust_color_brightness(
                            self.colors["bg_medium"], 1.1))

                    r = r1 + (r2 - r1) * ratio
                    g = g1 + (g2 - g1) * ratio
                    b = b1 + (b2 - b1) * ratio
                else:  # Last section - medium to dark with accent hint
                    ratio = (pos - 0.8) / 0.2
                    r1, g1, b1 = self.hex_to_rgb(self.colors["bg_medium"])
                    r2, g2, b2 = self.hex_to_rgb(self.colors["bg_dark"])
                    r3, g3, b3 = self.hex_to_rgb(
                        self.colors["accent_secondary"])

                    # Mix colors with a hint of accent
                    r = r1 + (r2 - r1) * ratio + (r3 - r1) * ratio * 0.1
                    g = g1 + (g2 - g1) * ratio + (g3 - g1) * ratio * 0.1
                    b = b1 + (b2 - b1) * ratio + (b3 - b1) * ratio * 0.1

                color = f'#{int(r):02x}{int(g):02x}{int(b):02x}'
                self.header_canvas.create_line(i, 0, i, height, fill=color)

            # Add accent line at bottom with glow effect
            for i in range(3):
                alpha = 0.3 + (0.7 * (i / 2))  # Increasing opacity
                glow_color = self._adjust_color_brightness(
                    self.colors["accent_primary"], alpha)
            self.header_canvas.create_line(
                0, height - 3 + i, width, height - 3 + i,
                fill=glow_color,
                width=1
            )

        # Schedule gradient drawing
        self.app.after(100, draw_gradient)

        # Create a container for the header content
        header_content = ctk.CTkFrame(
            self.header_frame, fg_color="transparent")
        header_content.place(
            relx=0.5,
            rely=0.5,
            anchor="center",
            relwidth=1,
            relheight=0.8)

        # Left side - Logo and title
        logo_frame = ctk.CTkFrame(header_content, fg_color="transparent")
        logo_frame.pack(side="left", padx=(30, 0))

        # Try to load logo image if available
        try:
            logo_path = os.path.join("src", "assets", "dragon_logo.png")
            if os.path.exists(logo_path):
                logo_image = ctk.CTkImage(
                    light_image=Image.open(logo_path),
                    dark_image=Image.open(logo_path),
                    size=(40, 40)
                )
                logo_label = ctk.CTkLabel(
                    logo_frame,
                    image=logo_image,
                    text=""
                )
                logo_label.pack(side="left", padx=(0, 15))
        except Exception as e:
            logging.error(f"Failed to load logo: {str(e)}")

        # App title with modern styling
        title_label = ctk.CTkLabel(
            logo_frame,
            text="DragonVoice",
            font=self.fonts["header"],
            text_color=self.colors["text_bright"]
        )
        title_label.pack(side="left")

        # Version with pill background
        version_pill = ctk.CTkFrame(
            logo_frame,
            fg_color=self.colors["accent_primary"],
            corner_radius=12,
            height=24
        )
        version_pill.pack(side="left", padx=(10, 0), pady=(8, 0))

        version_label = ctk.CTkLabel(
            version_pill,
            text="v2.0",
            font=self.fonts["small"],
            text_color=self.colors["text_bright"]
        )
        version_label.pack(padx=10, pady=2)

        # Center - Status indicator
        status_frame = ctk.CTkFrame(header_content, fg_color="transparent")
        status_frame.pack(side="left", expand=True)

        # Right side - Controls
        controls_frame = ctk.CTkFrame(header_content, fg_color="transparent")
        controls_frame.pack(side="right", padx=(0, 30))

        # Microphone selector with improved styling
        mic_frame = ctk.CTkFrame(
            controls_frame,
            fg_color=self.colors["bg_light"],
            corner_radius=8
        )
        mic_frame.pack(side="left", padx=(0, 15), pady=5)

        mic_label = ctk.CTkLabel(
            mic_frame,
            text="Microphone:",
            font=self.fonts["small"],
            text_color=self.colors["text_normal"]
        )
        mic_label.pack(side="left", padx=(10, 5), pady=5)

        # Microphone dropdown
        self.mic_var = ctk.StringVar(value="Default Microphone")
        self.mic_dropdown = ctk.CTkOptionMenu(
            mic_frame,
            values=["Default Microphone"],
            variable=self.mic_var,
            width=150,
            dynamic_resizing=True,
            fg_color=self.colors["bg_medium"],
            button_color=self.colors["accent_primary"],
            button_hover_color=self.colors["accent_secondary"],
            dropdown_fg_color=self.colors["bg_medium"]
        )
        self.mic_dropdown.pack(side="left", padx=(0, 10), pady=5)

        # Theme toggle button
        theme_button = ctk.CTkButton(
            controls_frame,
            text="",
            width=36,
            height=36,
            corner_radius=10,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            text_color=self.colors["text_bright"],
            command=self.toggle_theme
        )
        theme_button.pack(side="left", padx=(0, 10))

        # Settings button
        settings_button = ctk.CTkButton(
            controls_frame,
            text="Settings",
            width=100,
            height=36,
            corner_radius=10,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            text_color=self.colors["text_bright"],
            command=self.show_settings
        )
        settings_button.pack(side="left", padx=(0, 10))

        # Help button
        help_button = ctk.CTkButton(
            controls_frame,
            text="Help",
            width=80,
            height=36,
            corner_radius=10,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            text_color=self.colors["text_bright"],
            command=self.show_help
        )
        help_button.pack(side="left")

        # Refresh microphone list
        self.refresh_mic_list()

    def hex_to_rgb(self, hex_color):
        """Convert hex color to RGB tuple"""
        hex_color = hex_color.lstrip('#')
        return tuple(int(hex_color[i:i + 2], 16) for i in (0, 2, 4))

    def show_settings(self):
        """Show the settings dialog"""
        # Switch to the Configuration tab
        self.tab_view.set("Configuration")

    def show_help(self):
        """Show the help dialog"""
        # Create a new top-level window
        help_window = ctk.CTkToplevel(self.app)
        help_window.title("DragonVoice Help")
        help_window.geometry("800x600")
        help_window.minsize(800, 600)
        help_window.grab_set()  # Make window modal

        # Set window icon
        if platform.system() == "Windows":
            try:
                icon_path = os.path.join(
                    os.path.dirname(
                        os.path.abspath(__file__)),
                    "assets",
                    "dragon_icon.ico")
                if os.path.exists(icon_path):
                    help_window.iconbitmap(icon_path)
            except Exception as e:
                print(f"Could not set help window icon: {e}")

        # Create tab view for help content
        help_tabs = ctk.CTkTabview(
            help_window,
            fg_color=self.colors["bg_dark"],
            segmented_button_fg_color=self.colors["bg_medium"],
            segmented_button_selected_color=self.colors["accent_primary"],
            segmented_button_selected_hover_color=self.colors["accent_secondary"],
            segmented_button_unselected_color=self.colors["bg_medium"],
            segmented_button_unselected_hover_color=self.colors["bg_light"])
        help_tabs.pack(fill="both", expand=True, padx=20, pady=20)

        # Add tabs
        help_tabs.add("Getting Started")
        help_tabs.add("Voice Commands")
        help_tabs.add("Chatbots")
        help_tabs.add("Troubleshooting")
        help_tabs.add("About")

        # Create content for each tab
        self.create_help_getting_started(help_tabs.tab("Getting Started"))
        self.create_help_voice_commands(help_tabs.tab("Voice Commands"))
        self.create_help_chatbots(help_tabs.tab("Chatbots"))
        self.create_help_troubleshooting(help_tabs.tab("Troubleshooting"))
        self.create_help_about(help_tabs.tab("About"))

        # Add close button at bottom
        button_frame = ctk.CTkFrame(help_window, fg_color="transparent")
        button_frame.pack(fill="x", padx=20, pady=(0, 20))

        close_button = ctk.CTkButton(
            button_frame,
            text="Close",
            command=help_window.destroy,
            width=100,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        close_button.pack(side="right")

    def create_footer(self):
        """Create the footer with status information"""
        # Create footer container
        self.footer = ctk.CTkFrame(
            self.app,
            fg_color=self.colors["bg_dark"],
            height=30
        )
        self.footer.pack(fill="x", side="bottom")
        self.footer.pack_propagate(False)

        # Create canvas for gradient background
        footer_canvas = ctk.CTkCanvas(
            self.footer,
            bg=self.colors["bg_dark"],
            highlightthickness=0,
            height=30
        )
        footer_canvas.pack(fill="x")

        # Draw gradient
        def draw_gradient():
            width = footer_canvas.winfo_width()
            if width <= 1:  # Not properly rendered yet
                self.app.after(100, draw_gradient)
                return

            height = 30
            # Create gradient from dark to slightly lighter
            for i in range(height):
                # Calculate color based on position
                r, g, b = self.hex_to_rgb(self.colors["bg_dark"])
                factor = i / height * 0.2  # Subtle gradient
                r = min(255, int(r + (255 - r) * factor))
                g = min(255, int(g + (255 - g) * factor))
                b = min(255, int(b + (255 - b) * factor))
                color = f'#{r:02x}{g:02x}{b:02x}'

                # Draw line
                footer_canvas.create_line(0, i, width, i, fill=color)

        # Schedule gradient drawing after the window is rendered
        self.app.after(100, draw_gradient)

        # Status label
        self.status_label = ctk.CTkLabel(
            footer_canvas,
            text="Ready",
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        self.status_label.place(relx=0.01, rely=0.5, anchor="w")

        # Version label
        version_label = ctk.CTkLabel(
            footer_canvas,
            text="DragonVoice v2.0",
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        version_label.place(relx=0.99, rely=0.5, anchor="e")

        # Log successful creation
        logging.info(
            "Footer created successfully with status_label initialized")

    def create_tabs(self):
        """Create the main tab view and tabs"""
        # Create the main tab container
        self.tab_container = ctk.CTkFrame(self.app, fg_color="transparent")
        self.tab_container.pack(
            fill="both",
            expand=True,
            padx=20,
            pady=(
                0,
                20))

        # Create the tab view
        self.tab_view = ctk.CTkTabview(
            self.tab_container,
            fg_color=self.colors["bg_dark"],
            segmented_button_fg_color=self.colors["bg_medium"],
            segmented_button_selected_color=self.colors["accent_primary"],
            segmented_button_selected_hover_color=self.colors["accent_secondary"],
            segmented_button_unselected_color=self.colors["bg_medium"],
            segmented_button_unselected_hover_color=self.colors["bg_light"])
        self.tab_view.pack(fill="both", expand=True)

        # Add tabs
        self.tab_view.add("Dashboard")
        self.tab_view.add("Chatbots")
        self.tab_view.add("History")
        self.tab_view.add("Configuration")
        self.tab_view.add("About")

        # Set default tab
        self.tab_view.set("Dashboard")

        # Create tab contents
        self.create_dashboard_tab()
        self.create_chatbots_tab()
        self.create_history_tab()
        self.create_config_tab()
        self.create_about_tab()

    def create_dashboard_tab(self):
        """Create the dashboard tab content"""
        # Main container with gradient background
        dashboard_container = ctk.CTkScrollableFrame(
            self.tab_view.tab("Dashboard"),
            fg_color="transparent"
        )
        dashboard_container.pack(fill="both", expand=True, padx=20, pady=0)  # Reduced top padding

        # Create a grid layout for dashboard widgets
        dashboard_container.columnconfigure(0, weight=2)
        dashboard_container.columnconfigure(1, weight=1)
        dashboard_container.rowconfigure(0, weight=1)
        dashboard_container.rowconfigure(1, weight=1)
        dashboard_container.rowconfigure(2, weight=1)

        # Status panel (top left)
        status_panel = self.create_status_panel(dashboard_container)
        status_panel.grid(row=0, column=0, sticky="nsew", padx=(0, 10), pady=(0, 10))

        # Voice assistant control panel (top right)
        control_panel = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=15,
            border_width=1,
            border_color=self.colors["bg_light"]
        )
        control_panel.grid(row=0, column=1, sticky="nsew", padx=(10, 0), pady=(0, 10))

        # Control panel header with icon
        control_header = ctk.CTkFrame(control_panel, fg_color="transparent", height=50)
        control_header.pack(fill="x", padx=20, pady=(15, 5))

        # Control panel title with icon
        control_title = ctk.CTkLabel(
            control_header,
            text="Voice Assistant",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        control_title.pack(side="left")

        # Start/Stop button with improved styling
        self.toggle_button = ctk.CTkButton(
            control_panel,
            text="Start Voice Assistant",
            command=self.toggle_voice_assistant,
            fg_color=self.colors["status_green"],
            hover_color=self._adjust_color_brightness(self.colors["status_green"], 0.8),
            height=60,
            corner_radius=10,
            font=self.fonts["subtitle"],
            border_width=1,
            border_color=self._adjust_color_brightness(self.colors["status_green"], 1.2)
        )
        self.toggle_button.pack(fill="x", padx=20, pady=15)
        
        # Recording buttons container
        recording_buttons_frame = ctk.CTkFrame(control_panel, fg_color="transparent")
        recording_buttons_frame.pack(fill="x", padx=20, pady=10)

        # Record button
        self.record_button = ctk.CTkButton(
            recording_buttons_frame,
            text="Record",
            command=self.start_manual_recording,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            height=40,
            width=150,
            corner_radius=10
        )
        self.record_button.pack(side="left", fill="x", expand=True, padx=(0, 5))

        # Stop Recording button
        self.stop_record_button = ctk.CTkButton(
            recording_buttons_frame,
            text="Stop Recording",
            command=self.stop_manual_recording,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            height=40,
            width=150,
            corner_radius=10,
            state="disabled"
        )
        self.stop_record_button.pack(side="right", fill="x", expand=True, padx=(5, 0))

        # Add synthesizer bar to show voice detection
        self.synth_bar = SynthesizerBar(control_panel, self.colors, self.fonts)

        # Microphone sensitivity slider
        sensitivity_frame = ctk.CTkFrame(
            control_panel,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        sensitivity_frame.pack(fill="x", padx=20, pady=10)

        sensitivity_label = ctk.CTkLabel(
            sensitivity_frame,
            text="Microphone Sensitivity",
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"]
        )
        sensitivity_label.pack(anchor="w", padx=15, pady=(10, 5))

        sensitivity_control = ctk.CTkFrame(sensitivity_frame, fg_color="transparent")
        sensitivity_control.pack(fill="x", padx=15, pady=(0, 10))

        self.sensitivity_var = ctk.DoubleVar(value=0.5)
        self.sensitivity_slider = ctk.CTkSlider(
            sensitivity_control,
            from_=0.1,
            to=1.0,
            variable=self.sensitivity_var,
            width=200,
            progress_color=self.colors["accent_primary"],
            button_color=self.colors["accent_secondary"],
            button_hover_color=self.colors["accent_primary"]
        )
        self.sensitivity_slider.pack(side="left", fill="x", expand=True, padx=(0, 10))

        self.sensitivity_value = ctk.CTkLabel(
            sensitivity_control,
            text=f"{int(self.sensitivity_var.get() * 100)}%",
            font=self.fonts["small"],
            width=40,
            text_color=self.colors["text_dim"]
        )
        self.sensitivity_value.pack(side="right")

        # Update sensitivity value when slider changes
        def update_sensitivity(*args):
            self.sensitivity_value.configure(text=f"{int(self.sensitivity_var.get() * 100)}%")
            if hasattr(self, 'gain_var'):
                self.gain_var.set(self.sensitivity_var.get())

        self.sensitivity_var.trace_add("write", update_sensitivity)
        
        # Initialize gain variable for level meter
        self.gain_var = ctk.DoubleVar(value=self.sensitivity_var.get())

        # Status indicator with improved styling
        status_frame = ctk.CTkFrame(
            control_panel,
            fg_color=self.colors["bg_light"],
            corner_radius=10,
            height=50
        )
        status_frame.pack(fill="x", padx=20, pady=10)
        status_frame.pack_propagate(False)

        status_label = ctk.CTkLabel(
            status_frame,
            text="Status: Idle",
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"]
        )
        status_label.pack(side="left", padx=15, pady=10)

        self.status_indicator = ctk.CTkFrame(
            status_frame,
            fg_color=self.colors["status_gray"],
            width=20,
            height=20,
            corner_radius=10
        )
        self.status_indicator.pack(side="right", padx=15)

        # Transcription section (middle)
        transcription_frame = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=15,
            border_width=1,
            border_color=self.colors["bg_light"]
        )
        transcription_frame.grid(row=1, column=0, columnspan=2, sticky="nsew", pady=(0, 10))
            
        # Transcription header
        transcription_header = ctk.CTkFrame(transcription_frame, fg_color="transparent", height=50)
        transcription_header.pack(fill="x", padx=20, pady=(15, 5))
        
        transcription_title = ctk.CTkLabel(
            transcription_header,
            text="📝 Transcription",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        transcription_title.pack(side="left")
        
        # Controls frame
        controls = ctk.CTkFrame(transcription_header, fg_color="transparent")
        controls.pack(side="right")
        
        # Clear button
        clear_button = ctk.CTkButton(
            controls,
            text="Clear",
            command=lambda: self.clear_transcription(),
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            width=80
        )
        clear_button.pack(side="right", padx=(0, 10))
        
        # Enter button
        self.enter_button = ctk.CTkButton(
            controls,
            text="Enter",
            command=self.process_transcription,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            width=100,
            state="disabled"
        )
        self.enter_button.pack(side="right")
        
        # Transcription display
        self.transcription_display = ctk.CTkTextbox(
            transcription_frame,
            fg_color=self.colors["bg_light"],
            text_color=self.colors["text_bright"],
            font=self.fonts["large"],
            corner_radius=10,
            border_width=1,
            border_color=self.colors["bg_light"],
            height=150
        )
        self.transcription_display.pack(fill="both", expand=True, padx=20, pady=(5, 20))
        
        # Configure text tags
        self.transcription_display._textbox.tag_configure("timestamp", foreground=self.colors["accent_secondary"])
        self.transcription_display._textbox.tag_configure("transcription", foreground=self.colors["text_bright"])
        
        # Add initial message
        self.transcription_display.configure(state="normal")
        self.transcription_display.insert("end", "Transcribed text will appear here...")
        self.transcription_display.configure(state="disabled")

        # Voice commands section (bottom)
        text_display_frame = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=15,
            border_width=1,
            border_color=self.colors["bg_light"]
        )
        text_display_frame.grid(row=2, column=0, columnspan=2, sticky="nsew")
                
        # Text display header
        text_header = ctk.CTkFrame(text_display_frame, fg_color="transparent", height=50)
        text_header.pack(fill="x", padx=20, pady=(15, 5))
        
        text_title = ctk.CTkLabel(
            text_header,
            text="🔊 Voice Commands",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        text_title.pack(side="left")
        
        # Clear button for text display
        clear_text_button = ctk.CTkButton(
            text_header,
            text="Clear",
            command=lambda: self.clear_text_display(),
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            width=80
        )
        clear_text_button.pack(side="right")
        
        # Text display area
        self.text_display = ctk.CTkTextbox(
            text_display_frame,
            fg_color=self.colors["bg_light"],
            text_color=self.colors["text_bright"],
            font=self.fonts["large"],
            corner_radius=10,
            border_width=1,
            border_color=self.colors["bg_light"],
            height=200
        )
        self.text_display.pack(fill="both", expand=True, padx=20, pady=(5, 20))
        
        # Configure text tags
        self.text_display._textbox.tag_configure("timestamp", foreground=self.colors["accent_secondary"])
        self.text_display._textbox.tag_configure("command", foreground=self.colors["accent_primary"])
        self.text_display._textbox.tag_configure("system", foreground=self.colors["status_blue"])
        
        # Add initial message
        self.text_display.configure(state="normal")
        self.text_display.insert("end", "Voice commands will appear here after starting the voice assistant...")
        self.text_display.configure(state="disabled")

        # Initialize monitor visualization
        self.app.after(500, self.refresh_monitor_visualization)

    def create_synthesizer_bar(self, parent):
        """Create a synthesizer bar to visualize voice detection"""
        # Use the new SynthesizerBar class if available
        try:
            from synthesizer_bar import SynthesizerBar
            self.synth_bar = SynthesizerBar(parent, self.colors, self.fonts)
            return
        except ImportError:
            logging.warning(
                "SynthesizerBar class not found, using fallback implementation")

        # Fallback implementation
        synth_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10,
            height=80
        )
        synth_frame.pack(fill="x", padx=20, pady=10)

        # Synthesizer label
        synth_label = ctk.CTkLabel(
            synth_frame,
            text="Voice Detection",
            font=self.fonts["normal"],
            text_color=self.colors["text_bright"]
        )
        synth_label.pack(anchor="w", padx=15, pady=(10, 5))

        # Create level meter canvas
        self.level_canvas = ctk.CTkCanvas(
            synth_frame,
            bg=self.colors["bg_dark"],
            highlightthickness=0,
            height=30
        )
        self.level_canvas.pack(fill="x", padx=15, pady=(0, 10))

        # Initialize level meter with zero level
        self.app.after(100, lambda: self._update_level_meter(0))

    def create_chatbots_tab(self):
        """Create the chatbots tab content"""
        # Main container
        chatbots_container = ctk.CTkFrame(
            self.tab_view.tab("Chatbots"),
            fg_color="transparent"
        )
        chatbots_container.pack(fill="both", expand=True, padx=20, pady=20)

        # Title and add button row
        title_frame = ctk.CTkFrame(chatbots_container, fg_color="transparent")
        title_frame.pack(fill="x", pady=(0, 15))

        # Title with icon
        title_label = ctk.CTkLabel(
            title_frame,
            text="Chatbot Management",
            font=ctk.CTkFont(size=24, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title_label.pack(side="left")

        # Add chatbot button
        add_button = ctk.CTkButton(
            title_frame,
            text="Add New Chatbot",
            command=self.show_add_chatbot_dialog,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            width=120
        )
        add_button.pack(side="right")

        # Search frame
        search_frame = ctk.CTkFrame(
            chatbots_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=10,
            height=50
        )
        search_frame.pack(fill="x", pady=(0, 15))
        search_frame.pack_propagate(False)

        # Search icon
        search_icon = ctk.CTkLabel(
            search_frame,
            text="🔍",
            font=ctk.CTkFont(size=16),
            width=30
        )
        search_icon.pack(side="left", padx=(15, 0))

        # Search entry
        self.search_var = ctk.StringVar()
        self.search_var.trace_add(
            "write", lambda *args: self.filter_chatbot_list())
        search_entry = ctk.CTkEntry(
            search_frame,
            placeholder_text="Search chatbots...",
            textvariable=self.search_var,
            border_width=0,
            fg_color="transparent",
            height=40
        )
        search_entry.pack(side="left", fill="x", expand=True, padx=10)

        # Chatbot list container
        self.chatbot_list_frame = ctk.CTkScrollableFrame(
            chatbots_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        self.chatbot_list_frame.pack(fill="both", expand=True)

        # Refresh chatbot list
        self.refresh_chatbots()

    def create_about_tab(self):
        """Create the about tab content"""
        # Main container
        about_container = ctk.CTkFrame(
            self.tab_view.tab("About"),
            fg_color="transparent"
        )
        about_container.pack(fill="both", expand=True, padx=20, pady=20)

        # Create a scrollable frame for the about content
        about_scroll = ctk.CTkScrollableFrame(
            about_container,
            fg_color="transparent"
        )
        about_scroll.pack(fill="both", expand=True)

        # Logo and title
        logo_frame = ctk.CTkFrame(about_scroll, fg_color="transparent")
        logo_frame.pack(fill="x", pady=(0, 20))

        # App title
        title_label = ctk.CTkLabel(
            logo_frame,
            text="DragonVoice",
            font=ctk.CTkFont(size=32, weight="bold"),
            text_color=self.colors["accent_primary"]
        )
        title_label.pack(pady=(0, 5))

        # Version
        version_label = ctk.CTkLabel(
            logo_frame,
            text="Version 2.0",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"]
        )
        version_label.pack()

        # Description
        description_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        description_frame.pack(fill="x", pady=10, padx=5)

        description_label = ctk.CTkLabel(
            description_frame,
            text="DragonVoice is an advanced voice assistant that integrates with multiple AI chatbots.\n"
            "It provides a seamless voice interface for interacting with AI models and controlling your computer.",
            font=ctk.CTkFont(
                size=14),
            text_color=self.colors["text_normal"],
            wraplength=600,
            justify="left")
        description_label.pack(padx=20, pady=20)

        # Features
        features_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        features_frame.pack(fill="x", pady=10, padx=5)

        features_title = ctk.CTkLabel(
            features_frame,
            text="Key Features",
            font=ctk.CTkFont(size=18, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        features_title.pack(anchor="w", padx=20, pady=(15, 10))

        features = [
            "🎤 Voice recognition with OpenAI Whisper",
            "🤖 Multiple AI chatbot integrations",
            "⌨️ System control through voice commands",
            "📊 Real-time system monitoring",
            "🎨 Customizable themes and appearance",
            "🔧 Advanced configuration options"
        ]

        for feature in features:
            feature_label = ctk.CTkLabel(
                features_frame,
                text=feature,
                font=ctk.CTkFont(size=14),
                text_color=self.colors["text_normal"],
                anchor="w"
            )
            feature_label.pack(anchor="w", padx=20, pady=5)

        # Credits
        credits_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        credits_frame.pack(fill="x", pady=10, padx=5)

        credits_title = ctk.CTkLabel(
            credits_frame,
            text="Credits",
            font=ctk.CTkFont(size=18, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        credits_title.pack(anchor="w", padx=20, pady=(15, 10))

        credits_label = ctk.CTkLabel(
            credits_frame,
            text="Developed by: DragonVoice Team\n"
                 "UI Framework: CustomTkinter\n"
                 "Voice Recognition: OpenAI Whisper\n"
                 "Special thanks to all contributors and testers",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            justify="left"
        )
        credits_label.pack(anchor="w", padx=20, pady=(0, 15))

        # Links
        links_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        links_frame.pack(fill="x", pady=10, padx=5)

        links_title = ctk.CTkLabel(
            links_frame,
            text="Links",
            font=ctk.CTkFont(size=18, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        links_title.pack(anchor="w", padx=20, pady=(15, 10))

        # Function to open links
        def open_link(url):
            import webbrowser
            webbrowser.open(url)

        # Website link
        website_button = ctk.CTkButton(
            links_frame,
            text="Visit Website",
            command=lambda: open_link("https://dragonvoice.ai"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        website_button.pack(anchor="w", padx=20, pady=5)

        # Documentation link
        docs_button = ctk.CTkButton(
            links_frame,
            text="Documentation",
            command=lambda: open_link("https://docs.dragonvoice.ai"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        docs_button.pack(anchor="w", padx=20, pady=5)

        # GitHub link
        github_button = ctk.CTkButton(
            links_frame,
            text="GitHub Repository",
            command=lambda: open_link("https://github.com/dragonvoice/dragonvoice"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"])
        github_button.pack(anchor="w", padx=20, pady=(5, 15))

    def create_settings_advanced_tab(self, parent):
        """Create the advanced settings tab content"""
        # Main container
        container = ctk.CTkFrame(parent, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)

        # Logging settings section
        logging_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        logging_frame.pack(fill="x", pady=(0, 15))

        # Section title
        logging_title = ctk.CTkLabel(
            logging_frame,
            text="Logging Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        logging_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Log level
        log_level_frame = ctk.CTkFrame(logging_frame, fg_color="transparent")
        log_level_frame.pack(fill="x", padx=15, pady=5)

        log_level_label = ctk.CTkLabel(
            log_level_frame,
            text="Log Level",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        log_level_label.pack(side="left")

        self.log_level_var = ctk.StringVar(value="INFO")
        log_level_dropdown = ctk.CTkOptionMenu(
            log_level_frame,
            values=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
            variable=self.log_level_var,
            width=200
        )
        log_level_dropdown.pack(side="left", padx=10)

        # Enable file logging
        file_logging_frame = ctk.CTkFrame(
            logging_frame, fg_color="transparent")
        file_logging_frame.pack(fill="x", padx=15, pady=5)

        file_logging_label = ctk.CTkLabel(
            file_logging_frame,
            text="File Logging",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        file_logging_label.pack(side="left")

        self.file_logging_var = ctk.BooleanVar(value=True)
        file_logging_switch = ctk.CTkSwitch(
            file_logging_frame,
            text="",
            variable=self.file_logging_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        file_logging_switch.pack(side="left", padx=10)

        # Performance settings section
        performance_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        performance_frame.pack(fill="x", pady=(0, 15))

        # Section title
        performance_title = ctk.CTkLabel(
            performance_frame,
            text="Performance Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        performance_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Hardware acceleration
        hardware_frame = ctk.CTkFrame(
            performance_frame, fg_color="transparent")
        hardware_frame.pack(fill="x", padx=15, pady=5)

        hardware_label = ctk.CTkLabel(
            hardware_frame,
            text="Hardware Acceleration",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        hardware_label.pack(side="left")

        self.hardware_var = ctk.BooleanVar(value=True)
        hardware_switch = ctk.CTkSwitch(
            hardware_frame,
            text="",
            variable=self.hardware_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        hardware_switch.pack(side="left", padx=10)

        # Thread count
        thread_frame = ctk.CTkFrame(performance_frame, fg_color="transparent")
        thread_frame.pack(fill="x", padx=15, pady=5)

        thread_label = ctk.CTkLabel(
            thread_frame,
            text="Worker Threads",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        thread_label.pack(side="left")

        self.thread_var = ctk.IntVar(value=4)
        thread_slider = ctk.CTkSlider(
            thread_frame,
            from_=1,
            to=16,
            number_of_steps=15,
            variable=self.thread_var,
            width=200
        )
        thread_slider.pack(side="left", padx=10)

        thread_value = ctk.CTkLabel(
            thread_frame,
            textvariable=self.thread_var,
            width=30
        )
        thread_value.pack(side="left", padx=5)

        # Memory limit
        memory_frame = ctk.CTkFrame(performance_frame, fg_color="transparent")
        memory_frame.pack(fill="x", padx=15, pady=5)

        memory_label = ctk.CTkLabel(
            memory_frame,
            text="Memory Limit (MB)",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        memory_label.pack(side="left")

        self.memory_var = ctk.IntVar(value=1024)
        memory_slider = ctk.CTkSlider(
            memory_frame,
            from_=256,
            to=4096,
            number_of_steps=15,
            variable=self.memory_var,
            width=200
        )
        memory_slider.pack(side="left", padx=10)

        memory_value = ctk.CTkLabel(
            memory_frame,
            textvariable=self.memory_var,
            width=50
        )
        memory_value.pack(side="left", padx=5)

        # Reset button
        reset_button = ctk.CTkButton(
            container,
            text="Reset to Defaults",
            command=lambda: self.reset_advanced_settings(),
            fg_color=self.colors["bg_medium"],
            hover_color=self.colors["bg_light"],
            width=150
        )
        reset_button.pack(anchor="e", pady=10)

        return container

    def reset_advanced_settings(self):
        """Reset advanced settings to defaults"""
        self.log_level_var.set("INFO")
        self.file_logging_var.set(True)
        self.hardware_var.set(True)
        self.thread_var.set(4)
        self.memory_var.set(1024)
        self.update_status("Advanced settings reset to defaults")

    def apply_theme(self, theme_name):
        """Apply the selected theme"""
        if theme_name in self.color_schemes:
            self.colors = self.color_schemes[theme_name]
            self.config["theme"] = theme_name
            self.save_configuration(show_notification=False)
            # Refresh UI with new theme
            self.setup_theme()
            self.refresh_ui()

    def show_add_chatbot_dialog(self):
        """Show dialog to add a new chatbot"""
        dialog = ctk.CTkToplevel(self.app)
        dialog.title("Add New Chatbot")
        dialog.geometry("400x500")
        dialog.transient(self.app)
        dialog.grab_set()

        # Create form fields
        name_label = ctk.CTkLabel(
            dialog,
            text="Chatbot Name",
            text_color=self.colors["text_bright"]
        )
        name_label.pack(anchor="w", padx=20, pady=(20, 0))

        name_entry = ctk.CTkEntry(dialog, width=360)
        name_entry.pack(anchor="w", padx=20, pady=(0, 10))

        type_label = ctk.CTkLabel(
            dialog,
            text="Chatbot Type",
            text_color=self.colors["text_bright"]
        )
        type_label.pack(anchor="w", padx=20, pady=(10, 0))

        type_var = ctk.StringVar(value="GPT")
        type_dropdown = ctk.CTkOptionMenu(
            dialog,
            values=["GPT", "Claude", "Gemini", "Custom"],
            variable=type_var,
            width=360
        )
        type_dropdown.pack(anchor="w", padx=20, pady=(0, 10))

        api_key_label = ctk.CTkLabel(
            dialog,
            text="API Key",
            text_color=self.colors["text_bright"]
        )
        api_key_label.pack(anchor="w", padx=20, pady=(10, 0))

        api_key_entry = ctk.CTkEntry(dialog, width=360, show="*")
        api_key_entry.pack(anchor="w", padx=20, pady=(0, 10))

        # Add chatbot button
        def add_chatbot():
            name = name_entry.get()
            chatbot_type = type_var.get()
            api_key = api_key_entry.get()

            if name and chatbot_type and api_key:
                # Add to config
                if "chatbots" not in self.config:
                    self.config["chatbots"] = {}

                self.config["chatbots"][name] = {
                    "type": chatbot_type,
                    "api_key": api_key,
                    "status": "Ready",
                    "color": self.colors["accent_primary"],
                    "icon": "🤖"
                }

                self.save_configuration()
                self.refresh_chatbot_list()
                dialog.destroy()
            else:
                # Show error
                error_label.configure(text="Please fill in all fields")

        add_button = ctk.CTkButton(
            dialog,
            text="Add Chatbot",
            command=add_chatbot,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        add_button.pack(anchor="center", pady=20)

        # Error label
        error_label = ctk.CTkLabel(
            dialog,
            text="",
            text_color=self.colors["error"]
        )
        error_label.pack(anchor="center")

    def refresh_chatbot_list(self):
        """Refresh the list of chatbots in settings"""
        # Clear existing items
        for widget in self.chatbot_list_frame.winfo_children():
            widget.destroy()

        # Add header
        header = ctk.CTkFrame(
            self.chatbot_list_frame,
            fg_color="transparent"
        )
        header.pack(fill="x", padx=15, pady=5)

        ctk.CTkLabel(
            header,
            text="Name",
            font=ctk.CTkFont(weight="bold"),
            text_color=self.colors["text_bright"],
            width=100
        ).pack(side="left")

        ctk.CTkLabel(
            header,
            text="Type",
            font=ctk.CTkFont(weight="bold"),
            text_color=self.colors["text_bright"],
            width=100
        ).pack(side="left")

        ctk.CTkLabel(
            header,
            text="Status",
            font=ctk.CTkFont(weight="bold"),
            text_color=self.colors["text_bright"],
            width=100
        ).pack(side="left")

        # Add chatbots
        for name, config in self.config.get("chatbots", {}).items():
            self.add_chatbot_list_item(name, config)

    def add_chatbot_list_item(self, name, config):
        """Add a single chatbot item to the list"""
        # Create item frame with hover effect
        item = ctk.CTkFrame(
            self.chatbot_list_frame,
            fg_color=self.colors["bg_dark"],
            corner_radius=10,
            height=70
        )
        item.pack(fill="x", padx=5, pady=5)
        item.pack_propagate(False)

        # Add hover effect
        def on_enter(e):
            item.configure(fg_color=self.colors["bg_light"])

        def on_leave(e):
            item.configure(fg_color=self.colors["bg_dark"])

        item.bind("<Enter>", on_enter)
        item.bind("<Leave>", on_leave)

        # Icon and name container
        info_frame = ctk.CTkFrame(
            item,
            fg_color="transparent"
        )
        info_frame.pack(side="left", fill="y", padx=10)

        # Icon with colored background
        icon_frame = ctk.CTkFrame(
            info_frame,
            fg_color=config.get("color", self.colors["accent_primary"]),
            width=40,
            height=40,
            corner_radius=20
        )
        icon_frame.pack(side="left", padx=(0, 10))
        icon_frame.pack_propagate(False)

        icon_label = ctk.CTkLabel(
            icon_frame,
            text=config.get("icon", "🤖"),
            font=ctk.CTkFont(size=20)
        )
        icon_label.place(relx=0.5, rely=0.5, anchor="center")

        # Name and type
        text_frame = ctk.CTkFrame(
            info_frame,
            fg_color="transparent"
        )
        text_frame.pack(side="left", fill="y")

        name_label = ctk.CTkLabel(
            text_frame,
            text=name,
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        name_label.pack(anchor="w")

        type_label = ctk.CTkLabel(
            text_frame,
            text=config.get("type", "Unknown"),
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        type_label.pack(anchor="w")

        # Status indicator
        status_color = self.colors["status_green"] if config.get(
            "status") == "Ready" else self.colors["status_red"]
        status_frame = ctk.CTkFrame(
            item,
            fg_color="transparent"
        )
        status_frame.pack(side="right", fill="y", padx=10)

        status_dot = ctk.CTkLabel(
            status_frame,
            text="●",
            font=ctk.CTkFont(size=20),
            text_color=status_color
        )
        status_dot.pack(side="right", padx=5)

        status_label = ctk.CTkLabel(
            status_frame,
            text=config.get("status", "Unknown"),
            font=ctk.CTkFont(size=12),
            text_color=status_color
        )
        status_label.pack(side="right")

        # Make the entire item clickable
        item.bind(
            "<Button-1>",
            lambda e: self.show_chatbot_settings(
                name,
                config))

    def delete_chatbot(self, name):
        """Delete a chatbot from the configuration"""
        if name in self.config.get("chatbots", {}):
            del self.config["chatbots"][name]
            self.save_configuration()
            self.refresh_chatbot_list()
            # Also refresh the dashboard
            self.add_sample_chatbot_cards()

    def run(self):
        """Run the application main loop"""
        try:
            # Log startup
            logging.info("Starting DragonVoice application")

            # Update status
            self.update_status("Application started successfully")

            # Start the main event loop
            self.app.mainloop()

        except Exception as e:
            logging.error(f"Error in main loop: {str(e)}")
            raise

    def create_help_getting_started(self, parent):
        """Create the getting started help content"""
        # Welcome section
        welcome_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        welcome_frame.pack(fill="x", padx=20, pady=10)

        welcome_label = ctk.CTkLabel(
            welcome_frame,
            text="Welcome to DragonVoice",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        welcome_label.pack(anchor="w", padx=15, pady=(10, 5))

        welcome_text = ctk.CTkTextbox(
            welcome_frame,
            height=100,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        welcome_text.pack(fill="x", padx=15, pady=(0, 10))
        welcome_text.insert(
            "1.0",
            """DragonVoice is a powerful voice-controlled interface for interacting with multiple AI chatbots. This guide will help you get started with the basic features and setup.""")
        welcome_text.configure(state="disabled")

        # Quick Start Guide
        quickstart_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        quickstart_frame.pack(fill="x", padx=20, pady=10)

        quickstart_label = ctk.CTkLabel(
            quickstart_frame,
            text="Quick Start Guide",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        quickstart_label.pack(anchor="w", padx=15, pady=(10, 5))

        steps_text = ctk.CTkTextbox(
            quickstart_frame,
            height=200,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        steps_text.pack(fill="x", padx=15, pady=(0, 10))
        steps_text.insert("1.0", """1. Configure Your Chatbots
• Click the Settings button (⚙️) in the top right
• Go to the Chatbots tab
• Click "Add New Chatbot" and enter your API keys

2. Start Voice Assistant
• Click the "Start Voice Assistant" button in the header
• Wait for the status to show "Ready"
• Say your wake word (default: "Hey Dragon")

3. Issue Commands
• After the wake word, speak your command
• Example: "Ask what are the latest treatments for hypertension"
• The command will be sent to the appropriate chatbot

4. View Responses
• Responses appear in the chatbot windows
• You can interact with multiple chatbots simultaneously
• Use voice commands to switch between chatbots""")
        steps_text.configure(state="disabled")

    def create_help_voice_commands(self, parent):
        """Create the voice commands help content"""
        # Available Commands
        commands_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        commands_frame.pack(fill="x", padx=20, pady=10)

        commands_label = ctk.CTkLabel(
            commands_frame,
            text="Available Voice Commands",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        commands_label.pack(anchor="w", padx=15, pady=(10, 5))

        commands_text = ctk.CTkTextbox(
            commands_frame,
            height=400,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        commands_text.pack(fill="x", padx=15, pady=(0, 10))
        commands_text.insert("1.0", """Basic Commands:
• "Hey Dragon" - Wake word to start listening
• "Ask [question]" - Send a question to the active chatbot
• "Switch to [chatbot name]" - Change the active chatbot
• "Stop listening" - Deactivate voice recognition
• "Clear chat" - Clear the current conversation

Chatbot Control:
• "New conversation" - Start a fresh chat session
• "Save conversation" - Save the current chat history
• "Load conversation" - Restore a previous chat session
• "Export as PDF" - Export the conversation to PDF

Window Management:
• "Maximize window" - Expand the current chatbot window
• "Minimize window" - Minimize the current chatbot window
• "Arrange windows" - Organize all chatbot windows
• "Close window" - Close the current chatbot window

System Commands:
• "Open settings" - Show the settings dialog
• "Show help" - Display this help window
• "Check status" - Report system status
• "Exit program" - Close DragonVoice

Tips:
• Speak clearly and at a normal pace
• Wait for the "Listening..." indicator
• You can customize the wake word in settings
• Commands are case-insensitive""")
        commands_text.configure(state="disabled")

    def create_help_chatbots(self, parent):
        """Create the chatbots help content"""
        # Chatbot Overview
        overview_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        overview_frame.pack(fill="x", padx=20, pady=10)

        overview_label = ctk.CTkLabel(
            overview_frame,
            text="Working with Chatbots",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        overview_label.pack(anchor="w", padx=15, pady=(10, 5))

        overview_text = ctk.CTkTextbox(
            overview_frame,
            height=300,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        overview_text.pack(fill="x", padx=15, pady=(0, 10))
        overview_text.insert(
            "1.0", """DragonVoice supports multiple AI chatbots, allowing you to:
• Interact with different AI models simultaneously
• Compare responses across different chatbots
• Use specialized models for specific tasks
• Maintain separate conversation contexts

Supported Chatbots:
1. GPT (OpenAI)
   • Requires OpenAI API key
   • Supports GPT-3.5 and GPT-4
   • Best for general knowledge and coding

2. Claude (Anthropic)
   • Requires Anthropic API key
   • Excellent for analysis and writing
   • Strong ethical considerations

3. Gemini (Google)
   • Requires Google API key
   • Good at mathematical reasoning
   • Supports image understanding

4. Custom Chatbots
   • Add your own API integrations
   • Configure custom endpoints
   • Define specialized behaviors

Setting Up Chatbots:
1. Obtain API keys from providers
2. Add chatbots in Settings > Chatbots
3. Configure any special parameters
4. Test the connection

Best Practices:
• Keep API keys secure
• Monitor usage and costs
• Regular backup conversations
• Update chatbot configs as needed""")
        overview_text.configure(state="disabled")

    def create_help_troubleshooting(self, parent):
        """Create the troubleshooting help content"""
        # Common Issues
        issues_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        issues_frame.pack(fill="x", padx=20, pady=10)

        issues_label = ctk.CTkLabel(
            issues_frame,
            text="Common Issues",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        issues_label.pack(anchor="w", padx=15, pady=(10, 5))

        issues_text = ctk.CTkTextbox(
            issues_frame,
            height=400,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        issues_text.pack(fill="x", padx=15, pady=(0, 10))
        issues_text.insert("1.0", """Voice Recognition Issues:
1. Microphone Not Detected
   • Check microphone connections
   • Verify Windows permissions
   • Select correct input device in settings
   • Try restarting the application

2. Poor Recognition Accuracy
   • Adjust microphone sensitivity
   • Reduce background noise
   • Speak clearly and at normal pace
   • Check for latest updates

Chatbot Connection Problems:
1. API Key Errors
   • Verify API key is valid
   • Check for sufficient credits
   • Ensure correct API endpoint
   • Look for error messages in logs

2. Slow Responses
   • Check internet connection
   • Verify server status
   • Adjust timeout settings
   • Consider upgrading API tier

Interface Issues:
1. Display Problems
   • Update graphics drivers
   • Check resolution settings
   • Try different theme
   • Restart application

2. Performance Issues
   • Close unused applications
   • Check CPU/memory usage
   • Reduce number of active chatbots
   • Clear conversation history

Getting Help:
• Check application logs
• Visit our support forum
• Submit bug reports
• Contact technical support""")
        issues_text.configure(state="disabled")

    def create_help_about(self, parent):
        """Create the about help content"""
        # About Information
        about_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        about_frame.pack(fill="x", padx=20, pady=10)

        # Logo/Icon placeholder
        logo_label = ctk.CTkLabel(
            about_frame,
            text="🐉",
            font=ctk.CTkFont(size=48),
            text_color=self.colors["accent_primary"]
        )
        logo_label.pack(anchor="center", pady=20)

        # App title
        title_label = ctk.CTkLabel(
            about_frame,
            text="DragonVoice",
            font=ctk.CTkFont(size=24, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title_label.pack(anchor="center")

        # Version
        version_label = ctk.CTkLabel(
            about_frame,
            text="Version 2.0",
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        version_label.pack(anchor="center", pady=(0, 20))

        # Description
        description_text = ctk.CTkTextbox(
            about_frame,
            height=100,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        description_text.pack(fill="x", padx=15, pady=(0, 10))
        description_text.insert(
            "1.0",
            """DragonVoice is a powerful voice-controlled interface for medical professionals to interact with multiple AI chatbots simultaneously. It provides a seamless way to access and compare AI insights while maintaining focus on patient care.""")
        description_text.configure(state="disabled")

        # Credits
        credits_label = ctk.CTkLabel(
            about_frame,
            text="Credits",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        credits_label.pack(anchor="w", padx=15, pady=(10, 5))

        credits_text = ctk.CTkTextbox(
            about_frame,
            height=100,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        credits_text.pack(fill="x", padx=15, pady=(0, 10))
        credits_text.insert("1.0", """• OpenAI Whisper - Speech Recognition
• CustomTkinter - GUI Framework
• Various AI Models - Chatbot Integration
• Open Source Community - Libraries and Tools

Special thanks to all contributors and users who have helped improve DragonVoice.""")
        credits_text.configure(state="disabled")

        # Links
        links_frame = ctk.CTkFrame(
            about_frame,
            fg_color="transparent"
        )
        links_frame.pack(fill="x", padx=15, pady=10)

        website_button = ctk.CTkButton(
            links_frame,
            text="Website",
            width=100,
            command=lambda: webbrowser.open("https://dragonvoice.ai")
        )
        website_button.pack(side="left", padx=5)

        docs_button = ctk.CTkButton(
            links_frame,
            text="Documentation",
            width=100,
            command=lambda: webbrowser.open("https://docs.dragonvoice.ai")
        )
        docs_button.pack(side="left", padx=5)

        github_button = ctk.CTkButton(
            links_frame,
            text="GitHub",
            width=100,
            command=lambda: webbrowser.open("https://github.com/dragonvoice")
        )
        github_button.pack(side="left", padx=5)

    def toggle_theme(self):
        """Toggle between light and dark themes"""
        try:
            # Get current appearance mode
            current_mode = ctk.get_appearance_mode()

            # Toggle mode
            new_mode = "Light" if current_mode == "Dark" else "Dark"
            ctk.set_appearance_mode(new_mode)

            # Update status
            self.update_status(f"Theme changed to {new_mode} mode")

        except Exception as e:
            logging.error(f"Error toggling theme: {str(e)}")
            self.update_status(f"Failed to toggle theme: {str(e)}", "error")

    def start_system_monitoring(self):
        """Start monitoring system resources"""
        try:
            # Initialize status variables if they don't exist
            if not hasattr(self, 'cpu_usage'):
                self.cpu_usage = 0
            if not hasattr(self, 'memory_usage'):
                self.memory_usage = 0
            if not hasattr(self, 'disk_usage'):
                self.disk_usage = 0
            if not hasattr(self, 'voice_status'):
                self.voice_status = "Idle"

            def update_system_info():
                try:
                    # Update CPU usage
                    self.cpu_usage = psutil.cpu_percent(interval=None)

                    # Update memory usage
                    memory = psutil.virtual_memory()
                    self.memory_usage = memory.percent

                    # Update disk usage
                    disk = psutil.disk_usage('/')
                    self.disk_usage = disk.percent

                    # Update status indicators if they exist
                    for i, (value, color) in enumerate([
                        (self.cpu_usage, self.get_resource_color(self.cpu_usage)),
                        (self.memory_usage, self.get_resource_color(self.memory_usage)),
                        (self.disk_usage, self.get_resource_color(self.disk_usage))
                    ]):
                        status_indicator = getattr(self, f'status_indicator_{i}', None)
                        status_value = getattr(self, f'status_value_{i}', None)
                        if status_indicator and status_value:
                            status_indicator.configure(fg_color=color)
                            status_value.configure(
                                text=f"{value:.1f}%",
                                text_color=self.colors["text_bright"]
                            )

                    # Update voice status
                    if hasattr(self, 'recording_active'):
                        voice_status = "Recording" if self.recording_active else "Idle"
                        status_color = self.colors["status_green"] if self.recording_active else self.colors["status_gray"]
                        
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=status_color)
                        if hasattr(self, 'status_value_3'):
                            self.status_value_3.configure(
                                text=voice_status,
                                text_color=self.colors["text_bright"]
                            )

                    # Schedule next update
                    self.app.after(1000, update_system_info)

                except Exception as e:
                    logging.error(f"Error updating system info: {str(e)}")
                    # Try again later
                    self.app.after(5000, update_system_info)

            # Start the update loop
            update_system_info()

        except Exception as e:
            logging.error(f"Error starting system monitoring: {str(e)}")

    def get_resource_color(self, value):
        """Get color based on resource usage percentage"""
        if value < 60:
            return self.colors["status_green"]  # Green for normal
        elif value < 80:
            return self.colors["status_yellow"]  # Yellow for warning
        else:
            return self.colors["status_red"]  # Red for critical

    def filter_chatbot_list(self):
        """Filter the chatbot list based on search text"""
        search_text = self.search_var.get().lower()

        # Clear existing items
        for widget in self.chatbot_list_frame.winfo_children():
            widget.destroy()

        # Add filtered chatbots
        for name, config in self.config.get("chatbots", {}).items():
            if search_text in name.lower():
                self.add_chatbot_list_item(name, config)

    def show_chatbot_settings(self, name, config):
        """Show settings for the selected chatbot"""
        # Update header
        self.selected_chatbot_label.configure(text=f"Settings: {name}")

        # Clear existing settings
        for widget in self.settings_content.winfo_children():
            widget.destroy()

        # Create settings sections
        sections = [
            ("General Settings", self.create_general_settings),
            ("API Configuration", self.create_api_settings),
            ("Model Settings", self.create_model_settings),
            ("Response Settings", self.create_response_settings),
            ("Advanced Options", self.create_advanced_settings)
        ]

        for title, create_func in sections:
            section = create_func(self.settings_content, name, config)
            section.pack(fill="x", padx=10, pady=5)

    def create_general_settings(self, parent, name, config):
        """Create general settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="General Settings",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # Display name
        name_frame = ctk.CTkFrame(frame, fg_color="transparent")
        name_frame.pack(fill="x", padx=15, pady=5)

        name_label = ctk.CTkLabel(
            name_frame,
            text="Display Name:",
            width=120,
            anchor="w"
        )
        name_label.pack(side="left")

        name_entry = ctk.CTkEntry(
            name_frame,
            width=200,
            placeholder_text="Enter display name"
        )
        name_entry.insert(0, name)
        name_entry.pack(side="left", padx=10)

        # Icon selection
        icon_frame = ctk.CTkFrame(frame, fg_color="transparent")
        icon_frame.pack(fill="x", padx=15, pady=5)

        icon_label = ctk.CTkLabel(
            icon_frame,
            text="Icon:",
            width=120,
            anchor="w"
        )
        icon_label.pack(side="left")

        icons = ["🤖", "🧠", "💡", "🔍", "💬", "🌐", "📚", "⚡"]
        icon_var = ctk.StringVar(value=config.get("icon", "🤖"))

        for icon in icons:
            btn = ctk.CTkButton(
                icon_frame,
                text=icon,
                width=40,
                height=40,
                corner_radius=20,
                fg_color=self.colors["bg_medium"] if icon != icon_var.get() else self.colors["accent_primary"],
                hover_color=self.colors["accent_secondary"],
                command=lambda i=icon: [
                    icon_var.set(i),
                    self.update_chatbot_config(
                        name,
                        "icon",
                        i)])
            btn.pack(side="left", padx=2)

        return frame

    def create_api_settings(self, parent, name, config):
        """Create API settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="API Configuration",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # API Key
        key_frame = ctk.CTkFrame(frame, fg_color="transparent")
        key_frame.pack(fill="x", padx=15, pady=5)

        key_label = ctk.CTkLabel(
            key_frame,
            text="API Key:",
            width=120,
            anchor="w"
        )
        key_label.pack(side="left")

        key_entry = ctk.CTkEntry(
            key_frame,
            width=300,
            placeholder_text="Enter API key",
            show="*"
        )
        key_entry.insert(0, config.get("api_key", ""))
        key_entry.pack(side="left", padx=10)

        show_key = ctk.CTkButton(
            key_frame, text="👁️", width=40, command=lambda: key_entry.configure(
                show="" if key_entry.cget("show") == "*" else "*"))
        show_key.pack(side="left")

        # API Endpoint
        endpoint_frame = ctk.CTkFrame(frame, fg_color="transparent")
        endpoint_frame.pack(fill="x", padx=15, pady=5)

        endpoint_label = ctk.CTkLabel(
            endpoint_frame,
            text="API Endpoint:",
            width=120,
            anchor="w"
        )
        endpoint_label.pack(side="left")

        endpoint_entry = ctk.CTkEntry(
            endpoint_frame,
            width=300,
            placeholder_text="Enter API endpoint"
        )
        endpoint_entry.insert(0, config.get("endpoint", ""))
        endpoint_entry.pack(side="left", padx=10)

        # Test connection button
        test_button = ctk.CTkButton(
            frame,
            text="Test Connection",
            command=lambda: self.test_chatbot_connection(name),
            fg_color=self.colors["accent_secondary"]
        )
        test_button.pack(anchor="e", padx=15, pady=10)

        return frame

    def create_model_settings(self, parent, name, config):
        """Create model settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="Model Settings",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # Model selection
        model_frame = ctk.CTkFrame(frame, fg_color="transparent")
        model_frame.pack(fill="x", padx=15, pady=5)

        model_label = ctk.CTkLabel(
            model_frame,
            text="Model:",
            width=120,
            anchor="w"
        )
        model_label.pack(side="left")

        models = {
            "GPT": ["gpt-4", "gpt-3.5-turbo", "gpt-3.5-turbo-16k"],
            "Claude": ["claude-2", "claude-instant"],
            "Gemini": ["gemini-pro", "gemini-pro-vision"],
            "Custom": ["custom-model"]
        }

        model_type = config.get("type", "GPT")
        model_var = ctk.StringVar(
            value=config.get(
                "model", models[model_type][0]))

        model_combo = ctk.CTkComboBox(
            model_frame,
            width=200,
            values=models[model_type],
            variable=model_var,
            state="readonly"
        )
        model_combo.pack(side="left", padx=10)

        # Temperature
        temp_frame = ctk.CTkFrame(frame, fg_color="transparent")
        temp_frame.pack(fill="x", padx=15, pady=5)

        temp_label = ctk.CTkLabel(
            temp_frame,
            text="Temperature:",
            width=120,
            anchor="w"
        )
        temp_label.pack(side="left")

        temp_var = ctk.DoubleVar(value=config.get("temperature", 0.7))
        temp_slider = ctk.CTkSlider(
            temp_frame,
            from_=0.0,
            to=2.0,
            variable=temp_var,
            width=200
        )
        temp_slider.pack(side="left", padx=10)

        temp_value = ctk.CTkLabel(
            temp_frame,
            textvariable=temp_var,
            width=50
        )
        temp_value.pack(side="left")

        return frame

    def create_response_settings(self, parent, name, config):
        """Create response settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="Response Settings",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # Max tokens
        tokens_frame = ctk.CTkFrame(frame, fg_color="transparent")
        tokens_frame.pack(fill="x", padx=15, pady=5)

        tokens_label = ctk.CTkLabel(
            tokens_frame,
            text="Max Tokens:",
            width=120,
            anchor="w"
        )
        tokens_label.pack(side="left")

        tokens_var = ctk.IntVar(value=config.get("max_tokens", 2000))
        tokens_slider = ctk.CTkSlider(
            tokens_frame,
            from_=100,
            to=4000,
            variable=tokens_var,
            width=200
        )
        tokens_slider.pack(side="left", padx=10)

        tokens_value = ctk.CTkLabel(
            tokens_frame,
            textvariable=tokens_var,
            width=50
        )
        tokens_value.pack(side="left")

        # Response format
        format_frame = ctk.CTkFrame(frame, fg_color="transparent")
        format_frame.pack(fill="x", padx=15, pady=5)

        format_label = ctk.CTkLabel(
            format_frame,
            text="Format:",
            width=120,
            anchor="w"
        )
        format_label.pack(side="left")

        format_var = ctk.StringVar(value=config.get("format", "markdown"))
        formats = ["markdown", "html", "plain"]

        format_combo = ctk.CTkComboBox(
            format_frame,
            width=200,
            values=formats,
            variable=format_var,
            state="readonly"
        )
        format_combo.pack(side="left", padx=10)

        return frame

    def create_advanced_settings(self, parent, name, config):
        """Create advanced settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="Advanced Options",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # System prompt
        prompt_label = ctk.CTkLabel(
            frame,
            text="System Prompt:",
            anchor="w"
        )
        prompt_label.pack(anchor="w", padx=15, pady=(5, 0))

        prompt_text = ctk.CTkTextbox(
            frame,
            height=100,
            wrap="word"
        )
        prompt_text.pack(fill="x", padx=15, pady=5)
        prompt_text.insert("1.0", config.get("system_prompt", ""))

        # Checkboxes
        options_frame = ctk.CTkFrame(frame, fg_color="transparent")
        options_frame.pack(fill="x", padx=15, pady=5)

        stream_var = ctk.BooleanVar(value=config.get("stream", True))
        stream_cb = ctk.CTkCheckBox(
            options_frame,
            text="Stream responses",
            variable=stream_var
        )
        stream_cb.pack(anchor="w")

        history_var = ctk.BooleanVar(value=config.get("keep_history", True))
        history_cb = ctk.CTkCheckBox(
            options_frame,
            text="Keep conversation history",
            variable=history_var
        )
        history_cb.pack(anchor="w", pady=5)

        # Action buttons
        buttons_frame = ctk.CTkFrame(frame, fg_color="transparent")
        buttons_frame.pack(fill="x", padx=15, pady=10)

        save_button = ctk.CTkButton(
            buttons_frame,
            text="Save Changes",
            command=lambda: self.save_chatbot_settings(name),
            fg_color=self.colors["accent_primary"]
        )
        save_button.pack(side="left", padx=5)

        delete_button = ctk.CTkButton(
            buttons_frame,
            text="Delete Chatbot",
            command=lambda: self.delete_chatbot(name),
            fg_color=self.colors["error"]
        )
        delete_button.pack(side="right", padx=5)

        return frame

    def refresh_chatbots(self):
        """Refresh the chatbot cards and status in the dashboard"""
        # Update the chatbot list in the dedicated chatbots tab if it exists
        if hasattr(
                self,
                'chatbot_list_frame') and self.chatbot_list_frame.winfo_exists():
            self.refresh_chatbot_list()

        # Update status
        self.update_status("Chatbots refreshed", "info")

        # Refresh the monitor visualization
        if hasattr(self, 'monitor_canvas'):
            self.refresh_monitor_visualization()

        return True

    def load_config(self) -> dict:
        """Load the configuration from the JSON file"""
        try:
            with open(self.config_path, "r") as f:
                config = json.load(f)
                logging.info("Configuration loaded successfully")
                return config
        except FileNotFoundError:
            logging.error(f"Configuration file not found: {self.config_path}")
            return {}
        except json.JSONDecodeError:
            logging.error(
                f"Invalid JSON in configuration file: {self.config_path}")
            return {}

    def toggle_voice_assistant(self):
        """Toggle the voice assistant on/off"""
        # Check if we're in recording mode
        if hasattr(self, 'recording_active') and self.recording_active:
            # Update button text and color
            if hasattr(self, 'toggle_button'):
                self.toggle_button.configure(
                    text="Start Voice Assistant",
                    fg_color=self.colors["status_green"]  # Green when off
                )

            # Stop recording and transcribe
            if self.stop_manual_recording():
                # Transcribe the recording
                self.transcribe_last_recording()
                # Disable continuous recording
                self.continuous_recording = False

            # Update status indicator
            if hasattr(self, 'status_indicator'):
                self.status_indicator.configure(
                    fg_color=self.colors["status_gray"])
                
            # Enable record button, disable stop button
            if hasattr(self, 'record_button'):
                self.record_button.configure(state="normal")
            if hasattr(self, 'stop_record_button'):
                self.stop_record_button.configure(state="disabled")
        else:
            # Update button text and color
            if hasattr(self, 'toggle_button'):
                self.toggle_button.configure(
                    text="Stop Voice Assistant",
                    fg_color=self.colors["status_red"]  # Red when recording
                )

            # Start recording
            success = self.start_manual_recording()
            if success:
                # Enable continuous recording
                self.continuous_recording = True
                self.recording_active = True

                # Update status indicator
                if hasattr(self, 'status_indicator'):
                    self.status_indicator.configure(
                        fg_color=self.colors["status_green"])
                        
                # Disable record button, enable stop button
                if hasattr(self, 'record_button'):
                    self.record_button.configure(state="disabled")
                if hasattr(self, 'stop_record_button'):
                    self.stop_record_button.configure(state="normal")

                if hasattr(self, 'text_display'):
                    # Update the text display to show that voice assistant is active
                    self.text_display.configure(state="normal")
                    timestamp = datetime.now().strftime("%H:%M:%S")

                    # Add system message with formatting
                    system_pos = self.text_display.index("end-1c")
                    self.text_display.insert(
                        "end", f"[{timestamp}] Voice Assistant activated. Speak now...\n\n")
                    self.text_display._textbox.tag_add(
                        "system", system_pos, self.text_display.index("end-2c"))

                    self.text_display.see("end")
                    self.text_display.configure(state="disabled")
                    # Update status
                    self.update_status(
                        "Voice Assistant activated. Speak now...",
                        log_level="info")

    def start_manual_recording(self):
        """Start manual recording"""
        if not hasattr(self, 'whisper_recognizer') or self.whisper_recognizer is None:
            self.update_status("Whisper recognizer not initialized", log_level="error")
            return False

        try:
            # Get the selected microphone device if available
            device_id = None
            if hasattr(self, 'mic_device_var') and self.mic_device_var.get() != "Default":
                # Extract device ID from the selection string
                device_str = self.mic_device_var.get()
                if ":" in device_str:
                    device_id = int(device_str.split(":")[0].strip())
            
            # Log the device being used
            logging.info(f"Started recording audio with device_id: {device_id}")
            
            # Start recording with the selected device
            self.whisper_recognizer.start_recording(device=device_id)
            self.recording_active = True

            # Start level meter animation
            self.animate_level_meter()

            # Update UI
            if hasattr(self, 'toggle_button'):
                self.toggle_button.configure(text="Stop Voice Assistant")
                
            # Update status
            self.update_status("Voice Assistant activated. Speak now...", log_level="info")
            return True
        except Exception as e:
            self.update_status(f"Failed to start recording: {str(e)}", log_level="error")
            return False

    def stop_manual_recording(self):
        """Stop recording audio manually"""
        if not hasattr(self, 'whisper_recognizer'):
            self.update_status(
                "Whisper recognizer not initialized",
                log_level="error")
            return False

        try:
            # Stop recording
            success = self.whisper_recognizer.stop_recording()
            if success:
                self.update_status("Recording stopped", log_level="info")
                # Update UI to show stopped state
                self.toggle_button.configure(
                    text="Start Voice Assistant",
                    fg_color=self.colors["status_green"]
                )
                # Enable record button, disable stop button
                if hasattr(self, 'record_button'):
                    self.record_button.configure(state="normal")
                if hasattr(self, 'stop_record_button'):
                    self.stop_record_button.configure(state="disabled")
                
                # Stop level meter animation
                self.recording_active = False

                # Update text display to show that voice assistant is stopped
                if hasattr(self, 'text_display'):
                    self.text_display.configure(state="normal")
                    timestamp = datetime.now().strftime("%H:%M:%S")

                    # Add system message with formatting
                    system_pos = self.text_display.index("end-1c")
                    self.text_display.insert(
                        "end", f"[{timestamp}] Voice Assistant stopped.\n\n")
                    self.text_display._textbox.tag_add(
                        "system", system_pos, self.text_display.index("end-2c"))

                    self.text_display.see("end")
                    self.text_display.configure(state="disabled")

                # Transcribe the recording
                self.transcribe_last_recording()

                return True
            else:
                self.update_status("No recording to stop", log_level="warning")
                return False
        except Exception as e:
            self.update_status(
                f"Error stopping recording: {str(e)}",
                log_level="error")
            return False

    def transcribe_last_recording(self):
        """Transcribe the last recording using Whisper API"""
        try:
            # Check if whisper recognizer is initialized
            if not hasattr(self, 'whisper_recognizer') or self.whisper_recognizer is None:
                self.update_status("Whisper recognizer not initialized")
                logging.warning("Attempted to transcribe without initialized recognizer")
                return
                
            # Save audio to file and check if we have audio data
            if not hasattr(self, 'audio_data') or self.audio_data is None or len(self.audio_data) == 0:
                self.update_status("No audio data available for transcription")
                logging.warning("No audio data available for transcription")
                return
                
            # Update status
            self.update_status("Transcribing audio...")
            
            # Transcribe the audio
            transcription = self.whisper_recognizer.transcribe_audio(self.audio_data)
            
            if transcription:
                # Update status
                self.update_status(f"Transcription successful: {transcription[:30]}...")
                
                # Add to transcription display
                self.add_to_transcription(transcription)
                
                # Add to voice commands display
                self.add_to_text_display(transcription)
                
                # Auto-start recording if continuous mode is enabled
                if self.continuous_recording:
                    self.start_manual_recording()
            else:
                self.update_status("Transcription failed or returned empty result")
                logging.warning("Transcription failed or returned empty result")
                
        except Exception as e:
            self.update_status(f"Error during transcription: {str(e)}")
            logging.error(f"Error during transcription: {str(e)}", exc_info=True)
            
        # Disable the transcribe button after transcription
        if hasattr(self, 'transcribe_button'):
            self.transcribe_button.configure(state="disabled")

    def animate_level_meter(self):
        """Animate the microphone level meter during recording"""
        if not hasattr(self, 'recording_active') or not self.recording_active:
            # Even when not recording, update with zero level to show the meter
            if hasattr(self, 'synth_bar'):
                self.synth_bar.update(0)
            return

        try:
            # Get the latest audio data if available
            if hasattr(self, 'whisper_recognizer') and self.whisper_recognizer.audio_data:
                latest_chunk = self.whisper_recognizer.audio_data[-1]
                
                # Calculate volume (RMS)
                volume = np.sqrt(np.mean(latest_chunk**2))
                
                # Apply sensitivity/gain from the slider
                if hasattr(self, 'sensitivity_var'):
                    # Apply a logarithmic scaling for more natural sensitivity control
                    sensitivity = self.sensitivity_var.get()
                    volume = volume * (np.exp(sensitivity * 2) - 1)
                
                # Add noise floor threshold to filter out background noise
                noise_floor = 0.01  # Adjust this value based on testing
                if volume < noise_floor:
                    volume = 0
                
                # Scale for visualization (0-100) with more moderate scaling
                volume = min(100, volume * 150)  # Reduced from 300 to 150

                # Update the level meter
                if hasattr(self, 'synth_bar'):
                    self.synth_bar.update(volume)
                
                # Update voice status indicator
                if hasattr(self, 'status_value_3'):
                    if volume > 70:  # High volume
                        self.status_value_3.configure(text="Speaking")
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=self.colors["status_red"])
                    elif volume > 30:  # Medium volume
                        self.status_value_3.configure(text="Active")
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=self.colors["status_yellow"])
                    else:  # Low/no volume
                        self.status_value_3.configure(text="Listening")
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=self.colors["status_green"])
            else:
                # If no audio data, show no activity
                if hasattr(self, 'synth_bar'):
                    self.synth_bar.update(0)
            
            # Continue animation if recording is still active
            if self.recording_active:
                self.app.after(50, self.animate_level_meter)  # Faster updates for smoother animation
                
        except Exception as e:
            logging.error(f"Error in level meter animation: {str(e)}")
            # Try to continue animation despite error
            if hasattr(self, 'recording_active') and self.recording_active:
                self.app.after(100, self.animate_level_meter)

    def refresh_monitor_visualization(self):
        """Update the system monitor visualization"""
        try:
            # Check if monitor_canvas exists
            if not hasattr(self, 'monitor_canvas'):
                logging.warning("monitor_canvas not initialized yet")
                return

            # Clear previous visualization
            self.monitor_canvas.delete("all")

            # Get system metrics
            import psutil
            cpu_percent = psutil.cpu_percent()
            memory_percent = psutil.virtual_memory().percent
            disk_percent = psutil.disk_usage('/').percent

            # Canvas dimensions
            width = self.monitor_canvas.winfo_width()
            height = self.monitor_canvas.winfo_height()

            # Ensure we have valid dimensions
            if width <= 1 or height <= 1:
                # Canvas not properly sized yet, schedule another update
                self.app.after(1000, self.refresh_monitor_visualization)
                return

            # Bar width and spacing
            bar_width = width / 4
            spacing = width / 12

            # Draw CPU bar
            cpu_color = self.get_resource_color(cpu_percent)
            cpu_height = (cpu_percent / 100) * height
            self.monitor_canvas.create_rectangle(
                spacing, height - cpu_height,
                spacing + bar_width, height,
                fill=cpu_color, outline=""
            )
            self.monitor_canvas.create_text(
                spacing + bar_width / 2, height - cpu_height - 15,
                text=f"CPU\n{cpu_percent}%",
                fill=self.colors["text_bright"],
                font=("Helvetica", 10, "bold"),
                justify="center"
            )

            # Draw Memory bar
            mem_color = self.get_resource_color(memory_percent)
            mem_height = (memory_percent / 100) * height
            self.monitor_canvas.create_rectangle(
                spacing * 2 + bar_width, height - mem_height,
                spacing * 2 + bar_width * 2, height,
                fill=mem_color, outline=""
            )
            self.monitor_canvas.create_text(
                spacing * 2 + bar_width * 1.5, height - mem_height - 15,
                text=f"RAM\n{memory_percent}%",
                fill=self.colors["text_bright"],
                font=("Helvetica", 10, "bold"),
                justify="center"
            )

            # Draw Disk bar
            disk_color = self.get_resource_color(disk_percent)
            disk_height = (disk_percent / 100) * height
            self.monitor_canvas.create_rectangle(
                spacing * 3 + bar_width * 2, height - disk_height,
                spacing * 3 + bar_width * 3, height,
                fill=disk_color, outline=""
            )
            self.monitor_canvas.create_text(
                spacing * 3 + bar_width * 2.5, height - disk_height - 15,
                text=f"Disk\n{disk_percent}%",
                fill=self.colors["text_bright"],
                font=("Helvetica", 10, "bold"),
                justify="center"
            )

            # Schedule next update
            self.app.after(2000, self.refresh_monitor_visualization)

        except Exception as e:
            logging.error(f"Error updating monitor visualization: {str(e)}")
            # Try again later
            self.app.after(5000, self.refresh_monitor_visualization)

    def update_status(self, message, log_level="info"):
        """Update the status message in the footer"""
        try:
            # Log the message with appropriate level
            if log_level == "info":
                logging.info(message)
            elif log_level == "warning":
                logging.warning(message)
            elif log_level == "error":
                logging.error(message)

            # Check if status_label exists before updating
            if hasattr(self, 'status_label') and self.status_label is not None:
                self.status_label.configure(text=message)
            else:
                logging.warning(
                    "Status label not initialized yet, can't update status")

        except Exception as e:
            logging.error(f"Error updating status: {str(e)}")
            # Don't raise the exception to avoid crashing the app

    def _adjust_color_brightness(self, hex_color, factor):
        """Adjust the brightness of a hex color"""
        # Convert hex to RGB
        r, g, b = self.hex_to_rgb(hex_color)
        
        # Adjust brightness
        r = max(0, min(255, int(r * factor)))
        g = max(0, min(255, int(g * factor)))
        b = max(0, min(255, int(b * factor)))
        
        # Convert back to hex
        return f'#{r:02x}{g:02x}{b:02x}'
        
    def clear_transcription(self):
        """Clear the transcription display"""
        self.transcription_display.configure(state="normal")
        self.transcription_display.delete("1.0", "end")
        self.transcription_display.insert("end", "Transcribed text will appear here...")
        self.transcription_display.configure(state="disabled")
        self.enter_button.configure(state="disabled")
        
    def clear_text_display(self):
        """Clear the text display"""
        self.text_display.configure(state="normal")
        self.text_display.delete("1.0", "end")
        self.text_display.insert("end", "Voice commands will appear here after starting the voice assistant...")
        self.text_display.configure(state="disabled")

    def toggle_fullscreen(self):
        """Toggle fullscreen mode for the application window"""
        try:
            # Track fullscreen state
            if not hasattr(self, 'is_fullscreen'):
                self.is_fullscreen = False

            # Toggle state
            self.is_fullscreen = not self.is_fullscreen

            # Apply the change
            self.app.attributes("-fullscreen", self.is_fullscreen)

            # Update status
            status = "Fullscreen mode enabled" if self.is_fullscreen else "Fullscreen mode disabled"
            self.update_status(status)

        except Exception as e:
            logging.error(f"Error toggling fullscreen: {str(e)}")
            self.update_status(
                f"Failed to toggle fullscreen: {str(e)}", "error")

    def create_settings_general_tab(self, parent):
        """Create the general settings tab content"""
        # Main container
        container = ctk.CTkFrame(parent, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)

        # Interface settings section
        interface_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        interface_frame.pack(fill="x", pady=(0, 15))

        # Section title
        interface_title = ctk.CTkLabel(
            interface_frame,
            text="Interface Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        interface_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Language setting
        language_frame = ctk.CTkFrame(interface_frame, fg_color="transparent")
        language_frame.pack(fill="x", padx=15, pady=5)

        language_label = ctk.CTkLabel(
            language_frame,
            text="Interface Language",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        language_label.pack(side="left")

        self.language_var = ctk.StringVar(value="English")
        language_dropdown = ctk.CTkOptionMenu(
            language_frame,
            values=[
                "English",
                "Spanish",
                "French",
                "German",
                "Chinese",
                "Japanese"],
            variable=self.language_var,
            width=200)
        language_dropdown.pack(side="left", padx=10)

        # Startup settings section
        startup_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        startup_frame.pack(fill="x", pady=(0, 15))

        # Section title
        startup_title = ctk.CTkLabel(
            startup_frame,
            text="Startup Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        startup_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Auto-start setting
        autostart_frame = ctk.CTkFrame(startup_frame, fg_color="transparent")
        autostart_frame.pack(fill="x", padx=15, pady=5)

        autostart_label = ctk.CTkLabel(
            autostart_frame,
            text="Start with Windows",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        autostart_label.pack(side="left")

        self.autostart_var = ctk.BooleanVar(value=False)
        autostart_switch = ctk.CTkSwitch(
            autostart_frame,
            text="",
            variable=self.autostart_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        autostart_switch.pack(side="left", padx=10)

        # Start minimized setting
        minimized_frame = ctk.CTkFrame(startup_frame, fg_color="transparent")
        minimized_frame.pack(fill="x", padx=15, pady=5)

        minimized_label = ctk.CTkLabel(
            minimized_frame,
            text="Start Minimized",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        minimized_label.pack(side="left")

        self.minimized_var = ctk.BooleanVar(value=False)
        minimized_switch = ctk.CTkSwitch(
            minimized_frame,
            text="",
            variable=self.minimized_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        minimized_switch.pack(side="left", padx=10)

        # Auto-activate voice assistant
        autoactivate_frame = ctk.CTkFrame(
            startup_frame, fg_color="transparent")
        autoactivate_frame.pack(fill="x", padx=15, pady=5)

        autoactivate_label = ctk.CTkLabel(
            autoactivate_frame,
            text="Auto-activate Voice Assistant",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        autoactivate_label.pack(side="left")

        self.autoactivate_var = ctk.BooleanVar(value=False)
        autoactivate_switch = ctk.CTkSwitch(
            autoactivate_frame,
            text="",
            variable=self.autoactivate_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        autoactivate_switch.pack(side="left", padx=10)

        return container

    def create_settings_appearance_tab(self, parent):
        """Create the appearance settings tab content"""
        # Main container
        container = ctk.CTkFrame(parent, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)

        # Theme settings section
        theme_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        theme_frame.pack(fill="x", pady=(0, 15))

        # Section title
        theme_title = ctk.CTkLabel(
            theme_frame,
            text="Theme Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        theme_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Theme selection
        theme_selection_frame = ctk.CTkFrame(
            theme_frame, fg_color="transparent")
        theme_selection_frame.pack(fill="x", padx=15, pady=5)

        theme_label = ctk.CTkLabel(
            theme_selection_frame,
            text="Color Theme",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        theme_label.pack(side="left")

        self.theme_var = ctk.StringVar(value="medical")
        theme_dropdown = ctk.CTkOptionMenu(
            theme_selection_frame,
            values=["medical", "midnight", "cyberpunk"],
            variable=self.theme_var,
            width=200,
            command=self.apply_theme
        )
        theme_dropdown.pack(side="left", padx=10)

        # Appearance mode
        appearance_frame = ctk.CTkFrame(theme_frame, fg_color="transparent")
        appearance_frame.pack(fill="x", padx=15, pady=5)

        appearance_label = ctk.CTkLabel(
            appearance_frame,
            text="Appearance Mode",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        appearance_label.pack(side="left")

        self.appearance_var = ctk.StringVar(value="Dark")
        appearance_dropdown = ctk.CTkOptionMenu(
            appearance_frame,
            values=["Dark", "Light", "System"],
            variable=self.appearance_var,
            width=200,
            command=lambda value: ctk.set_appearance_mode(value)
        )
        appearance_dropdown.pack(side="left", padx=10)

        # Font settings section
        font_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        font_frame.pack(fill="x", pady=(0, 15))

        # Section title
        font_title = ctk.CTkLabel(
            font_frame,
            text="Font Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        font_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Font size
        font_size_frame = ctk.CTkFrame(font_frame, fg_color="transparent")
        font_size_frame.pack(fill="x", padx=15, pady=5)

        font_size_label = ctk.CTkLabel(
            font_size_frame,
            text="Font Size",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        font_size_label.pack(side="left")

        self.font_size_var = ctk.IntVar(value=12)
        font_size_slider = ctk.CTkSlider(
            font_size_frame,
            from_=8,
            to=16,
            number_of_steps=8,
            variable=self.font_size_var,
            width=200
        )
        font_size_slider.pack(side="left", padx=10)

        font_size_value = ctk.CTkLabel(
            font_size_frame,
            textvariable=self.font_size_var,
            width=30
        )
        font_size_value.pack(side="left", padx=5)

        # Preview section
        preview_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        preview_frame.pack(fill="x", pady=(0, 15))

        # Section title
        preview_title = ctk.CTkLabel(
            preview_frame,
            text="Theme Preview",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        preview_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Preview content
        preview_content = ctk.CTkFrame(
            preview_frame,
            fg_color=self.colors["bg_medium"],
            corner_radius=5,
            height=100
        )
        preview_content.pack(fill="x", padx=15, pady=(0, 15))
        preview_content.pack_propagate(False)

        preview_label = ctk.CTkLabel(
            preview_content,
            text="Sample Text",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"]
        )
        preview_label.pack(anchor="center", pady=10)

        preview_button = ctk.CTkButton(
            preview_content,
            text="Sample Button",
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            width=150
        )
        preview_button.pack(anchor="center")

        return container

    def create_settings_voice_tab(self, parent):
        """Create the voice settings tab content"""
        # Main container with gradient background
        container = ctk.CTkFrame(parent, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)

        # Microphone settings section
        mic_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        mic_frame.pack(fill="x", pady=(0, 15))

        # Section title
        mic_title = ctk.CTkLabel(
            mic_frame,
            text="Microphone Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        mic_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Microphone selection
        mic_selection_frame = ctk.CTkFrame(mic_frame, fg_color="transparent")
        mic_selection_frame.pack(fill="x", padx=15, pady=5)

        mic_label = ctk.CTkLabel(
            mic_selection_frame,
            text="Input Device",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        mic_label.pack(side="left")

        # Create a frame for the dropdown and refresh button
        mic_dropdown_frame = ctk.CTkFrame(
            mic_selection_frame, fg_color="transparent")
        mic_dropdown_frame.pack(side="left", fill="x", expand=True)

        # Microphone dropdown
        self.mic_var = ctk.StringVar(value="Default Microphone")
        self.mic_dropdown = ctk.CTkOptionMenu(
            mic_dropdown_frame,
            values=["Default Microphone"],
            variable=self.mic_var,
            width=200
        )
        self.mic_dropdown.pack(side="left", padx=(0, 10))

        # Refresh button
        refresh_button = ctk.CTkButton(
            mic_dropdown_frame,
            text="Refresh",
            command=self.refresh_mic_list,
            fg_color=self.colors["bg_medium"],
            hover_color=self.colors["bg_light"],
            width=80
        )
        refresh_button.pack(side="left")

        # Microphone level visualization
        level_frame = ctk.CTkFrame(mic_frame, fg_color="transparent")
        level_frame.pack(fill="x", padx=15, pady=5)

        level_label = ctk.CTkLabel(
            level_frame,
            text="Input Level",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        level_label.pack(side="left")

        # Level meter canvas
        self.level_canvas = ctk.CTkCanvas(
            level_frame,
            height=24,
            width=200,
            bg=self.colors["bg_dark"],
            highlightthickness=0
        )
        self.level_canvas.pack(side="left", padx=10)

        # Test microphone button
        test_button = ctk.CTkButton(
            level_frame,
            text="Test",
            command=self.test_microphone,
            fg_color=self.colors["accent_secondary"],
            hover_color=self.colors["accent_primary"],
            width=80
        )
        test_button.pack(side="left")

        # Advanced microphone settings
        advanced_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        advanced_frame.pack(fill="x", pady=(0, 15))

        # Section title
        advanced_title = ctk.CTkLabel(
            advanced_frame,
            text="Advanced Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        advanced_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Input gain
        gain_frame = ctk.CTkFrame(advanced_frame, fg_color="transparent")
        gain_frame.pack(fill="x", padx=15, pady=5)

        gain_label = ctk.CTkLabel(
            gain_frame,
            text="Input Gain",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        gain_label.pack(side="left")

        self.gain_var = ctk.DoubleVar(value=1.0)
        gain_slider = ctk.CTkSlider(
            gain_frame,
            from_=0.1,
            to=2.0,
            variable=self.gain_var,
            width=200
        )
        gain_slider.pack(side="left", padx=10)

        gain_value = ctk.CTkLabel(
            gain_frame,
            text=f"{self.gain_var.get():.1f}",
            width=30
        )
        gain_value.pack(side="left", padx=5)

        # Noise threshold
        threshold_frame = ctk.CTkFrame(advanced_frame, fg_color="transparent")
        threshold_frame.pack(fill="x", padx=15, pady=5)

        threshold_label = ctk.CTkLabel(
            threshold_frame,
            text="Noise Threshold",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        threshold_label.pack(side="left")

        self.threshold_var = ctk.DoubleVar(value=0.2)
        threshold_slider = ctk.CTkSlider(
            threshold_frame,
            from_=0.0,
            to=0.5,
            variable=self.threshold_var,
            width=200
        )
        threshold_slider.pack(side="left", padx=10)

        threshold_value = ctk.CTkLabel(
            threshold_frame,
            text=f"{self.threshold_var.get():.2f}",
            width=30
        )
        threshold_value.pack(side="left", padx=5)

        # Echo cancellation
        echo_frame = ctk.CTkFrame(advanced_frame, fg_color="transparent")
        echo_frame.pack(fill="x", padx=15, pady=5)

        echo_label = ctk.CTkLabel(
            echo_frame,
            text="Echo Cancellation",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        echo_label.pack(side="left")

        self.echo_var = ctk.BooleanVar(value=True)
        echo_switch = ctk.CTkSwitch(
            echo_frame,
            text="",
            variable=self.echo_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        echo_switch.pack(side="left", padx=10)

        # Noise reduction
        noise_frame = ctk.CTkFrame(advanced_frame, fg_color="transparent")
        noise_frame.pack(fill="x", padx=15, pady=5)

        noise_label = ctk.CTkLabel(
            noise_frame,
            text="Noise Reduction",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        noise_label.pack(side="left")

        self.noise_var = ctk.BooleanVar(value=True)
        noise_switch = ctk.CTkSwitch(
            noise_frame,
            text="",
            variable=self.noise_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        noise_switch.pack(side="left", padx=10)

        # Initialize microphone list
        self.refresh_mic_list()

        return container

    def refresh_mic_list(self):
        """Refresh the list of available microphones."""
        try:
            devices = sd.query_devices()
            input_devices = []

            # Add a default option
            input_devices.append("Default Microphone")

            # Add all input devices with their IDs for easier identification
            for i, device in enumerate(devices):
                if device['max_input_channels'] > 0:
                    input_devices.append(f"{device['name']} (ID: {i})")

            # Update dropdown
            self.mic_dropdown.configure(values=input_devices)

            # Set default selection
            if input_devices:
                self.mic_var.set(input_devices[0])

            # Update status
            self.update_status(f"Found {len(input_devices)-1} input devices")

        except Exception as e:
            logging.error(f"Error refreshing microphone list: {str(e)}")
            self.update_status("Failed to refresh microphone list", "error")
            # Ensure at least the default option is available
            self.mic_dropdown.configure(values=["Default Microphone"])
            self.mic_var.set("Default Microphone")

    def test_microphone(self):
        """Test the selected microphone by recording and playing back audio."""
        try:
            device_str = self.mic_var.get()
            device_id = None

            # Extract device ID if it's not the default microphone
            if device_str != "Default Microphone":
                try:
                    device_id = int(device_str.split("ID: ")[1].strip(")"))
                    logging.info(f"Testing microphone with ID: {device_id}")
                except Exception as e:
                    logging.error(f"Error parsing device ID: {str(e)}")
                    device_id = None
                    logging.info("Using default microphone instead")

            # Create a modern dialog to show recording status
            dialog = ctk.CTkToplevel(self.app)
            dialog.title("Microphone Test")
            dialog.geometry("400x300")
            dialog.resizable(False, False)
            dialog.transient(self.app)
            dialog.grab_set()

            # Set dialog theme
            dialog.configure(fg_color=self.colors["bg_medium"])

            # Center the dialog
            dialog.update_idletasks()
            width = dialog.winfo_width()
            height = dialog.winfo_height()
            x = (dialog.winfo_screenwidth() // 2) - (width // 2)
            y = (dialog.winfo_screenheight() // 2) - (height // 2)
            dialog.geometry(f"{width}x{height}+{x}+{y}")

            # Title with icon
            title_frame = ctk.CTkFrame(dialog, fg_color="transparent")
            title_frame.pack(fill="x", padx=20, pady=(20, 10))

            title_label = ctk.CTkLabel(
                title_frame,
                text="Microphone Test",
                font=ctk.CTkFont(size=20, weight="bold"),
                text_color=self.colors["text_bright"]
            )
            title_label.pack(side="left")

            # Status label with modern styling
            status_frame = ctk.CTkFrame(
                dialog, fg_color=self.colors["bg_light"], corner_radius=10)
            status_frame.pack(fill="x", padx=20, pady=10)

            status_label = ctk.CTkLabel(
                status_frame,
                text="Initializing microphone test...",
                font=ctk.CTkFont(size=14),
                text_color=self.colors["text_bright"],
                wraplength=350
            )
            status_label.pack(pady=15, padx=15)

            # Progress bar with custom styling
            progress_frame = ctk.CTkFrame(dialog, fg_color="transparent")
            progress_frame.pack(fill="x", padx=20, pady=5)

            progress_label = ctk.CTkLabel(
                progress_frame,
                text="Progress:",
                font=ctk.CTkFont(size=12),
                text_color=self.colors["text_normal"]
            )
            progress_label.pack(anchor="w")

            progress = ctk.CTkProgressBar(
                progress_frame,
                width=360,
                height=15,
                corner_radius=5,
                fg_color=self.colors["bg_dark"],
                progress_color=self.colors["accent_primary"]
            )
            progress.pack(pady=5)
            progress.set(0)

            # Level meter with improved visualization
            level_frame = ctk.CTkFrame(dialog, fg_color="transparent")
            level_frame.pack(fill="x", padx=20, pady=5)

            level_label = ctk.CTkLabel(
                level_frame,
                text="Audio Level:",
                font=ctk.CTkFont(size=12),
                text_color=self.colors["text_normal"]
            )
            level_label.pack(anchor="w")

            meter_bg = ctk.CTkFrame(
                level_frame,
                fg_color=self.colors["bg_dark"],
                height=30,
                width=360,
                corner_radius=5
            )
            meter_bg.pack(pady=5)

            level_indicator = ctk.CTkFrame(
                meter_bg,
                fg_color=self.colors["accent_primary"],
                height=30,
                width=1,
                corner_radius=5
            )
            level_indicator.place(x=0, y=0)

            level_text = ctk.CTkLabel(
                meter_bg,
                text="0%",
                font=ctk.CTkFont(size=12, weight="bold"),
                text_color=self.colors["text_bright"]
            )
            level_text.place(relx=0.5, rely=0.5, anchor="center")

            # Button frame
            button_frame = ctk.CTkFrame(dialog, fg_color="transparent")
            button_frame.pack(fill="x", padx=20, pady=(15, 20))

            # Cancel button
            cancel_button = ctk.CTkButton(
                button_frame,
                text="Cancel",
                command=dialog.destroy,
                fg_color=self.colors["bg_light"],
                hover_color=self.colors["bg_medium"],
                text_color=self.colors["text_normal"],
                width=100
            )
            cancel_button.pack(side="left", padx=(0, 10))

            # Close button (initially disabled)
            close_button = ctk.CTkButton(
                button_frame,
                text="Close",
                command=dialog.destroy,
                state="disabled",
                fg_color=self.colors["accent_primary"],
                hover_color=self.colors["accent_secondary"],
                width=100
            )
            close_button.pack(side="right")

            # Get device info
            try:
                device_info = sd.query_devices(device_id)
                samplerate = int(device_info['default_samplerate'])

                # Show device info in status
                status_label.configure(
                    text=f"Testing: {device_info['name']}\nPlease speak now to test your microphone.")
            except Exception as e:
                status_label.configure(
                    text=f"Error: {str(e)}\nCould not initialize the selected microphone.")
                close_button.configure(state="normal")
                return

            # Duration of recording
            duration = 5  # seconds

            # Function to update progress
            def update_progress(current, total):
                progress.set(current / total)
                progress_label.configure(
                    text=f"Progress: {int(current/total*100)}%")
                dialog.update()

            # Function to update level indicator
            def update_level(volume):
                # Scale volume (0-1) to width
                width = min(360, int(volume * 360))
                level_indicator.configure(width=width)

                # Update color based on level
                if volume < 0.3:
                    level_indicator.configure(
                        fg_color=self.colors["status_green"])
                elif volume < 0.7:
                    level_indicator.configure(
                        fg_color=self.colors["status_yellow"])
                else:
                    level_indicator.configure(
                        fg_color=self.colors["status_red"])

                # Update text
                level_text.configure(text=f"{int(volume * 100)}%")
                dialog.update()

            # Function to record audio
            def record_audio():
                status_label.configure(
                    text=f"Recording from: {device_info['name']}\nPlease speak now...")

                # Create array to store audio data
                audio_data = []

                # Start time
                start_time = time.time()

                # Callback function for audio stream
                def audio_callback(indata, frames, time_info, status):
                    if status:
                        logging.warning(f"Audio status: {status}")

                    # Copy audio data
                    audio_data.append(indata.copy())

                    # Calculate volume level (RMS)
                    volume = np.sqrt(np.mean(indata**2))

                    # Apply gain if available
                    if hasattr(self, 'gain_var'):
                        volume *= self.gain_var.get()

                    # Update level indicator
                    dialog.after(0, lambda: update_level(min(1.0, volume * 2)))

                    # Update progress
                    elapsed = time.time() - start_time
                    if elapsed < duration:
                        dialog.after(
                            0, lambda: update_progress(
                                elapsed, duration))

                # Start audio stream
                try:
                    with sd.InputStream(
                        device=device_id,
                        channels=1,
                        callback=audio_callback,
                        samplerate=samplerate,
                        blocksize=int(samplerate * 0.1)  # 100ms blocks
                    ):
                        # Wait for duration
                        sd.sleep(int(duration * 1000))
                except Exception as e:
                    error_msg = f"Error recording: {str(e)}"
                    logging.error(error_msg)
                    status_label.configure(text=error_msg)
                    close_button.configure(state="normal")
                    return None

                # Combine all audio chunks
                if audio_data:
                    return np.concatenate(audio_data)
                return None

            # Function to play audio
            def play_audio(audio_data):
                status_label.configure(text="Playing back recording...")
                progress.set(0)

                try:
                    # Start time
                    start_time = time.time()

                    # Play audio
                    sd.play(audio_data, samplerate)

                    # Update progress during playback
                    def update_playback_progress():
                        elapsed = time.time() - start_time
                        if elapsed < duration and not dialog.winfo_exists():
                            return

                        if elapsed < duration:
                            update_progress(elapsed, duration)
                            dialog.after(100, update_playback_progress)
                        else:
                            progress.set(1.0)


class DragonVoiceGUI:
    """
    Main GUI class for the Dragon Voice Project

    Provides a modern, feature-rich interface for controlling the voice assistant,
    managing chatbots, and configuring system settings.
    """

    def __init__(self, config_path=DEFAULT_CONFIG_PATH):
        """Initialize the DragonVoice GUI application"""
        logging.info("Initializing DragonVoiceGUI")
        logging.info("Initializing DragonVoice GUI")

        try:
            # Initialize logging
            self.setup_logging()

            # Initialize state variables
            self.recording_active = False
            self.continuous_recording = False  # Flag for continuous recording
            self.is_fullscreen = False

            # Create main application window
            self.app = ctk.CTk()
            self.app.title("DragonVoice")
            self.app.geometry("1200x800")
            self.app.minsize(900, 600)
            
            # Center window on screen
            screen_width = self.app.winfo_screenwidth()
            screen_height = self.app.winfo_screenheight()
            x = (screen_width - 1200) // 2
            y = (screen_height - 800) // 2
            self.app.geometry(f"1200x800+{x}+{y}")

            # Load configuration
            self.config_path = config_path
            self.config = self.load_config()
            logging.info(f"Configuration loaded from {config_path}")

            # Set up theme and colors
            self.setup_theme()

            # Initialize Whisper recognizer
            self.init_whisper_recognizer()

            # Set up UI components
            self.setup_ui()

            # Start system monitoring
            self.start_system_monitoring()

        except Exception as e:
            logging.error(f"Error initializing DragonVoiceGUI: {str(e)}")
            raise

    def setup_logging(self):
        """Set up logging configuration"""
        # Check if logging is already configured
        if not logging.getLogger().handlers:
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - %(message)s'
            )
        logging.info("Logging setup complete")

    def setup_theme(self):
        """Set up the theme and colors for the application"""
        # Set appearance mode
        ctk.set_appearance_mode("dark")

        # Define color schemes
        self.color_schemes = {
            "dark": {
                "bg_dark": "#1A1A2E",
                "bg_medium": "#16213E",
                "bg_light": "#0F3460",
                "accent_primary": "#E94560",
                "accent_secondary": "#0F52BA",
                "text_bright": "#FFFFFF",
                "text_normal": "#E0E0E0",
                "text_dim": "#A0A0A0",
                "status_green": "#4CAF50",
                "status_yellow": "#FFC107",
                "status_red": "#F44336",
                "status_blue": "#2196F3",
                "status_gray": "#757575"
            },
            "light": {
                "bg_dark": "#F0F0F0",
                "bg_medium": "#E0E0E0",
                "bg_light": "#D0D0D0",
                "accent_primary": "#E94560",
                "accent_secondary": "#0F52BA",
                "text_bright": "#000000",
                "text_normal": "#202020",
                "text_dim": "#505050",
                "status_green": "#4CAF50",
                "status_yellow": "#FFC107",
                "status_red": "#F44336",
                "status_blue": "#2196F3",
                "status_gray": "#757575"
            },
            "dragon": {
                "bg_dark": "#0A1931",
                "bg_medium": "#150E56",
                "bg_light": "#1A1A40",
                "accent_primary": "#D82148",
                "accent_secondary": "#6EBF8B",
                "text_bright": "#FFFFFF",
                "text_normal": "#E0E0E0",
                "text_dim": "#A0A0A0",
                "status_green": "#4CAF50",
                "status_yellow": "#FFC107",
                "status_red": "#F44336",
                "status_blue": "#2196F3",
                "status_gray": "#757575"
            }
        }

        # Set default color scheme
        self.colors = self.color_schemes["dragon"]

        # Define fonts
        self.fonts = {
            "header": ctk.CTkFont(family="Segoe UI", size=28, weight="bold"),
            "title": ctk.CTkFont(family="Segoe UI", size=20, weight="bold"),
            "subtitle": ctk.CTkFont(family="Segoe UI", size=16, weight="bold"),
            "normal": ctk.CTkFont(family="Segoe UI", size=14),
            "small": ctk.CTkFont(family="Segoe UI", size=12),
            "tiny": ctk.CTkFont(family="Segoe UI", size=10),
            "mono": ctk.CTkFont(family="Consolas", size=12),
            # Added the 'large' font definition
            "large": ctk.CTkFont(family="Segoe UI", size=18)
        }

    def init_whisper_recognizer(self):
        """Initialize the Whisper recognizer"""
        try:
            # Initialize API keys with default values
            self.openai_api_key = "j3ydNXEmQFyDKwl5mWxSzcvdZcTLJw1t"
            self.base_url = "https://api.deepinfra.com/v1/openai"
            
            # Initialize WhisperRecognizer with error handling
            if self.openai_api_key:
                self.whisper_recognizer = WhisperRecognizer(
                    api_key=self.openai_api_key,
                    base_url=self.base_url
                )
                # Initialize recording state
                self.recording_active = False
                self.continuous_recording = False
                self.audio_data = []
                logging.info("WhisperRecognizer initialized successfully")
            else:
                logging.warning("No OpenAI API key found, WhisperRecognizer not initialized")
                self.whisper_recognizer = None
        except Exception as e:
            logging.error(f"Failed to initialize WhisperRecognizer: {str(e)}")
            self.whisper_recognizer = None

    def setup_ui(self):
        """Set up the main UI components"""
        try:
            # Create the main container
            self.main_container = ctk.CTkFrame(
                self.app, fg_color="transparent")
            self.main_container.pack(fill="both", expand=True)

            # Create UI components in the correct order
            self.create_footer()  # Create footer first to ensure status_label exists
            self.create_header()
            self.create_tabs()

            # Start system monitoring
            self.start_system_monitoring()

            # Update status
            self.update_status("Application initialized successfully")

            # Log successful UI setup
            logging.info("UI setup completed successfully")

        except Exception as e:
            logging.error(f"Error setting up UI: {str(e)}", exc_info=True)
            # Show error in a messagebox if possible
            try:
                import tkinter.messagebox as messagebox
                messagebox.showerror(
                    "UI Setup Error",
                    f"Error setting up UI:\n{str(e)}")
            except BaseException:
                pass

    def create_header(self):
        """Create a modern application header with logo and controls"""
        # Create header frame with gradient background
        self.header_frame = ctk.CTkFrame(
            self.main_container,
            fg_color=self.colors["bg_dark"],
            corner_radius=0,
            height=90
        )
        self.header_frame.pack(fill="x", pady=0)
        self.header_frame.pack_propagate(False)

        # Create gradient effect for header
        self.header_canvas = ctk.CTkCanvas(
            self.header_frame,
            bg=self.colors["bg_dark"],
            highlightthickness=0,
            height=90
        )
        self.header_canvas.pack(fill="x", side="top")

        # Draw gradient
        def draw_gradient():
            width = self.header_canvas.winfo_width()
            if width <= 1:  # Not yet properly initialized
                self.app.after(100, draw_gradient)
                return

            height = 90
            # Create a more sophisticated gradient
            for i in range(width):
                # Calculate gradient position (0 to 1)
                pos = i / width

                # Create a gradient with accent color highlights
                if pos < 0.2:  # First section - dark to medium with accent hint
                    ratio = pos / 0.2
                    r1, g1, b1 = self.hex_to_rgb(self.colors["bg_dark"])
                    r2, g2, b2 = self.hex_to_rgb(self.colors["bg_medium"])
                    r3, g3, b3 = self.hex_to_rgb(self.colors["accent_primary"])

                    # Mix colors with a hint of accent
                    r = r1 + (r2 - r1) * ratio + (r3 - r1) * ratio * 0.1
                    g = g1 + (g2 - g1) * ratio + (g3 - g1) * ratio * 0.1
                    b = b1 + (b2 - b1) * ratio + (b3 - b1) * ratio * 0.1
                elif pos < 0.8:  # Middle section - medium to medium with subtle variation
                    ratio = (pos - 0.2) / 0.6
                    r1, g1, b1 = self.hex_to_rgb(self.colors["bg_medium"])
                    r2, g2, b2 = self.hex_to_rgb(
                        self._adjust_color_brightness(
                            self.colors["bg_medium"], 1.1))

                    r = r1 + (r2 - r1) * ratio
                    g = g1 + (g2 - g1) * ratio
                    b = b1 + (b2 - b1) * ratio
                else:  # Last section - medium to dark with accent hint
                    ratio = (pos - 0.8) / 0.2
                    r1, g1, b1 = self.hex_to_rgb(self.colors["bg_medium"])
                    r2, g2, b2 = self.hex_to_rgb(self.colors["bg_dark"])
                    r3, g3, b3 = self.hex_to_rgb(
                        self.colors["accent_secondary"])

                    # Mix colors with a hint of accent
                    r = r1 + (r2 - r1) * ratio + (r3 - r1) * ratio * 0.1
                    g = g1 + (g2 - g1) * ratio + (g3 - g1) * ratio * 0.1
                    b = b1 + (b2 - b1) * ratio + (b3 - b1) * ratio * 0.1

                color = f'#{int(r):02x}{int(g):02x}{int(b):02x}'
                self.header_canvas.create_line(i, 0, i, height, fill=color)

            # Add accent line at bottom with glow effect
            for i in range(3):
                alpha = 0.3 + (0.7 * (i / 2))  # Increasing opacity
                glow_color = self._adjust_color_brightness(
                    self.colors["accent_primary"], alpha)
            self.header_canvas.create_line(
                0, height - 3 + i, width, height - 3 + i,
                fill=glow_color,
                width=1
            )

        # Schedule gradient drawing
        self.app.after(100, draw_gradient)

        # Create a container for the header content
        header_content = ctk.CTkFrame(
            self.header_frame, fg_color="transparent")
        header_content.place(
            relx=0.5,
            rely=0.5,
            anchor="center",
            relwidth=1,
            relheight=0.8)

        # Left side - Logo and title
        logo_frame = ctk.CTkFrame(header_content, fg_color="transparent")
        logo_frame.pack(side="left", padx=(30, 0))

        # Try to load logo image if available
        try:
            logo_path = os.path.join("src", "assets", "dragon_logo.png")
            if os.path.exists(logo_path):
                logo_image = ctk.CTkImage(
                    light_image=Image.open(logo_path),
                    dark_image=Image.open(logo_path),
                    size=(40, 40)
                )
                logo_label = ctk.CTkLabel(
                    logo_frame,
                    image=logo_image,
                    text=""
                )
                logo_label.pack(side="left", padx=(0, 15))
        except Exception as e:
            logging.error(f"Failed to load logo: {str(e)}")

        # App title with modern styling
        title_label = ctk.CTkLabel(
            logo_frame,
            text="DragonVoice",
            font=self.fonts["header"],
            text_color=self.colors["text_bright"]
        )
        title_label.pack(side="left")

        # Version with pill background
        version_pill = ctk.CTkFrame(
            logo_frame,
            fg_color=self.colors["accent_primary"],
            corner_radius=12,
            height=24
        )
        version_pill.pack(side="left", padx=(10, 0), pady=(8, 0))

        version_label = ctk.CTkLabel(
            version_pill,
            text="v2.0",
            font=self.fonts["small"],
            text_color=self.colors["text_bright"]
        )
        version_label.pack(padx=10, pady=2)

        # Center - Status indicator
        status_frame = ctk.CTkFrame(header_content, fg_color="transparent")
        status_frame.pack(side="left", expand=True)

        # Right side - Controls
        controls_frame = ctk.CTkFrame(header_content, fg_color="transparent")
        controls_frame.pack(side="right", padx=(0, 30))

        # Microphone selector with improved styling
        mic_frame = ctk.CTkFrame(
            controls_frame,
            fg_color=self.colors["bg_light"],
            corner_radius=8
        )
        mic_frame.pack(side="left", padx=(0, 15), pady=5)

        mic_label = ctk.CTkLabel(
            mic_frame,
            text="Microphone:",
            font=self.fonts["small"],
            text_color=self.colors["text_normal"]
        )
        mic_label.pack(side="left", padx=(10, 5), pady=5)

        # Microphone dropdown
        self.mic_var = ctk.StringVar(value="Default Microphone")
        self.mic_dropdown = ctk.CTkOptionMenu(
            mic_frame,
            values=["Default Microphone"],
            variable=self.mic_var,
            width=150,
            dynamic_resizing=True,
            fg_color=self.colors["bg_medium"],
            button_color=self.colors["accent_primary"],
            button_hover_color=self.colors["accent_secondary"],
            dropdown_fg_color=self.colors["bg_medium"]
        )
        self.mic_dropdown.pack(side="left", padx=(0, 10), pady=5)

        # Theme toggle button
        theme_button = ctk.CTkButton(
            controls_frame,
            text="",
            width=36,
            height=36,
            corner_radius=10,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            text_color=self.colors["text_bright"],
            command=self.toggle_theme
        )
        theme_button.pack(side="left", padx=(0, 10))

        # Settings button
        settings_button = ctk.CTkButton(
            controls_frame,
            text="Settings",
            width=100,
            height=36,
            corner_radius=10,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            text_color=self.colors["text_bright"],
            command=self.show_settings
        )
        settings_button.pack(side="left", padx=(0, 10))

        # Help button
        help_button = ctk.CTkButton(
            controls_frame,
            text="Help",
            width=80,
            height=36,
            corner_radius=10,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            text_color=self.colors["text_bright"],
            command=self.show_help
        )
        help_button.pack(side="left")

        # Refresh microphone list
        self.refresh_mic_list()

    def hex_to_rgb(self, hex_color):
        """Convert hex color to RGB tuple"""
        hex_color = hex_color.lstrip('#')
        return tuple(int(hex_color[i:i + 2], 16) for i in (0, 2, 4))

    def show_settings(self):
        """Show the settings dialog"""
        # Switch to the Configuration tab
        self.tab_view.set("Configuration")

    def show_help(self):
        """Show the help dialog"""
        # Create a new top-level window
        help_window = ctk.CTkToplevel(self.app)
        help_window.title("DragonVoice Help")
        help_window.geometry("800x600")
        help_window.minsize(800, 600)
        help_window.grab_set()  # Make window modal

        # Set window icon
        if platform.system() == "Windows":
            try:
                icon_path = os.path.join(
                    os.path.dirname(
                        os.path.abspath(__file__)),
                    "assets",
                    "dragon_icon.ico")
                if os.path.exists(icon_path):
                    help_window.iconbitmap(icon_path)
            except Exception as e:
                print(f"Could not set help window icon: {e}")

        # Create tab view for help content
        help_tabs = ctk.CTkTabview(
            help_window,
            fg_color=self.colors["bg_dark"],
            segmented_button_fg_color=self.colors["bg_medium"],
            segmented_button_selected_color=self.colors["accent_primary"],
            segmented_button_selected_hover_color=self.colors["accent_secondary"],
            segmented_button_unselected_color=self.colors["bg_medium"],
            segmented_button_unselected_hover_color=self.colors["bg_light"])
        help_tabs.pack(fill="both", expand=True, padx=20, pady=20)

        # Add tabs
        help_tabs.add("Getting Started")
        help_tabs.add("Voice Commands")
        help_tabs.add("Chatbots")
        help_tabs.add("Troubleshooting")
        help_tabs.add("About")

        # Create content for each tab
        self.create_help_getting_started(help_tabs.tab("Getting Started"))
        self.create_help_voice_commands(help_tabs.tab("Voice Commands"))
        self.create_help_chatbots(help_tabs.tab("Chatbots"))
        self.create_help_troubleshooting(help_tabs.tab("Troubleshooting"))
        self.create_help_about(help_tabs.tab("About"))

        # Add close button at bottom
        button_frame = ctk.CTkFrame(help_window, fg_color="transparent")
        button_frame.pack(fill="x", padx=20, pady=(0, 20))

        close_button = ctk.CTkButton(
            button_frame,
            text="Close",
            command=help_window.destroy,
            width=100,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        close_button.pack(side="right")

    def create_footer(self):
        """Create the footer with status information"""
        # Create footer container
        self.footer = ctk.CTkFrame(
            self.app,
            fg_color=self.colors["bg_dark"],
            height=30
        )
        self.footer.pack(fill="x", side="bottom")
        self.footer.pack_propagate(False)

        # Create canvas for gradient background
        footer_canvas = ctk.CTkCanvas(
            self.footer,
            bg=self.colors["bg_dark"],
            highlightthickness=0,
            height=30
        )
        footer_canvas.pack(fill="x")

        # Draw gradient
        def draw_gradient():
            width = footer_canvas.winfo_width()
            if width <= 1:  # Not properly rendered yet
                self.app.after(100, draw_gradient)
                return

            height = 30
            # Create gradient from dark to slightly lighter
            for i in range(height):
                # Calculate color based on position
                r, g, b = self.hex_to_rgb(self.colors["bg_dark"])
                factor = i / height * 0.2  # Subtle gradient
                r = min(255, int(r + (255 - r) * factor))
                g = min(255, int(g + (255 - g) * factor))
                b = min(255, int(b + (255 - b) * factor))
                color = f'#{r:02x}{g:02x}{b:02x}'

                # Draw line
                footer_canvas.create_line(0, i, width, i, fill=color)

        # Schedule gradient drawing after the window is rendered
        self.app.after(100, draw_gradient)

        # Status label
        self.status_label = ctk.CTkLabel(
            footer_canvas,
            text="Ready",
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        self.status_label.place(relx=0.01, rely=0.5, anchor="w")

        # Version label
        version_label = ctk.CTkLabel(
            footer_canvas,
            text="DragonVoice v2.0",
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        version_label.place(relx=0.99, rely=0.5, anchor="e")

        # Log successful creation
        logging.info(
            "Footer created successfully with status_label initialized")

    def create_tabs(self):
        """Create the main tab view and tabs"""
        # Create the main tab container
        self.tab_container = ctk.CTkFrame(self.app, fg_color="transparent")
        self.tab_container.pack(
            fill="both",
            expand=True,
            padx=20,
            pady=(
                0,
                20))

        # Create the tab view
        self.tab_view = ctk.CTkTabview(
            self.tab_container,
            fg_color=self.colors["bg_dark"],
            segmented_button_fg_color=self.colors["bg_medium"],
            segmented_button_selected_color=self.colors["accent_primary"],
            segmented_button_selected_hover_color=self.colors["accent_secondary"],
            segmented_button_unselected_color=self.colors["bg_medium"],
            segmented_button_unselected_hover_color=self.colors["bg_light"])
        self.tab_view.pack(fill="both", expand=True)

        # Add tabs
        self.tab_view.add("Dashboard")
        self.tab_view.add("Chatbots")
        self.tab_view.add("History")
        self.tab_view.add("Configuration")
        self.tab_view.add("About")

        # Set default tab
        self.tab_view.set("Dashboard")

        # Create tab contents
        self.create_dashboard_tab()
        self.create_chatbots_tab()
        self.create_history_tab()
        self.create_config_tab()
        self.create_about_tab()

    def create_dashboard_tab(self):
        """Create the dashboard tab content"""
        # Main container with gradient background
        dashboard_container = ctk.CTkScrollableFrame(
            self.tab_view.tab("Dashboard"),
            fg_color="transparent"
        )
        dashboard_container.pack(fill="both", expand=True, padx=20, pady=0)  # Reduced top padding

        # Create a grid layout for dashboard widgets
        dashboard_container.columnconfigure(0, weight=2)
        dashboard_container.columnconfigure(1, weight=1)
        dashboard_container.rowconfigure(0, weight=1)
        dashboard_container.rowconfigure(1, weight=1)
        dashboard_container.rowconfigure(2, weight=1)

        # Status panel (top left)
        status_panel = self.create_status_panel(dashboard_container)
        status_panel.grid(row=0, column=0, sticky="nsew", padx=(0, 10), pady=(0, 10))

        # Voice assistant control panel (top right)
        control_panel = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=15,
            border_width=1,
            border_color=self.colors["bg_light"]
        )
        control_panel.grid(row=0, column=1, sticky="nsew", padx=(10, 0), pady=(0, 10))

        # Control panel header with icon
        control_header = ctk.CTkFrame(control_panel, fg_color="transparent", height=50)
        control_header.pack(fill="x", padx=20, pady=(15, 5))

        # Control panel title with icon
        control_title = ctk.CTkLabel(
            control_header,
            text="Voice Assistant",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        control_title.pack(side="left")

        # Start/Stop button with improved styling
        self.toggle_button = ctk.CTkButton(
            control_panel,
            text="Start Voice Assistant",
            command=self.toggle_voice_assistant,
            fg_color=self.colors["status_green"],
            hover_color=self._adjust_color_brightness(self.colors["status_green"], 0.8),
            height=60,
            corner_radius=10,
            font=self.fonts["subtitle"],
            border_width=1,
            border_color=self._adjust_color_brightness(self.colors["status_green"], 1.2)
        )
        self.toggle_button.pack(fill="x", padx=20, pady=15)
        
        # Recording buttons container
        recording_buttons_frame = ctk.CTkFrame(control_panel, fg_color="transparent")
        recording_buttons_frame.pack(fill="x", padx=20, pady=10)

        # Record button
        self.record_button = ctk.CTkButton(
            recording_buttons_frame,
            text="Record",
            command=self.start_manual_recording,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            height=40,
            width=150,
            corner_radius=10
        )
        self.record_button.pack(side="left", fill="x", expand=True, padx=(0, 5))

        # Stop Recording button
        self.stop_record_button = ctk.CTkButton(
            recording_buttons_frame,
            text="Stop Recording",
            command=self.stop_manual_recording,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            height=40,
            width=150,
            corner_radius=10,
            state="disabled"
        )
        self.stop_record_button.pack(side="right", fill="x", expand=True, padx=(5, 0))

        # Add synthesizer bar to show voice detection
        self.synth_bar = SynthesizerBar(control_panel, self.colors, self.fonts)

        # Microphone sensitivity slider
        sensitivity_frame = ctk.CTkFrame(
            control_panel,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        sensitivity_frame.pack(fill="x", padx=20, pady=10)

        sensitivity_label = ctk.CTkLabel(
            sensitivity_frame,
            text="Microphone Sensitivity",
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"]
        )
        sensitivity_label.pack(anchor="w", padx=15, pady=(10, 5))

        sensitivity_control = ctk.CTkFrame(sensitivity_frame, fg_color="transparent")
        sensitivity_control.pack(fill="x", padx=15, pady=(0, 10))

        self.sensitivity_var = ctk.DoubleVar(value=0.5)
        self.sensitivity_slider = ctk.CTkSlider(
            sensitivity_control,
            from_=0.1,
            to=1.0,
            variable=self.sensitivity_var,
            width=200,
            progress_color=self.colors["accent_primary"],
            button_color=self.colors["accent_secondary"],
            button_hover_color=self.colors["accent_primary"]
        )
        self.sensitivity_slider.pack(side="left", fill="x", expand=True, padx=(0, 10))

        self.sensitivity_value = ctk.CTkLabel(
            sensitivity_control,
            text=f"{int(self.sensitivity_var.get() * 100)}%",
            font=self.fonts["small"],
            width=40,
            text_color=self.colors["text_dim"]
        )
        self.sensitivity_value.pack(side="right")

        # Update sensitivity value when slider changes
        def update_sensitivity(*args):
            self.sensitivity_value.configure(text=f"{int(self.sensitivity_var.get() * 100)}%")
            if hasattr(self, 'gain_var'):
                self.gain_var.set(self.sensitivity_var.get())

        self.sensitivity_var.trace_add("write", update_sensitivity)
        
        # Initialize gain variable for level meter
        self.gain_var = ctk.DoubleVar(value=self.sensitivity_var.get())

        # Status indicator with improved styling
        status_frame = ctk.CTkFrame(
            control_panel,
            fg_color=self.colors["bg_light"],
            corner_radius=10,
            height=50
        )
        status_frame.pack(fill="x", padx=20, pady=10)
        status_frame.pack_propagate(False)

        status_label = ctk.CTkLabel(
            status_frame,
            text="Status: Idle",
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"]
        )
        status_label.pack(side="left", padx=15, pady=10)

        self.status_indicator = ctk.CTkFrame(
            status_frame,
            fg_color=self.colors["status_gray"],
            width=20,
            height=20,
            corner_radius=10
        )
        self.status_indicator.pack(side="right", padx=15)

        # Transcription section (middle)
        transcription_frame = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=15,
            border_width=1,
            border_color=self.colors["bg_light"]
        )
        transcription_frame.grid(row=1, column=0, columnspan=2, sticky="nsew", pady=(0, 10))
            
        # Transcription header
        transcription_header = ctk.CTkFrame(transcription_frame, fg_color="transparent", height=50)
        transcription_header.pack(fill="x", padx=20, pady=(15, 5))
        
        transcription_title = ctk.CTkLabel(
            transcription_header,
            text="📝 Transcription",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        transcription_title.pack(side="left")
        
        # Controls frame
        controls = ctk.CTkFrame(transcription_header, fg_color="transparent")
        controls.pack(side="right")
        
        # Clear button
        clear_button = ctk.CTkButton(
            controls,
            text="Clear",
            command=lambda: self.clear_transcription(),
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            width=80
        )
        clear_button.pack(side="right", padx=(0, 10))
        
        # Enter button
        self.enter_button = ctk.CTkButton(
            controls,
            text="Enter",
            command=self.process_transcription,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            width=100,
            state="disabled"
        )
        self.enter_button.pack(side="right")
        
        # Transcription display
        self.transcription_display = ctk.CTkTextbox(
            transcription_frame,
            fg_color=self.colors["bg_light"],
            text_color=self.colors["text_bright"],
            font=self.fonts["large"],
            corner_radius=10,
            border_width=1,
            border_color=self.colors["bg_light"],
            height=150
        )
        self.transcription_display.pack(fill="both", expand=True, padx=20, pady=(5, 20))
        
        # Configure text tags
        self.transcription_display._textbox.tag_configure("timestamp", foreground=self.colors["accent_secondary"])
        self.transcription_display._textbox.tag_configure("transcription", foreground=self.colors["text_bright"])
        
        # Add initial message
        self.transcription_display.configure(state="normal")
        self.transcription_display.insert("end", "Transcribed text will appear here...")
        self.transcription_display.configure(state="disabled")

        # Voice commands section (bottom)
        text_display_frame = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=15,
            border_width=1,
            border_color=self.colors["bg_light"]
        )
        text_display_frame.grid(row=2, column=0, columnspan=2, sticky="nsew")
                
        # Text display header
        text_header = ctk.CTkFrame(text_display_frame, fg_color="transparent", height=50)
        text_header.pack(fill="x", padx=20, pady=(15, 5))
        
        text_title = ctk.CTkLabel(
            text_header,
            text="🔊 Voice Commands",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        text_title.pack(side="left")
        
        # Clear button for text display
        clear_text_button = ctk.CTkButton(
            text_header,
            text="Clear",
            command=lambda: self.clear_text_display(),
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            width=80
        )
        clear_text_button.pack(side="right")
        
        # Text display area
        self.text_display = ctk.CTkTextbox(
            text_display_frame,
            fg_color=self.colors["bg_light"],
            text_color=self.colors["text_bright"],
            font=self.fonts["large"],
            corner_radius=10,
            border_width=1,
            border_color=self.colors["bg_light"],
            height=200
        )
        self.text_display.pack(fill="both", expand=True, padx=20, pady=(5, 20))
        
        # Configure text tags
        self.text_display._textbox.tag_configure("timestamp", foreground=self.colors["accent_secondary"])
        self.text_display._textbox.tag_configure("command", foreground=self.colors["accent_primary"])
        self.text_display._textbox.tag_configure("system", foreground=self.colors["status_blue"])
        
        # Add initial message
        self.text_display.configure(state="normal")
        self.text_display.insert("end", "Voice commands will appear here after starting the voice assistant...")
        self.text_display.configure(state="disabled")

        # Initialize monitor visualization
        self.app.after(500, self.refresh_monitor_visualization)

    def create_synthesizer_bar(self, parent):
        """Create a synthesizer bar to visualize voice detection"""
        # Use the new SynthesizerBar class if available
        try:
            from synthesizer_bar import SynthesizerBar
            self.synth_bar = SynthesizerBar(parent, self.colors, self.fonts)
            return
        except ImportError:
            logging.warning(
                "SynthesizerBar class not found, using fallback implementation")

        # Fallback implementation
        synth_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10,
            height=80
        )
        synth_frame.pack(fill="x", padx=20, pady=10)

        # Synthesizer label
        synth_label = ctk.CTkLabel(
            synth_frame,
            text="Voice Detection",
            font=self.fonts["normal"],
            text_color=self.colors["text_bright"]
        )
        synth_label.pack(anchor="w", padx=15, pady=(10, 5))

        # Create level meter canvas
        self.level_canvas = ctk.CTkCanvas(
            synth_frame,
            bg=self.colors["bg_dark"],
            highlightthickness=0,
            height=30
        )
        self.level_canvas.pack(fill="x", padx=15, pady=(0, 10))

        # Initialize level meter with zero level
        self.app.after(100, lambda: self._update_level_meter(0))

    def create_chatbots_tab(self):
        """Create the chatbots tab content"""
        # Main container
        chatbots_container = ctk.CTkFrame(
            self.tab_view.tab("Chatbots"),
            fg_color="transparent"
        )
        chatbots_container.pack(fill="both", expand=True, padx=20, pady=20)

        # Title and add button row
        title_frame = ctk.CTkFrame(chatbots_container, fg_color="transparent")
        title_frame.pack(fill="x", pady=(0, 15))

        # Title with icon
        title_label = ctk.CTkLabel(
            title_frame,
            text="Chatbot Management",
            font=ctk.CTkFont(size=24, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title_label.pack(side="left")

        # Add chatbot button
        add_button = ctk.CTkButton(
            title_frame,
            text="Add New Chatbot",
            command=self.show_add_chatbot_dialog,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            width=120
        )
        add_button.pack(side="right")

        # Search frame
        search_frame = ctk.CTkFrame(
            chatbots_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=10,
            height=50
        )
        search_frame.pack(fill="x", pady=(0, 15))
        search_frame.pack_propagate(False)

        # Search icon
        search_icon = ctk.CTkLabel(
            search_frame,
            text="🔍",
            font=ctk.CTkFont(size=16),
            width=30
        )
        search_icon.pack(side="left", padx=(15, 0))

        # Search entry
        self.search_var = ctk.StringVar()
        self.search_var.trace_add(
            "write", lambda *args: self.filter_chatbot_list())
        search_entry = ctk.CTkEntry(
            search_frame,
            placeholder_text="Search chatbots...",
            textvariable=self.search_var,
            border_width=0,
            fg_color="transparent",
            height=40
        )
        search_entry.pack(side="left", fill="x", expand=True, padx=10)

        # Chatbot list container
        self.chatbot_list_frame = ctk.CTkScrollableFrame(
            chatbots_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        self.chatbot_list_frame.pack(fill="both", expand=True)

        # Refresh chatbot list
        self.refresh_chatbots()

    def create_about_tab(self):
        """Create the about tab content"""
        # Main container
        about_container = ctk.CTkFrame(
            self.tab_view.tab("About"),
            fg_color="transparent"
        )
        about_container.pack(fill="both", expand=True, padx=20, pady=20)

        # Create a scrollable frame for the about content
        about_scroll = ctk.CTkScrollableFrame(
            about_container,
            fg_color="transparent"
        )
        about_scroll.pack(fill="both", expand=True)

        # Logo and title
        logo_frame = ctk.CTkFrame(about_scroll, fg_color="transparent")
        logo_frame.pack(fill="x", pady=(0, 20))

        # App title
        title_label = ctk.CTkLabel(
            logo_frame,
            text="DragonVoice",
            font=ctk.CTkFont(size=32, weight="bold"),
            text_color=self.colors["accent_primary"]
        )
        title_label.pack(pady=(0, 5))

        # Version
        version_label = ctk.CTkLabel(
            logo_frame,
            text="Version 2.0",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"]
        )
        version_label.pack()

        # Description
        description_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        description_frame.pack(fill="x", pady=10, padx=5)

        description_label = ctk.CTkLabel(
            description_frame,
            text="DragonVoice is an advanced voice assistant that integrates with multiple AI chatbots.\n"
            "It provides a seamless voice interface for interacting with AI models and controlling your computer.",
            font=ctk.CTkFont(
                size=14),
            text_color=self.colors["text_normal"],
            wraplength=600,
            justify="left")
        description_label.pack(padx=20, pady=20)

        # Features
        features_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        features_frame.pack(fill="x", pady=10, padx=5)

        features_title = ctk.CTkLabel(
            features_frame,
            text="Key Features",
            font=ctk.CTkFont(size=18, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        features_title.pack(anchor="w", padx=20, pady=(15, 10))

        features = [
            "🎤 Voice recognition with OpenAI Whisper",
            "🤖 Multiple AI chatbot integrations",
            "⌨️ System control through voice commands",
            "📊 Real-time system monitoring",
            "🎨 Customizable themes and appearance",
            "🔧 Advanced configuration options"
        ]

        for feature in features:
            feature_label = ctk.CTkLabel(
                features_frame,
                text=feature,
                font=ctk.CTkFont(size=14),
                text_color=self.colors["text_normal"],
                anchor="w"
            )
            feature_label.pack(anchor="w", padx=20, pady=5)

        # Credits
        credits_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        credits_frame.pack(fill="x", pady=10, padx=5)

        credits_title = ctk.CTkLabel(
            credits_frame,
            text="Credits",
            font=ctk.CTkFont(size=18, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        credits_title.pack(anchor="w", padx=20, pady=(15, 10))

        credits_label = ctk.CTkLabel(
            credits_frame,
            text="Developed by: DragonVoice Team\n"
                 "UI Framework: CustomTkinter\n"
                 "Voice Recognition: OpenAI Whisper\n"
                 "Special thanks to all contributors and testers",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            justify="left"
        )
        credits_label.pack(anchor="w", padx=20, pady=(0, 15))

        # Links
        links_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        links_frame.pack(fill="x", pady=10, padx=5)

        links_title = ctk.CTkLabel(
            links_frame,
            text="Links",
            font=ctk.CTkFont(size=18, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        links_title.pack(anchor="w", padx=20, pady=(15, 10))

        # Function to open links
        def open_link(url):
            import webbrowser
            webbrowser.open(url)

        # Website link
        website_button = ctk.CTkButton(
            links_frame,
            text="Visit Website",
            command=lambda: open_link("https://dragonvoice.ai"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        website_button.pack(anchor="w", padx=20, pady=5)

        # Documentation link
        docs_button = ctk.CTkButton(
            links_frame,
            text="Documentation",
            command=lambda: open_link("https://docs.dragonvoice.ai"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        docs_button.pack(anchor="w", padx=20, pady=5)

        # GitHub link
        github_button = ctk.CTkButton(
            links_frame,
            text="GitHub Repository",
            command=lambda: open_link("https://github.com/dragonvoice/dragonvoice"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"])
        github_button.pack(anchor="w", padx=20, pady=(5, 15))

    def create_settings_advanced_tab(self, parent):
        """Create the advanced settings tab content"""
        # Main container
        container = ctk.CTkFrame(parent, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)

        # Logging settings section
        logging_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        logging_frame.pack(fill="x", pady=(0, 15))

        # Section title
        logging_title = ctk.CTkLabel(
            logging_frame,
            text="Logging Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        logging_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Log level
        log_level_frame = ctk.CTkFrame(logging_frame, fg_color="transparent")
        log_level_frame.pack(fill="x", padx=15, pady=5)

        log_level_label = ctk.CTkLabel(
            log_level_frame,
            text="Log Level",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        log_level_label.pack(side="left")

        self.log_level_var = ctk.StringVar(value="INFO")
        log_level_dropdown = ctk.CTkOptionMenu(
            log_level_frame,
            values=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
            variable=self.log_level_var,
            width=200
        )
        log_level_dropdown.pack(side="left", padx=10)

        # Enable file logging
        file_logging_frame = ctk.CTkFrame(
            logging_frame, fg_color="transparent")
        file_logging_frame.pack(fill="x", padx=15, pady=5)

        file_logging_label = ctk.CTkLabel(
            file_logging_frame,
            text="File Logging",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        file_logging_label.pack(side="left")

        self.file_logging_var = ctk.BooleanVar(value=True)
        file_logging_switch = ctk.CTkSwitch(
            file_logging_frame,
            text="",
            variable=self.file_logging_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        file_logging_switch.pack(side="left", padx=10)

        # Performance settings section
        performance_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        performance_frame.pack(fill="x", pady=(0, 15))

        # Section title
        performance_title = ctk.CTkLabel(
            performance_frame,
            text="Performance Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        performance_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Hardware acceleration
        hardware_frame = ctk.CTkFrame(
            performance_frame, fg_color="transparent")
        hardware_frame.pack(fill="x", padx=15, pady=5)

        hardware_label = ctk.CTkLabel(
            hardware_frame,
            text="Hardware Acceleration",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        hardware_label.pack(side="left")

        self.hardware_var = ctk.BooleanVar(value=True)
        hardware_switch = ctk.CTkSwitch(
            hardware_frame,
            text="",
            variable=self.hardware_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        hardware_switch.pack(side="left", padx=10)

        # Thread count
        thread_frame = ctk.CTkFrame(performance_frame, fg_color="transparent")
        thread_frame.pack(fill="x", padx=15, pady=5)

        thread_label = ctk.CTkLabel(
            thread_frame,
            text="Worker Threads",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        thread_label.pack(side="left")

        self.thread_var = ctk.IntVar(value=4)
        thread_slider = ctk.CTkSlider(
            thread_frame,
            from_=1,
            to=16,
            number_of_steps=15,
            variable=self.thread_var,
            width=200
        )
        thread_slider.pack(side="left", padx=10)

        thread_value = ctk.CTkLabel(
            thread_frame,
            textvariable=self.thread_var,
            width=30
        )
        thread_value.pack(side="left", padx=5)

        # Memory limit
        memory_frame = ctk.CTkFrame(performance_frame, fg_color="transparent")
        memory_frame.pack(fill="x", padx=15, pady=5)

        memory_label = ctk.CTkLabel(
            memory_frame,
            text="Memory Limit (MB)",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        memory_label.pack(side="left")

        self.memory_var = ctk.IntVar(value=1024)
        memory_slider = ctk.CTkSlider(
            memory_frame,
            from_=256,
            to=4096,
            number_of_steps=15,
            variable=self.memory_var,
            width=200
        )
        memory_slider.pack(side="left", padx=10)

        memory_value = ctk.CTkLabel(
            memory_frame,
            textvariable=self.memory_var,
            width=50
        )
        memory_value.pack(side="left", padx=5)

        # Reset button
        reset_button = ctk.CTkButton(
            container,
            text="Reset to Defaults",
            command=lambda: self.reset_advanced_settings(),
            fg_color=self.colors["bg_medium"],
            hover_color=self.colors["bg_light"],
            width=150
        )
        reset_button.pack(anchor="e", pady=10)

        return container

    def reset_advanced_settings(self):
        """Reset advanced settings to defaults"""
        self.log_level_var.set("INFO")
        self.file_logging_var.set(True)
        self.hardware_var.set(True)
        self.thread_var.set(4)
        self.memory_var.set(1024)
        self.update_status("Advanced settings reset to defaults")

    def apply_theme(self, theme_name):
        """Apply the selected theme"""
        if theme_name in self.color_schemes:
            self.colors = self.color_schemes[theme_name]
            self.config["theme"] = theme_name
            self.save_configuration(show_notification=False)
            # Refresh UI with new theme
            self.setup_theme()
            self.refresh_ui()

    def show_add_chatbot_dialog(self):
        """Show dialog to add a new chatbot"""
        dialog = ctk.CTkToplevel(self.app)
        dialog.title("Add New Chatbot")
        dialog.geometry("400x500")
        dialog.transient(self.app)
        dialog.grab_set()

        # Create form fields
        name_label = ctk.CTkLabel(
            dialog,
            text="Chatbot Name",
            text_color=self.colors["text_bright"]
        )
        name_label.pack(anchor="w", padx=20, pady=(20, 0))

        name_entry = ctk.CTkEntry(dialog, width=360)
        name_entry.pack(anchor="w", padx=20, pady=(0, 10))

        type_label = ctk.CTkLabel(
            dialog,
            text="Chatbot Type",
            text_color=self.colors["text_bright"]
        )
        type_label.pack(anchor="w", padx=20, pady=(10, 0))

        type_var = ctk.StringVar(value="GPT")
        type_dropdown = ctk.CTkOptionMenu(
            dialog,
            values=["GPT", "Claude", "Gemini", "Custom"],
            variable=type_var,
            width=360
        )
        type_dropdown.pack(anchor="w", padx=20, pady=(0, 10))

        api_key_label = ctk.CTkLabel(
            dialog,
            text="API Key",
            text_color=self.colors["text_bright"]
        )
        api_key_label.pack(anchor="w", padx=20, pady=(10, 0))

        api_key_entry = ctk.CTkEntry(dialog, width=360, show="*")
        api_key_entry.pack(anchor="w", padx=20, pady=(0, 10))

        # Add chatbot button
        def add_chatbot():
            name = name_entry.get()
            chatbot_type = type_var.get()
            api_key = api_key_entry.get()

            if name and chatbot_type and api_key:
                # Add to config
                if "chatbots" not in self.config:
                    self.config["chatbots"] = {}

                self.config["chatbots"][name] = {
                    "type": chatbot_type,
                    "api_key": api_key,
                    "status": "Ready",
                    "color": self.colors["accent_primary"],
                    "icon": "🤖"
                }

                self.save_configuration()
                self.refresh_chatbot_list()
                dialog.destroy()
            else:
                # Show error
                error_label.configure(text="Please fill in all fields")

        add_button = ctk.CTkButton(
            dialog,
            text="Add Chatbot",
            command=add_chatbot,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        add_button.pack(anchor="center", pady=20)

        # Error label
        error_label = ctk.CTkLabel(
            dialog,
            text="",
            text_color=self.colors["error"]
        )
        error_label.pack(anchor="center")

    def refresh_chatbot_list(self):
        """Refresh the list of chatbots in settings"""
        # Clear existing items
        for widget in self.chatbot_list_frame.winfo_children():
            widget.destroy()

        # Add header
        header = ctk.CTkFrame(
            self.chatbot_list_frame,
            fg_color="transparent"
        )
        header.pack(fill="x", padx=15, pady=5)

        ctk.CTkLabel(
            header,
            text="Name",
            font=ctk.CTkFont(weight="bold"),
            text_color=self.colors["text_bright"],
            width=100
        ).pack(side="left")

        ctk.CTkLabel(
            header,
            text="Type",
            font=ctk.CTkFont(weight="bold"),
            text_color=self.colors["text_bright"],
            width=100
        ).pack(side="left")

        ctk.CTkLabel(
            header,
            text="Status",
            font=ctk.CTkFont(weight="bold"),
            text_color=self.colors["text_bright"],
            width=100
        ).pack(side="left")

        # Add chatbots
        for name, config in self.config.get("chatbots", {}).items():
            self.add_chatbot_list_item(name, config)

    def add_chatbot_list_item(self, name, config):
        """Add a single chatbot item to the list"""
        # Create item frame with hover effect
        item = ctk.CTkFrame(
            self.chatbot_list_frame,
            fg_color=self.colors["bg_dark"],
            corner_radius=10,
            height=70
        )
        item.pack(fill="x", padx=5, pady=5)
        item.pack_propagate(False)

        # Add hover effect
        def on_enter(e):
            item.configure(fg_color=self.colors["bg_light"])

        def on_leave(e):
            item.configure(fg_color=self.colors["bg_dark"])

        item.bind("<Enter>", on_enter)
        item.bind("<Leave>", on_leave)

        # Icon and name container
        info_frame = ctk.CTkFrame(
            item,
            fg_color="transparent"
        )
        info_frame.pack(side="left", fill="y", padx=10)

        # Icon with colored background
        icon_frame = ctk.CTkFrame(
            info_frame,
            fg_color=config.get("color", self.colors["accent_primary"]),
            width=40,
            height=40,
            corner_radius=20
        )
        icon_frame.pack(side="left", padx=(0, 10))
        icon_frame.pack_propagate(False)

        icon_label = ctk.CTkLabel(
            icon_frame,
            text=config.get("icon", "🤖"),
            font=ctk.CTkFont(size=20)
        )
        icon_label.place(relx=0.5, rely=0.5, anchor="center")

        # Name and type
        text_frame = ctk.CTkFrame(
            info_frame,
            fg_color="transparent"
        )
        text_frame.pack(side="left", fill="y")

        name_label = ctk.CTkLabel(
            text_frame,
            text=name,
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        name_label.pack(anchor="w")

        type_label = ctk.CTkLabel(
            text_frame,
            text=config.get("type", "Unknown"),
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        type_label.pack(anchor="w")

        # Status indicator
        status_color = self.colors["status_green"] if config.get(
            "status") == "Ready" else self.colors["status_red"]
        status_frame = ctk.CTkFrame(
            item,
            fg_color="transparent"
        )
        status_frame.pack(side="right", fill="y", padx=10)

        status_dot = ctk.CTkLabel(
            status_frame,
            text="●",
            font=ctk.CTkFont(size=20),
            text_color=status_color
        )
        status_dot.pack(side="right", padx=5)

        status_label = ctk.CTkLabel(
            status_frame,
            text=config.get("status", "Unknown"),
            font=ctk.CTkFont(size=12),
            text_color=status_color
        )
        status_label.pack(side="right")

        # Make the entire item clickable
        item.bind(
            "<Button-1>",
            lambda e: self.show_chatbot_settings(
                name,
                config))

    def delete_chatbot(self, name):
        """Delete a chatbot from the configuration"""
        if name in self.config.get("chatbots", {}):
            del self.config["chatbots"][name]
            self.save_configuration()
            self.refresh_chatbot_list()
            # Also refresh the dashboard
            self.add_sample_chatbot_cards()

    def run(self):
        """Run the application main loop"""
        try:
            # Log startup
            logging.info("Starting DragonVoice application")

            # Update status
            self.update_status("Application started successfully")

            # Start the main event loop
            self.app.mainloop()

        except Exception as e:
            logging.error(f"Error in main loop: {str(e)}")
            raise

    def create_help_getting_started(self, parent):
        """Create the getting started help content"""
        # Welcome section
        welcome_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
#!/usr/bin/env python3
"""
Dragon Voice GUI - Main application interface for Dragon Voice Project
"""

from whisper_integration import WhisperRecognizer
import os
import sys
import json
import time
import logging
import webbrowser
import threading
from datetime import datetime
from pathlib import Path

# GUI libraries
import tkinter as tk
from tkinter import messagebox
import customtkinter as ctk
from PIL import Image, ImageTk

# System monitoring
import psutil
import platform

# Window management
import pygetwindow as gw
import pyautogui
import sounddevice as sd
import numpy as np
import tempfile
import os
import time
import threading

# Custom components
from synthesizer_bar import SynthesizerBar

# Try to import soundfile, but don't fail if it's not available
try:
    import soundfile as sf
    SOUNDFILE_AVAILABLE = True
except ImportError:
    SOUNDFILE_AVAILABLE = False
    print("Warning: soundfile module not found. Some audio features will be limited.")

# Configure logging
logging.basicConfig(
    level=logging.WARNING,  # Changed from INFO to WARNING
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("dragon_gui.log"),
        logging.StreamHandler()
    ]
)

# Constants
DEFAULT_CONFIG_PATH = "src/config.json"
ASSETS_DIR = os.path.join("src", "assets")

# Add Whisper integration


class DragonVoiceGUI:
    """
    Main GUI class for the Dragon Voice Project

    Provides a modern, feature-rich interface for controlling the voice assistant,
    managing chatbots, and configuring system settings.
    """

    def __init__(self, config_path=DEFAULT_CONFIG_PATH):
        """Initialize the DragonVoice GUI application"""
        logging.info("Initializing DragonVoiceGUI")
        logging.info("Initializing DragonVoice GUI")

        try:
            # Initialize logging
            self.setup_logging()

            # Initialize state variables
            self.recording_active = False
            self.continuous_recording = False  # Flag for continuous recording
            self.is_fullscreen = False

            # Create main application window
            self.app = ctk.CTk()
            self.app.title("DragonVoice")
            self.app.geometry("1200x800")
            self.app.minsize(900, 600)
            
            # Center window on screen
            screen_width = self.app.winfo_screenwidth()
            screen_height = self.app.winfo_screenheight()
            x = (screen_width - 1200) // 2
            y = (screen_height - 800) // 2
            self.app.geometry(f"1200x800+{x}+{y}")

            # Load configuration
            self.config_path = config_path
            self.config = self.load_config()
            logging.info(f"Configuration loaded from {config_path}")

            # Set up theme and colors
            self.setup_theme()

            # Initialize Whisper recognizer
            self.init_whisper_recognizer()

            # Set up UI components
            self.setup_ui()

            # Start system monitoring
            self.start_system_monitoring()

        except Exception as e:
            logging.error(f"Error initializing DragonVoiceGUI: {str(e)}")
            raise

    def setup_logging(self):
        """Set up logging configuration"""
        # Check if logging is already configured
        if not logging.getLogger().handlers:
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - %(message)s'
            )
        logging.info("Logging setup complete")

    def setup_theme(self):
        """Set up the theme and colors for the application"""
        # Set appearance mode
        ctk.set_appearance_mode("dark")

        # Define color schemes
        self.color_schemes = {
            "dark": {
                "bg_dark": "#1A1A2E",
                "bg_medium": "#16213E",
                "bg_light": "#0F3460",
                "accent_primary": "#E94560",
                "accent_secondary": "#0F52BA",
                "text_bright": "#FFFFFF",
                "text_normal": "#E0E0E0",
                "text_dim": "#A0A0A0",
                "status_green": "#4CAF50",
                "status_yellow": "#FFC107",
                "status_red": "#F44336",
                "status_blue": "#2196F3",
                "status_gray": "#757575"
            },
            "light": {
                "bg_dark": "#F0F0F0",
                "bg_medium": "#E0E0E0",
                "bg_light": "#D0D0D0",
                "accent_primary": "#E94560",
                "accent_secondary": "#0F52BA",
                "text_bright": "#000000",
                "text_normal": "#202020",
                "text_dim": "#505050",
                "status_green": "#4CAF50",
                "status_yellow": "#FFC107",
                "status_red": "#F44336",
                "status_blue": "#2196F3",
                "status_gray": "#757575"
            },
            "dragon": {
                "bg_dark": "#0A1931",
                "bg_medium": "#150E56",
                "bg_light": "#1A1A40",
                "accent_primary": "#D82148",
                "accent_secondary": "#6EBF8B",
                "text_bright": "#FFFFFF",
                "text_normal": "#E0E0E0",
                "text_dim": "#A0A0A0",
                "status_green": "#4CAF50",
                "status_yellow": "#FFC107",
                "status_red": "#F44336",
                "status_blue": "#2196F3",
                "status_gray": "#757575"
            }
        }

        # Set default color scheme
        self.colors = self.color_schemes["dragon"]

        # Define fonts
        self.fonts = {
            "header": ctk.CTkFont(family="Segoe UI", size=28, weight="bold"),
            "title": ctk.CTkFont(family="Segoe UI", size=20, weight="bold"),
            "subtitle": ctk.CTkFont(family="Segoe UI", size=16, weight="bold"),
            "normal": ctk.CTkFont(family="Segoe UI", size=14),
            "small": ctk.CTkFont(family="Segoe UI", size=12),
            "tiny": ctk.CTkFont(family="Segoe UI", size=10),
            "mono": ctk.CTkFont(family="Consolas", size=12),
            # Added the 'large' font definition
            "large": ctk.CTkFont(family="Segoe UI", size=18)
        }

    def init_whisper_recognizer(self):
        """Initialize the Whisper recognizer"""
        try:
            # Initialize API keys with default values
            self.openai_api_key = "j3ydNXEmQFyDKwl5mWxSzcvdZcTLJw1t"
            self.base_url = "https://api.deepinfra.com/v1/openai"
            
            # Initialize WhisperRecognizer with error handling
            if self.openai_api_key:
                self.whisper_recognizer = WhisperRecognizer(
                    api_key=self.openai_api_key,
                    base_url=self.base_url
                )
                # Initialize recording state
                self.recording_active = False
                self.continuous_recording = False
                self.audio_data = []
                logging.info("WhisperRecognizer initialized successfully")
            else:
                logging.warning("No OpenAI API key found, WhisperRecognizer not initialized")
                self.whisper_recognizer = None
        except Exception as e:
            logging.error(f"Failed to initialize WhisperRecognizer: {str(e)}")
            self.whisper_recognizer = None

    def setup_ui(self):
        """Set up the main UI components"""
        try:
            # Create the main container
            self.main_container = ctk.CTkFrame(
                self.app, fg_color="transparent")
            self.main_container.pack(fill="both", expand=True)

            # Create UI components in the correct order
            self.create_footer()  # Create footer first to ensure status_label exists
            self.create_header()
            self.create_tabs()

            # Start system monitoring
            self.start_system_monitoring()

            # Update status
            self.update_status("Application initialized successfully")

            # Log successful UI setup
            logging.info("UI setup completed successfully")

        except Exception as e:
            logging.error(f"Error setting up UI: {str(e)}", exc_info=True)
            # Show error in a messagebox if possible
            try:
                import tkinter.messagebox as messagebox
                messagebox.showerror(
                    "UI Setup Error",
                    f"Error setting up UI:\n{str(e)}")
            except BaseException:
                pass

    def create_header(self):
        """Create a modern application header with logo and controls"""
        # Create header frame with gradient background
        self.header_frame = ctk.CTkFrame(
            self.main_container,
            fg_color=self.colors["bg_dark"],
            corner_radius=0,
            height=90
        )
        self.header_frame.pack(fill="x", pady=0)
        self.header_frame.pack_propagate(False)

        # Create gradient effect for header
        self.header_canvas = ctk.CTkCanvas(
            self.header_frame,
            bg=self.colors["bg_dark"],
            highlightthickness=0,
            height=90
        )
        self.header_canvas.pack(fill="x", side="top")

        # Draw gradient
        def draw_gradient():
            width = self.header_canvas.winfo_width()
            if width <= 1:  # Not yet properly initialized
                self.app.after(100, draw_gradient)
                return

            height = 90
            # Create a more sophisticated gradient
            for i in range(width):
                # Calculate gradient position (0 to 1)
                pos = i / width

                # Create a gradient with accent color highlights
                if pos < 0.2:  # First section - dark to medium with accent hint
                    ratio = pos / 0.2
                    r1, g1, b1 = self.hex_to_rgb(self.colors["bg_dark"])
                    r2, g2, b2 = self.hex_to_rgb(self.colors["bg_medium"])
                    r3, g3, b3 = self.hex_to_rgb(self.colors["accent_primary"])

                    # Mix colors with a hint of accent
                    r = r1 + (r2 - r1) * ratio + (r3 - r1) * ratio * 0.1
                    g = g1 + (g2 - g1) * ratio + (g3 - g1) * ratio * 0.1
                    b = b1 + (b2 - b1) * ratio + (b3 - b1) * ratio * 0.1
                elif pos < 0.8:  # Middle section - medium to medium with subtle variation
                    ratio = (pos - 0.2) / 0.6
                    r1, g1, b1 = self.hex_to_rgb(self.colors["bg_medium"])
                    r2, g2, b2 = self.hex_to_rgb(
                        self._adjust_color_brightness(
                            self.colors["bg_medium"], 1.1))

                    r = r1 + (r2 - r1) * ratio
                    g = g1 + (g2 - g1) * ratio
                    b = b1 + (b2 - b1) * ratio
                else:  # Last section - medium to dark with accent hint
                    ratio = (pos - 0.8) / 0.2
                    r1, g1, b1 = self.hex_to_rgb(self.colors["bg_medium"])
                    r2, g2, b2 = self.hex_to_rgb(self.colors["bg_dark"])
                    r3, g3, b3 = self.hex_to_rgb(
                        self.colors["accent_secondary"])

                    # Mix colors with a hint of accent
                    r = r1 + (r2 - r1) * ratio + (r3 - r1) * ratio * 0.1
                    g = g1 + (g2 - g1) * ratio + (g3 - g1) * ratio * 0.1
                    b = b1 + (b2 - b1) * ratio + (b3 - b1) * ratio * 0.1

                color = f'#{int(r):02x}{int(g):02x}{int(b):02x}'
                self.header_canvas.create_line(i, 0, i, height, fill=color)

            # Add accent line at bottom with glow effect
            for i in range(3):
                alpha = 0.3 + (0.7 * (i / 2))  # Increasing opacity
                glow_color = self._adjust_color_brightness(
                    self.colors["accent_primary"], alpha)
            self.header_canvas.create_line(
                0, height - 3 + i, width, height - 3 + i,
                fill=glow_color,
                width=1
            )

        # Schedule gradient drawing
        self.app.after(100, draw_gradient)

        # Create a container for the header content
        header_content = ctk.CTkFrame(
            self.header_frame, fg_color="transparent")
        header_content.place(
            relx=0.5,
            rely=0.5,
            anchor="center",
            relwidth=1,
            relheight=0.8)

        # Left side - Logo and title
        logo_frame = ctk.CTkFrame(header_content, fg_color="transparent")
        logo_frame.pack(side="left", padx=(30, 0))

        # Try to load logo image if available
        try:
            logo_path = os.path.join("src", "assets", "dragon_logo.png")
            if os.path.exists(logo_path):
                logo_image = ctk.CTkImage(
                    light_image=Image.open(logo_path),
                    dark_image=Image.open(logo_path),
                    size=(40, 40)
                )
                logo_label = ctk.CTkLabel(
                    logo_frame,
                    image=logo_image,
                    text=""
                )
                logo_label.pack(side="left", padx=(0, 15))
        except Exception as e:
            logging.error(f"Failed to load logo: {str(e)}")

        # App title with modern styling
        title_label = ctk.CTkLabel(
            logo_frame,
            text="DragonVoice",
            font=self.fonts["header"],
            text_color=self.colors["text_bright"]
        )
        title_label.pack(side="left")

        # Version with pill background
        version_pill = ctk.CTkFrame(
            logo_frame,
            fg_color=self.colors["accent_primary"],
            corner_radius=12,
            height=24
        )
        version_pill.pack(side="left", padx=(10, 0), pady=(8, 0))

        version_label = ctk.CTkLabel(
            version_pill,
            text="v2.0",
            font=self.fonts["small"],
            text_color=self.colors["text_bright"]
        )
        version_label.pack(padx=10, pady=2)

        # Center - Status indicator
        status_frame = ctk.CTkFrame(header_content, fg_color="transparent")
        status_frame.pack(side="left", expand=True)

        # Right side - Controls
        controls_frame = ctk.CTkFrame(header_content, fg_color="transparent")
        controls_frame.pack(side="right", padx=(0, 30))

        # Microphone selector with improved styling
        mic_frame = ctk.CTkFrame(
            controls_frame,
            fg_color=self.colors["bg_light"],
            corner_radius=8
        )
        mic_frame.pack(side="left", padx=(0, 15), pady=5)

        mic_label = ctk.CTkLabel(
            mic_frame,
            text="Microphone:",
            font=self.fonts["small"],
            text_color=self.colors["text_normal"]
        )
        mic_label.pack(side="left", padx=(10, 5), pady=5)

        # Microphone dropdown
        self.mic_var = ctk.StringVar(value="Default Microphone")
        self.mic_dropdown = ctk.CTkOptionMenu(
            mic_frame,
            values=["Default Microphone"],
            variable=self.mic_var,
            width=150,
            dynamic_resizing=True,
            fg_color=self.colors["bg_medium"],
            button_color=self.colors["accent_primary"],
            button_hover_color=self.colors["accent_secondary"],
            dropdown_fg_color=self.colors["bg_medium"]
        )
        self.mic_dropdown.pack(side="left", padx=(0, 10), pady=5)

        # Theme toggle button
        theme_button = ctk.CTkButton(
            controls_frame,
            text="",
            width=36,
            height=36,
            corner_radius=10,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            text_color=self.colors["text_bright"],
            command=self.toggle_theme
        )
        theme_button.pack(side="left", padx=(0, 10))

        # Settings button
        settings_button = ctk.CTkButton(
            controls_frame,
            text="Settings",
            width=100,
            height=36,
            corner_radius=10,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            text_color=self.colors["text_bright"],
            command=self.show_settings
        )
        settings_button.pack(side="left", padx=(0, 10))

        # Help button
        help_button = ctk.CTkButton(
            controls_frame,
            text="Help",
            width=80,
            height=36,
            corner_radius=10,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            text_color=self.colors["text_bright"],
            command=self.show_help
        )
        help_button.pack(side="left")

        # Refresh microphone list
        self.refresh_mic_list()

    def hex_to_rgb(self, hex_color):
        """Convert hex color to RGB tuple"""
        hex_color = hex_color.lstrip('#')
        return tuple(int(hex_color[i:i + 2], 16) for i in (0, 2, 4))

    def show_settings(self):
        """Show the settings dialog"""
        # Switch to the Configuration tab
        self.tab_view.set("Configuration")

    def show_help(self):
        """Show the help dialog"""
        # Create a new top-level window
        help_window = ctk.CTkToplevel(self.app)
        help_window.title("DragonVoice Help")
        help_window.geometry("800x600")
        help_window.minsize(800, 600)
        help_window.grab_set()  # Make window modal

        # Set window icon
        if platform.system() == "Windows":
            try:
                icon_path = os.path.join(
                    os.path.dirname(
                        os.path.abspath(__file__)),
                    "assets",
                    "dragon_icon.ico")
                if os.path.exists(icon_path):
                    help_window.iconbitmap(icon_path)
            except Exception as e:
                print(f"Could not set help window icon: {e}")

        # Create tab view for help content
        help_tabs = ctk.CTkTabview(
            help_window,
            fg_color=self.colors["bg_dark"],
            segmented_button_fg_color=self.colors["bg_medium"],
            segmented_button_selected_color=self.colors["accent_primary"],
            segmented_button_selected_hover_color=self.colors["accent_secondary"],
            segmented_button_unselected_color=self.colors["bg_medium"],
            segmented_button_unselected_hover_color=self.colors["bg_light"])
        help_tabs.pack(fill="both", expand=True, padx=20, pady=20)

        # Add tabs
        help_tabs.add("Getting Started")
        help_tabs.add("Voice Commands")
        help_tabs.add("Chatbots")
        help_tabs.add("Troubleshooting")
        help_tabs.add("About")

        # Create content for each tab
        self.create_help_getting_started(help_tabs.tab("Getting Started"))
        self.create_help_voice_commands(help_tabs.tab("Voice Commands"))
        self.create_help_chatbots(help_tabs.tab("Chatbots"))
        self.create_help_troubleshooting(help_tabs.tab("Troubleshooting"))
        self.create_help_about(help_tabs.tab("About"))

        # Add close button at bottom
        button_frame = ctk.CTkFrame(help_window, fg_color="transparent")
        button_frame.pack(fill="x", padx=20, pady=(0, 20))

        close_button = ctk.CTkButton(
            button_frame,
            text="Close",
            command=help_window.destroy,
            width=100,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        close_button.pack(side="right")

    def create_footer(self):
        """Create the footer with status information"""
        # Create footer container
        self.footer = ctk.CTkFrame(
            self.app,
            fg_color=self.colors["bg_dark"],
            height=30
        )
        self.footer.pack(fill="x", side="bottom")
        self.footer.pack_propagate(False)

        # Create canvas for gradient background
        footer_canvas = ctk.CTkCanvas(
            self.footer,
            bg=self.colors["bg_dark"],
            highlightthickness=0,
            height=30
        )
        footer_canvas.pack(fill="x")

        # Draw gradient
        def draw_gradient():
            width = footer_canvas.winfo_width()
            if width <= 1:  # Not properly rendered yet
                self.app.after(100, draw_gradient)
                return

            height = 30
            # Create gradient from dark to slightly lighter
            for i in range(height):
                # Calculate color based on position
                r, g, b = self.hex_to_rgb(self.colors["bg_dark"])
                factor = i / height * 0.2  # Subtle gradient
                r = min(255, int(r + (255 - r) * factor))
                g = min(255, int(g + (255 - g) * factor))
                b = min(255, int(b + (255 - b) * factor))
                color = f'#{r:02x}{g:02x}{b:02x}'

                # Draw line
                footer_canvas.create_line(0, i, width, i, fill=color)

        # Schedule gradient drawing after the window is rendered
        self.app.after(100, draw_gradient)

        # Status label
        self.status_label = ctk.CTkLabel(
            footer_canvas,
            text="Ready",
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        self.status_label.place(relx=0.01, rely=0.5, anchor="w")

        # Version label
        version_label = ctk.CTkLabel(
            footer_canvas,
            text="DragonVoice v2.0",
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        version_label.place(relx=0.99, rely=0.5, anchor="e")

        # Log successful creation
        logging.info(
            "Footer created successfully with status_label initialized")

    def create_tabs(self):
        """Create the main tab view and tabs"""
        # Create the main tab container
        self.tab_container = ctk.CTkFrame(self.app, fg_color="transparent")
        self.tab_container.pack(
            fill="both",
            expand=True,
            padx=20,
            pady=(
                0,
                20))

        # Create the tab view
        self.tab_view = ctk.CTkTabview(
            self.tab_container,
            fg_color=self.colors["bg_dark"],
            segmented_button_fg_color=self.colors["bg_medium"],
            segmented_button_selected_color=self.colors["accent_primary"],
            segmented_button_selected_hover_color=self.colors["accent_secondary"],
            segmented_button_unselected_color=self.colors["bg_medium"],
            segmented_button_unselected_hover_color=self.colors["bg_light"])
        self.tab_view.pack(fill="both", expand=True)

        # Add tabs
        self.tab_view.add("Dashboard")
        self.tab_view.add("Chatbots")
        self.tab_view.add("History")
        self.tab_view.add("Configuration")
        self.tab_view.add("About")

        # Set default tab
        self.tab_view.set("Dashboard")

        # Create tab contents
        self.create_dashboard_tab()
        self.create_chatbots_tab()
        self.create_history_tab()
        self.create_config_tab()
        self.create_about_tab()

    def create_dashboard_tab(self):
        """Create the dashboard tab content"""
        # Main container with gradient background
        dashboard_container = ctk.CTkScrollableFrame(
            self.tab_view.tab("Dashboard"),
            fg_color="transparent"
        )
        dashboard_container.pack(fill="both", expand=True, padx=20, pady=20)

        # Create a grid layout for dashboard widgets
        dashboard_container.columnconfigure(0, weight=2)
        dashboard_container.columnconfigure(1, weight=1)
        dashboard_container.rowconfigure(0, weight=1)
        dashboard_container.rowconfigure(1, weight=1)
        dashboard_container.rowconfigure(2, weight=1)  # Add row for transcription section

        # Status panel (top left) - Enhanced with modern styling
        status_panel = self.create_status_panel(dashboard_container)
        status_panel.grid(
            row=0, column=0, sticky="nsew", padx=(
                0, 10), pady=(
                0, 10))

        # Voice assistant control panel (top right) - Enhanced with modern
        # styling
        control_panel = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=15,
            border_width=1,
            border_color=self.colors["bg_light"]
        )
        control_panel.grid(
            row=0, column=1, sticky="nsew", padx=(
                10, 0), pady=(
                0, 10))

        # Control panel header with icon
        control_header = ctk.CTkFrame(
            control_panel, fg_color="transparent", height=50)
        control_header.pack(fill="x", padx=20, pady=(15, 5))

        # Control panel title with icon
        control_title = ctk.CTkLabel(
            control_header,
            text="Voice Assistant",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        control_title.pack(side="left")

        # Start/Stop button with improved styling
        self.toggle_button = ctk.CTkButton(
            control_panel,
            text="Start Voice Assistant",
            command=self.toggle_voice_assistant,
            fg_color=self.colors["status_green"],  # Start with green
            hover_color=self._adjust_color_brightness(self.colors["status_green"], 0.8),
            height=60,
            corner_radius=10,
            font=self.fonts["subtitle"],
            border_width=1,
            border_color=self._adjust_color_brightness(
                self.colors["status_green"],
                1.2))
        self.toggle_button.pack(fill="x", padx=20, pady=15)
        
        # Recording buttons container
        recording_buttons_frame = ctk.CTkFrame(control_panel, fg_color="transparent")
        recording_buttons_frame.pack(fill="x", padx=20, pady=10)

        # Record button
        self.record_button = ctk.CTkButton(
            recording_buttons_frame,
            text="Record",
            command=self.start_manual_recording,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            height=40,
            width=150,
            corner_radius=10
        )
        self.record_button.pack(side="left", fill="x", expand=True, padx=(0, 5))

        # Stop Recording button
        self.stop_record_button = ctk.CTkButton(
            recording_buttons_frame,
            text="Stop Recording",
            command=self.stop_manual_recording,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            height=40,
            width=150,
            corner_radius=10,
            state="disabled"
        )
        self.stop_record_button.pack(side="right", fill="x", expand=True, padx=(5, 0))

        # Add synthesizer bar to show voice detection
        self.synth_bar = SynthesizerBar(control_panel, self.colors, self.fonts)

        # Microphone sensitivity slider
        sensitivity_frame = ctk.CTkFrame(
            control_panel,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        sensitivity_frame.pack(fill="x", padx=20, pady=10)

        sensitivity_label = ctk.CTkLabel(
            sensitivity_frame,
            text="Microphone Sensitivity",
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"]
        )
        sensitivity_label.pack(anchor="w", padx=15, pady=(10, 5))

        sensitivity_control = ctk.CTkFrame(sensitivity_frame, fg_color="transparent")
        sensitivity_control.pack(fill="x", padx=15, pady=(0, 10))

        self.sensitivity_var = ctk.DoubleVar(value=0.5)
        self.sensitivity_slider = ctk.CTkSlider(
            sensitivity_control,
            from_=0.1,
            to=1.0,
            variable=self.sensitivity_var,
            width=200,
            progress_color=self.colors["accent_primary"],
            button_color=self.colors["accent_secondary"],
            button_hover_color=self.colors["accent_primary"]
        )
        self.sensitivity_slider.pack(side="left", fill="x", expand=True, padx=(0, 10))

        self.sensitivity_value = ctk.CTkLabel(
            sensitivity_control,
            text=f"{int(self.sensitivity_var.get() * 100)}%",
            font=self.fonts["small"],
            width=40,
            text_color=self.colors["text_dim"]
        )
        self.sensitivity_value.pack(side="right")

        # Update sensitivity value when slider changes
        def update_sensitivity(*args):
            self.sensitivity_value.configure(text=f"{int(self.sensitivity_var.get() * 100)}%")
            if hasattr(self, 'gain_var'):
                self.gain_var.set(self.sensitivity_var.get())

        self.sensitivity_var.trace_add("write", update_sensitivity)
        
        # Initialize gain variable for level meter
        self.gain_var = ctk.DoubleVar(value=self.sensitivity_var.get())

        # Status indicator with improved styling
        status_frame = ctk.CTkFrame(
            control_panel,
            fg_color=self.colors["bg_light"],
            corner_radius=10,
            height=50
        )
        status_frame.pack(fill="x", padx=20, pady=10)
        status_frame.pack_propagate(False)

        status_label = ctk.CTkLabel(
            status_frame,
            text="Status: Idle",
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"]
        )
        status_label.pack(side="left", padx=15, pady=10)

        self.status_indicator = ctk.CTkFrame(
            status_frame,
            fg_color=self.colors["status_gray"],
            width=20,
            height=20,
            corner_radius=10
        )
        self.status_indicator.pack(side="right", padx=15)

        # Add text display window for pronounced text
        text_display_frame = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=15,
            border_width=1,
            border_color=self.colors["bg_light"]
        )
        text_display_frame.grid(
            row=1,
            column=0,
            columnspan=2,
            sticky="nsew",
            pady=(10, 10))
                
        # Text display header
        text_header = ctk.CTkFrame(
            text_display_frame, fg_color="transparent", height=50)
        text_header.pack(fill="x", padx=20, pady=(15, 5))
        
        text_title = ctk.CTkLabel(
            text_header,
            text="🔊 Voice Commands",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        text_title.pack(side="left")
        
        # Clear button for text display
        clear_text_button = ctk.CTkButton(
            text_header,
            text="Clear",
            command=lambda: self.clear_text_display(),
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            width=80
        )
        clear_text_button.pack(side="right")
        
        # Text display area
        self.text_display = ctk.CTkTextbox(
            text_display_frame,
            fg_color=self.colors["bg_light"],
            text_color=self.colors["text_bright"],
            font=self.fonts["large"],
            corner_radius=10,
            border_width=1,
            border_color=self.colors["bg_light"],
            height=200
        )
        self.text_display.pack(fill="both", expand=True, padx=20, pady=(5, 20))
        
        # Configure text tags
        self.text_display._textbox.tag_configure(
            "timestamp",
            foreground=self.colors["accent_secondary"]
        )
        self.text_display._textbox.tag_configure(
            "command",
            foreground=self.colors["accent_primary"]
        )
        self.text_display._textbox.tag_configure(
            "system",
            foreground=self.colors["status_blue"]
        )
        
        # Add initial message
        self.text_display.configure(state="normal")
        self.text_display.insert("end", "Voice commands will appear here after starting the voice assistant...")
        self.text_display.configure(state="disabled")
        
        # Add transcription section (bottom)
        transcription_frame = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=15,
            border_width=1,
            border_color=self.colors["bg_light"]
        )
        transcription_frame.grid(
            row=2,
            column=0,
            columnspan=2,
            sticky="nsew",
            pady=(0, 10))
            
        # Transcription header
        transcription_header = ctk.CTkFrame(
            transcription_frame, fg_color="transparent", height=50)
        transcription_header.pack(fill="x", padx=20, pady=(15, 5))
        
        transcription_title = ctk.CTkLabel(
            transcription_header,
            text="📝 Transcription",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        transcription_title.pack(side="left")
        
        # Controls frame
        controls = ctk.CTkFrame(transcription_header, fg_color="transparent")
        controls.pack(side="right")
        
        # Clear button
        clear_button = ctk.CTkButton(
            controls,
            text="Clear",
            command=lambda: self.clear_transcription(),
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            width=80
        )
        clear_button.pack(side="right", padx=(0, 10))
        
        # Enter button
        self.enter_button = ctk.CTkButton(
            controls,
            text="Enter",
            command=self.process_transcription,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            width=100,
            state="disabled"
        )
        self.enter_button.pack(side="right")
        
        # Transcription display
        self.transcription_display = ctk.CTkTextbox(
            transcription_frame,
            fg_color=self.colors["bg_light"],
            text_color=self.colors["text_bright"],
            font=self.fonts["large"],
            corner_radius=10,
            border_width=1,
            border_color=self.colors["bg_light"],
            height=150
        )
        self.transcription_display.pack(fill="both", expand=True, padx=20, pady=(5, 20))
        
        # Configure text tags
        self.transcription_display._textbox.tag_configure(
            "timestamp",
            foreground=self.colors["accent_secondary"]
        )
        self.transcription_display._textbox.tag_configure(
            "transcription",
            foreground=self.colors["text_bright"]
        )
        
        # Add initial message
        self.transcription_display.configure(state="normal")
        self.transcription_display.insert("end", "Transcribed text will appear here...")
        self.transcription_display.configure(state="disabled")

        # Initialize monitor visualization
        self.app.after(500, self.refresh_monitor_visualization)

    def create_synthesizer_bar(self, parent):
        """Create a synthesizer bar to visualize voice detection"""
        # Use the new SynthesizerBar class if available
        try:
            from synthesizer_bar import SynthesizerBar
            self.synth_bar = SynthesizerBar(parent, self.colors, self.fonts)
            return
        except ImportError:
            logging.warning(
                "SynthesizerBar class not found, using fallback implementation")

        # Fallback implementation
        synth_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10,
            height=80
        )
        synth_frame.pack(fill="x", padx=20, pady=10)

        # Synthesizer label
        synth_label = ctk.CTkLabel(
            synth_frame,
            text="Voice Detection",
            font=self.fonts["normal"],
            text_color=self.colors["text_bright"]
        )
        synth_label.pack(anchor="w", padx=15, pady=(10, 5))

        # Create level meter canvas
        self.level_canvas = ctk.CTkCanvas(
            synth_frame,
            bg=self.colors["bg_dark"],
            highlightthickness=0,
            height=30
        )
        self.level_canvas.pack(fill="x", padx=15, pady=(0, 10))

        # Initialize level meter with zero level
        self.app.after(100, lambda: self._update_level_meter(0))

    def create_chatbots_tab(self):
        """Create the chatbots tab content"""
        # Main container
        chatbots_container = ctk.CTkFrame(
            self.tab_view.tab("Chatbots"),
            fg_color="transparent"
        )
        chatbots_container.pack(fill="both", expand=True, padx=20, pady=20)

        # Title and add button row
        title_frame = ctk.CTkFrame(chatbots_container, fg_color="transparent")
        title_frame.pack(fill="x", pady=(0, 15))

        # Title with icon
        title_label = ctk.CTkLabel(
            title_frame,
            text="Chatbot Management",
            font=ctk.CTkFont(size=24, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title_label.pack(side="left")

        # Add chatbot button
        add_button = ctk.CTkButton(
            title_frame,
            text="Add New Chatbot",
            command=self.show_add_chatbot_dialog,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            width=120
        )
        add_button.pack(side="right")

        # Search frame
        search_frame = ctk.CTkFrame(
            chatbots_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=10,
            height=50
        )
        search_frame.pack(fill="x", pady=(0, 15))
        search_frame.pack_propagate(False)

        # Search icon
        search_icon = ctk.CTkLabel(
            search_frame,
            text="🔍",
            font=ctk.CTkFont(size=16),
            width=30
        )
        search_icon.pack(side="left", padx=(15, 0))

        # Search entry
        self.search_var = ctk.StringVar()
        self.search_var.trace_add(
            "write", lambda *args: self.filter_chatbot_list())
        search_entry = ctk.CTkEntry(
            search_frame,
            placeholder_text="Search chatbots...",
            textvariable=self.search_var,
            border_width=0,
            fg_color="transparent",
            height=40
        )
        search_entry.pack(side="left", fill="x", expand=True, padx=10)

        # Chatbot list container
        self.chatbot_list_frame = ctk.CTkScrollableFrame(
            chatbots_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        self.chatbot_list_frame.pack(fill="both", expand=True)

        # Refresh chatbot list
        self.refresh_chatbots()

    def create_about_tab(self):
        """Create the about tab content"""
        # Main container
        about_container = ctk.CTkFrame(
            self.tab_view.tab("About"),
            fg_color="transparent"
        )
        about_container.pack(fill="both", expand=True, padx=20, pady=20)

        # Create a scrollable frame for the about content
        about_scroll = ctk.CTkScrollableFrame(
            about_container,
            fg_color="transparent"
        )
        about_scroll.pack(fill="both", expand=True)

        # Logo and title
        logo_frame = ctk.CTkFrame(about_scroll, fg_color="transparent")
        logo_frame.pack(fill="x", pady=(0, 20))

        # App title
        title_label = ctk.CTkLabel(
            logo_frame,
            text="DragonVoice",
            font=ctk.CTkFont(size=32, weight="bold"),
            text_color=self.colors["accent_primary"]
        )
        title_label.pack(pady=(0, 5))

        # Version
        version_label = ctk.CTkLabel(
            logo_frame,
            text="Version 2.0",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"]
        )
        version_label.pack()

        # Description
        description_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        description_frame.pack(fill="x", pady=10, padx=5)

        description_label = ctk.CTkLabel(
            description_frame,
            text="DragonVoice is an advanced voice assistant that integrates with multiple AI chatbots.\n"
            "It provides a seamless voice interface for interacting with AI models and controlling your computer.",
            font=ctk.CTkFont(
                size=14),
            text_color=self.colors["text_normal"],
            wraplength=600,
            justify="left")
        description_label.pack(padx=20, pady=20)

        # Features
        features_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        features_frame.pack(fill="x", pady=10, padx=5)

        features_title = ctk.CTkLabel(
            features_frame,
            text="Key Features",
            font=ctk.CTkFont(size=18, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        features_title.pack(anchor="w", padx=20, pady=(15, 10))

        features = [
            "🎤 Voice recognition with OpenAI Whisper",
            "🤖 Multiple AI chatbot integrations",
            "⌨️ System control through voice commands",
            "📊 Real-time system monitoring",
            "🎨 Customizable themes and appearance",
            "🔧 Advanced configuration options"
        ]

        for feature in features:
            feature_label = ctk.CTkLabel(
                features_frame,
                text=feature,
                font=ctk.CTkFont(size=14),
                text_color=self.colors["text_normal"],
                anchor="w"
            )
            feature_label.pack(anchor="w", padx=20, pady=5)

        # Credits
        credits_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        credits_frame.pack(fill="x", pady=10, padx=5)

        credits_title = ctk.CTkLabel(
            credits_frame,
            text="Credits",
            font=ctk.CTkFont(size=18, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        credits_title.pack(anchor="w", padx=20, pady=(15, 10))

        credits_label = ctk.CTkLabel(
            credits_frame,
            text="Developed by: DragonVoice Team\n"
                 "UI Framework: CustomTkinter\n"
                 "Voice Recognition: OpenAI Whisper\n"
                 "Special thanks to all contributors and testers",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            justify="left"
        )
        credits_label.pack(anchor="w", padx=20, pady=(0, 15))

        # Links
        links_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        links_frame.pack(fill="x", pady=10, padx=5)

        links_title = ctk.CTkLabel(
            links_frame,
            text="Links",
            font=ctk.CTkFont(size=18, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        links_title.pack(anchor="w", padx=20, pady=(15, 10))

        # Function to open links
        def open_link(url):
            import webbrowser
            webbrowser.open(url)

        # Website link
        website_button = ctk.CTkButton(
            links_frame,
            text="Visit Website",
            command=lambda: open_link("https://dragonvoice.ai"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        website_button.pack(anchor="w", padx=20, pady=5)

        # Documentation link
        docs_button = ctk.CTkButton(
            links_frame,
            text="Documentation",
            command=lambda: open_link("https://docs.dragonvoice.ai"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        docs_button.pack(anchor="w", padx=20, pady=5)

        # GitHub link
        github_button = ctk.CTkButton(
            links_frame,
            text="GitHub Repository",
            command=lambda: open_link("https://github.com/dragonvoice/dragonvoice"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"])
        github_button.pack(anchor="w", padx=20, pady=(5, 15))

    def create_dashboard_tab(self):
        """Create the dashboard tab content"""
        # Main container with gradient background
        dashboard_container = ctk.CTkScrollableFrame(
            self.app,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )
        dashboard_container.pack(fill="both", expand=True, padx=20, pady=20)

        # System status section
        system_frame = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        system_frame.pack(fill="x", pady=(0, 15))

        # Section title
        system_title = ctk.CTkLabel(
            system_frame,
            text="System Status",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        system_title.pack(anchor="w", padx=15, pady=(15, 10))

        # CPU usage
        cpu_frame = ctk.CTkFrame(system_frame, fg_color="transparent")
        cpu_frame.pack(fill="x", padx=15, pady=5)

        cpu_label = ctk.CTkLabel(
            cpu_frame,
            text="CPU Usage",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        cpu_label.pack(side="left")

        cpu_bar = ctk.CTkProgressBar(
            cpu_frame,
            width=200,
            height=10,
            progress_color=self.colors["accent_primary"]
        )
        cpu_bar.pack(side="left", padx=10)

        cpu_value = ctk.CTkLabel(
            cpu_frame,
            text="0%",
            width=30
        )
        cpu_value.pack(side="left", padx=5)

        # Memory usage
        memory_frame = ctk.CTkFrame(system_frame, fg_color="transparent")
        memory_frame.pack(fill="x", padx=15, pady=5)

        memory_label = ctk.CTkLabel(
            memory_frame,
            text="Memory Usage",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        memory_label.pack(side="left")

        memory_bar = ctk.CTkProgressBar(
            memory_frame,
            width=200,
            height=10,
            progress_color=self.colors["accent_primary"]
        )
        memory_bar.pack(side="left", padx=10)

        memory_value = ctk.CTkLabel(
            memory_frame,
            text="0%",
            width=30
        )
        memory_value.pack(side="left", padx=5)

        # Disk space
        disk_frame = ctk.CTkFrame(system_frame, fg_color="transparent")
        disk_frame.pack(fill="x", padx=15, pady=5)

        disk_label = ctk.CTkLabel(
            disk_frame,
            text="Disk Space",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        disk_label.pack(side="left")

        disk_bar = ctk.CTkProgressBar(
            disk_frame,
            width=200,
            height=10,
            progress_color=self.colors["accent_primary"]
        )
        disk_bar.pack(side="left", padx=10)

        disk_value = ctk.CTkLabel(
            disk_frame,
            text="0%",
            width=30
        )
        disk_value.pack(side="left", padx=5)

        # Voice assistant section
        voice_frame = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        voice_frame.pack(fill="x", pady=(0, 15))

        # Section title
        voice_title = ctk.CTkLabel(
            voice_frame,
            text="Voice Assistant",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        voice_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Voice assistant control panel
        control_panel = ctk.CTkFrame(
            voice_frame,
            fg_color="transparent"
        )
        control_panel.pack(fill="x", padx=15, pady=5)

        # Toggle button
        self.toggle_button = ctk.CTkButton(
            control_panel,
            text="Start Voice Assistant",
            command=self.toggle_voice_assistant,
            fg_color=self.colors["status_green"],
            hover_color=self.colors["status_red"]
        )
        self.toggle_button.pack(side="left", padx=(0, 10))

        # Record button
        self.record_button = ctk.CTkButton(
            control_panel,
            text="Record",
            command=self.start_manual_recording,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        self.record_button.pack(side="left", padx=(0, 10))

        # Stop record button
        self.stop_record_button = ctk.CTkButton(
            control_panel,
            text="Stop Recording",
            command=self.stop_manual_recording,
            fg_color=self.colors["status_red"],
            hover_color=self.colors["status_green"],
            state="disabled"
        )
        self.stop_record_button.pack(side="left", padx=(0, 10))

        # Voice detection display
        voice_detection_frame = ctk.CTkFrame(
            voice_frame,
            fg_color="transparent"
        )
        voice_detection_frame.pack(fill="x", padx=15, pady=5)

        voice_detection_label = ctk.CTkLabel(
            voice_detection_frame,
            text="Voice Detection",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        voice_detection_label.pack(side="left")

        self.voice_detection_bar = ctk.CTkProgressBar(
            voice_detection_frame,
            width=200,
            height=10,
            progress_color=self.colors["accent_primary"]
        )
        self.voice_detection_bar.pack(side="left", padx=10)

        # Microphone sensitivity slider
        sensitivity_frame = ctk.CTkFrame(
            voice_frame,
            fg_color="transparent"
        )
        sensitivity_frame.pack(fill="x", padx=15, pady=5)

        sensitivity_label = ctk.CTkLabel(
            sensitivity_frame,
            text="Microphone Sensitivity",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        sensitivity_label.pack(side="left")

        self.gain_var = ctk.DoubleVar(value=0.5)
        sensitivity_slider = ctk.CTkSlider(
            sensitivity_frame,
            from_=0.1,
            to=1.0,
            number_of_steps=9,
            variable=self.gain_var,
            width=200
        )
        sensitivity_slider.pack(side="left", padx=10)

        sensitivity_value = ctk.CTkLabel(
            sensitivity_frame,
            textvariable=self.gain_var,
            width=30
        )
        sensitivity_value.pack(side="left", padx=5)

        # Transcription section
        transcription_frame = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        transcription_frame.pack(fill="x", pady=(0, 15))

        # Section title
        transcription_title = ctk.CTkLabel(
            transcription_frame,
            text="Transcription",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        transcription_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Transcription display
        self.transcription_display = ctk.CTkTextbox(
            transcription_frame,
            height=100,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        self.transcription_display.pack(fill="x", padx=15, pady=(0, 10))
        self.transcription_display.configure(state="disabled")

        # Enter button
        enter_button = ctk.CTkButton(
            transcription_frame,
            text="Enter",
            command=self.process_transcription,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        enter_button.pack(anchor="center", pady=10)

        # Clear button
        clear_button = ctk.CTkButton(
            transcription_frame,
            text="Clear",
            command=self.clear_transcription,
            fg_color=self.colors["bg_medium"],
            hover_color=self.colors["bg_light"]
        )
        clear_button.pack(anchor="center", pady=10)

        # Text display section
        text_display_frame = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        text_display_frame.pack(fill="x", pady=(0, 15))

        # Section title
        text_display_title = ctk.CTkLabel(
            text_display_frame,
            text="Text Display",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        text_display_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Text display
        self.text_display = ctk.CTkTextbox(
            text_display_frame,
            height=100,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        self.text_display.pack(fill="x", padx=15, pady=(0, 10))
        self.text_display.configure(state="disabled")

        # Update system status
        self.update_system_status()

        # Start system status update thread
        self.system_status_thread = threading.Thread(
            target=self.update_system_status_thread,
            daemon=True
        )
        self.system_status_thread.start()

        return dashboard_container

    def toggle_voice_assistant(self):
        """Toggle voice assistant on/off"""
        if not hasattr(self, 'whisper_recognizer'):
            self.update_status(
                "Whisper recognizer not initialized",
                log_level="error")
            return

        if self.whisper_recognizer.is_recording():
            # Stop voice assistant
            self.stop_voice_assistant()
        else:
            # Start voice assistant
            self.start_voice_assistant()

    def start_voice_assistant(self):
        """Start voice assistant"""
        if not hasattr(self, 'whisper_recognizer'):
            self.update_status(
                "Whisper recognizer not initialized",
                log_level="error")
            return

        try:
            # Start recording
            self.whisper_recognizer.start_recording()
            self.update_status("Recording started", log_level="info")
            # Update UI to show recording state
            self.toggle_button.configure(
                text="Stop Voice Assistant",
                fg_color=self.colors["status_red"]
            )
            # Disable record button, enable stop button
            if hasattr(self, 'record_button'):
                self.record_button.configure(state="disabled")
            if hasattr(self, 'stop_record_button'):
                self.stop_record_button.configure(state="normal")
            
            # Start level meter animation
            self.recording_active = True
            self.animate_level_meter()

            # Update text display to show that voice assistant is active
            if hasattr(self, 'text_display'):
                self.text_display.configure(state="normal")
                timestamp = datetime.now().strftime("%H:%M:%S")

                # Add system message with formatting
                system_pos = self.text_display.index("end-1c")
                self.text_display.insert(
                    "end", f"[{timestamp}] Voice Assistant started.\n\n")
                self.text_display._textbox.tag_add(
                    "system", system_pos, self.text_display.index("end-2c"))

                self.text_display.see("end")
                self.text_display.configure(state="disabled")

        except Exception as e:
            self.update_status(
                f"Error starting voice assistant: {str(e)}",
                log_level="error")

    def stop_voice_assistant(self):
        """Stop voice assistant"""
        if not hasattr(self, 'whisper_recognizer'):
            self.update_status(
                "Whisper recognizer not initialized",
                log_level="error")
            return

        try:
            # Stop recording
            success = self.whisper_recognizer.stop_recording()
            if success:
                self.update_status("Recording stopped", log_level="info")
                # Update UI to show stopped state
                self.toggle_button.configure(
                    text="Start Voice Assistant",
                    fg_color=self.colors["status_green"]
                )
                # Enable record button, disable stop button
                if hasattr(self, 'record_button'):
                    self.record_button.configure(state="normal")
                if hasattr(self, 'stop_record_button'):
                    self.stop_record_button.configure(state="disabled")
                
                # Stop level meter animation
                self.recording_active = False

                # Update text display to show that voice assistant is stopped
                if hasattr(self, 'text_display'):
                    self.text_display.configure(state="normal")
                    timestamp = datetime.now().strftime("%H:%M:%S")

                    # Add system message with formatting
                    system_pos = self.text_display.index("end-1c")
                    self.text_display.insert(
                        "end", f"[{timestamp}] Voice Assistant stopped.\n\n")
                    self.text_display._textbox.tag_add(
                        "system", system_pos, self.text_display.index("end-2c"))

                    self.text_display.see("end")
                    self.text_display.configure(state="disabled")

                # Transcribe the recording
                self.transcribe_last_recording()

            else:
                self.update_status("No recording to stop", log_level="warning")
        except Exception as e:
            self.update_status(
                f"Error stopping voice assistant: {str(e)}",
                log_level="error")

    def start_manual_recording(self):
        """Start recording audio manually"""
        if not hasattr(self, 'whisper_recognizer'):
            self.update_status(
                "Whisper recognizer not initialized",
                log_level="error")
            return

        try:
            # Start recording
            self.whisper_recognizer.start_recording()
            self.update_status("Recording started", log_level="info")
            # Update UI to show recording state
            self.toggle_button.configure(
                text="Stop Voice Assistant",
                fg_color=self.colors["status_red"]
            )
            # Disable record button, enable stop button
            if hasattr(self, 'record_button'):
                self.record_button.configure(state="disabled")
            if hasattr(self, 'stop_record_button'):
                self.stop_record_button.configure(state="normal")
            
            # Start level meter animation
            self.recording_active = True
            self.animate_level_meter()

            # Update text display to show that voice assistant is active
            if hasattr(self, 'text_display'):
                self.text_display.configure(state="normal")
                timestamp = datetime.now().strftime("%H:%M:%S")

                # Add system message with formatting
                system_pos = self.text_display.index("end-1c")
                self.text_display.insert(
                    "end", f"[{timestamp}] Voice Assistant started.\n\n")
                self.text_display._textbox.tag_add(
                    "system", system_pos, self.text_display.index("end-2c"))

                self.text_display.see("end")
                self.text_display.configure(state="disabled")

        except Exception as e:
            self.update_status(
                f"Error starting manual recording: {str(e)}",
                log_level="error")

    def stop_manual_recording(self):
        """Stop recording audio manually"""
        if not hasattr(self, 'whisper_recognizer'):
            self.update_status(
                "Whisper recognizer not initialized",
                log_level="error")
            return False

        try:
            # Stop recording
            success = self.whisper_recognizer.stop_recording()
            if success:
                self.update_status("Recording stopped", log_level="info")
                # Update UI to show stopped state
                self.toggle_button.configure(
                    text="Start Voice Assistant",
                    fg_color=self.colors["status_green"]
                )
                # Enable record button, disable stop button
                if hasattr(self, 'record_button'):
                    self.record_button.configure(state="normal")
                if hasattr(self, 'stop_record_button'):
                    self.stop_record_button.configure(state="disabled")
                
                # Stop level meter animation
                self.recording_active = False

                # Update text display to show that voice assistant is stopped
                if hasattr(self, 'text_display'):
                    self.text_display.configure(state="normal")
                    timestamp = datetime.now().strftime("%H:%M:%S")

                    # Add system message with formatting
                    system_pos = self.text_display.index("end-1c")
                    self.text_display.insert(
                        "end", f"[{timestamp}] Voice Assistant stopped.\n\n")
                    self.text_display._textbox.tag_add(
                        "system", system_pos, self.text_display.index("end-2c"))

                    self.text_display.see("end")
                    self.text_display.configure(state="disabled")

                # Transcribe the recording
                self.transcribe_last_recording()

                return True
            else:
                self.update_status("No recording to stop", log_level="warning")
                return False
        except Exception as e:
            self.update_status(
                f"Error stopping recording: {str(e)}",
                log_level="error")
            return False

#!/usr/bin/env python3
"""
Dragon Voice GUI - Main application interface for Dragon Voice Project
"""

from whisper_integration import WhisperRecognizer
import os
import sys
import json
import time
import logging
import webbrowser
import threading
from datetime import datetime
from pathlib import Path

# GUI libraries
import tkinter as tk
from tkinter import messagebox
import customtkinter as ctk
from PIL import Image, ImageTk

# System monitoring
import psutil
import platform

# Window management
import pygetwindow as gw
import pyautogui
import sounddevice as sd
import numpy as np
import tempfile
import os
import time
import threading

# Custom components
from synthesizer_bar import SynthesizerBar

# Try to import soundfile, but don't fail if it's not available
try:
    import soundfile as sf
    SOUNDFILE_AVAILABLE = True
except ImportError:
    SOUNDFILE_AVAILABLE = False
    print("Warning: soundfile module not found. Some audio features will be limited.")

# Configure logging
logging.basicConfig(
    level=logging.WARNING,  # Changed from INFO to WARNING
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("dragon_gui.log"),
        logging.StreamHandler()
    ]
)

# Constants
DEFAULT_CONFIG_PATH = "src/config.json"
ASSETS_DIR = os.path.join("src", "assets")

# Add Whisper integration


class DragonVoiceGUI:
    """
    Main GUI class for the Dragon Voice Project

    Provides a modern, feature-rich interface for controlling the voice assistant,
    managing chatbots, and configuring system settings.
    """

    def __init__(self, config_path=DEFAULT_CONFIG_PATH):
        """Initialize the DragonVoice GUI application"""
        logging.info("Initializing DragonVoiceGUI")
        logging.info("Initializing DragonVoice GUI")

        try:
            # Initialize logging
            self.setup_logging()

            # Initialize state variables
            self.recording_active = False
            self.continuous_recording = False  # Flag for continuous recording
            self.is_fullscreen = False

            # Create main application window
            self.app = ctk.CTk()
            self.app.title("DragonVoice")
            self.app.geometry("1200x800")
            self.app.minsize(900, 600)
            
            # Center window on screen
            screen_width = self.app.winfo_screenwidth()
            screen_height = self.app.winfo_screenheight()
            x = (screen_width - 1200) // 2
            y = (screen_height - 800) // 2
            self.app.geometry(f"1200x800+{x}+{y}")

            # Load configuration
            self.config_path = config_path
            self.config = self.load_config()
            logging.info(f"Configuration loaded from {config_path}")

            # Set up theme and colors
            self.setup_theme()

            # Initialize Whisper recognizer
            self.init_whisper_recognizer()

            # Set up UI components
            self.setup_ui()

            # Start system monitoring
            self.start_system_monitoring()

        except Exception as e:
            logging.error(f"Error initializing DragonVoiceGUI: {str(e)}")
            raise

    def setup_logging(self):
        """Set up logging configuration"""
        # Check if logging is already configured
        if not logging.getLogger().handlers:
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - %(message)s'
            )
        logging.info("Logging setup complete")

    def setup_theme(self):
        """Set up the theme and colors for the application"""
        # Set appearance mode
        ctk.set_appearance_mode("dark")

        # Define color schemes
        self.color_schemes = {
            "dark": {
                "bg_dark": "#1A1A2E",
                "bg_medium": "#16213E",
                "bg_light": "#0F3460",
                "accent_primary": "#E94560",
                "accent_secondary": "#0F52BA",
                "text_bright": "#FFFFFF",
                "text_normal": "#E0E0E0",
                "text_dim": "#A0A0A0",
                "status_green": "#4CAF50",
                "status_yellow": "#FFC107",
                "status_red": "#F44336",
                "status_blue": "#2196F3",
                "status_gray": "#757575"
            },
            "light": {
                "bg_dark": "#F0F0F0",
                "bg_medium": "#E0E0E0",
                "bg_light": "#D0D0D0",
                "accent_primary": "#E94560",
                "accent_secondary": "#0F52BA",
                "text_bright": "#000000",
                "text_normal": "#202020",
                "text_dim": "#505050",
                "status_green": "#4CAF50",
                "status_yellow": "#FFC107",
                "status_red": "#F44336",
                "status_blue": "#2196F3",
                "status_gray": "#757575"
            },
            "dragon": {
                "bg_dark": "#0A1931",
                "bg_medium": "#150E56",
                "bg_light": "#1A1A40",
                "accent_primary": "#D82148",
                "accent_secondary": "#6EBF8B",
                "text_bright": "#FFFFFF",
                "text_normal": "#E0E0E0",
                "text_dim": "#A0A0A0",
                "status_green": "#4CAF50",
                "status_yellow": "#FFC107",
                "status_red": "#F44336",
                "status_blue": "#2196F3",
                "status_gray": "#757575"
            }
        }

        # Set default color scheme
        self.colors = self.color_schemes["dragon"]

        # Define fonts
        self.fonts = {
            "header": ctk.CTkFont(family="Segoe UI", size=28, weight="bold"),
            "title": ctk.CTkFont(family="Segoe UI", size=20, weight="bold"),
            "subtitle": ctk.CTkFont(family="Segoe UI", size=16, weight="bold"),
            "normal": ctk.CTkFont(family="Segoe UI", size=14),
            "small": ctk.CTkFont(family="Segoe UI", size=12),
            "tiny": ctk.CTkFont(family="Segoe UI", size=10),
            "mono": ctk.CTkFont(family="Consolas", size=12),
            # Added the 'large' font definition
            "large": ctk.CTkFont(family="Segoe UI", size=18)
        }

    def init_whisper_recognizer(self):
        """Initialize the Whisper recognizer"""
        try:
            # Initialize API keys with default values
            self.openai_api_key = "j3ydNXEmQFyDKwl5mWxSzcvdZcTLJw1t"
            self.base_url = "https://api.deepinfra.com/v1/openai"
            
            # Initialize WhisperRecognizer with error handling
            if self.openai_api_key:
                self.whisper_recognizer = WhisperRecognizer(
                    api_key=self.openai_api_key,
                    base_url=self.base_url
                )
                # Initialize recording state
                self.recording_active = False
                self.continuous_recording = False
                self.audio_data = []
                logging.info("WhisperRecognizer initialized successfully")
            else:
                logging.warning("No OpenAI API key found, WhisperRecognizer not initialized")
                self.whisper_recognizer = None
        except Exception as e:
            logging.error(f"Failed to initialize WhisperRecognizer: {str(e)}")
            self.whisper_recognizer = None

    def setup_ui(self):
        """Set up the main UI components"""
        try:
            # Create the main container
            self.main_container = ctk.CTkFrame(
                self.app, fg_color="transparent")
            self.main_container.pack(fill="both", expand=True)

            # Create UI components in the correct order
            self.create_footer()  # Create footer first to ensure status_label exists
            self.create_header()
            self.create_tabs()

            # Start system monitoring
            self.start_system_monitoring()

            # Update status
            self.update_status("Application initialized successfully")

            # Log successful UI setup
            logging.info("UI setup completed successfully")

        except Exception as e:
            logging.error(f"Error setting up UI: {str(e)}", exc_info=True)
            # Show error in a messagebox if possible
            try:
                import tkinter.messagebox as messagebox
                messagebox.showerror(
                    "UI Setup Error",
                    f"Error setting up UI:\n{str(e)}")
            except BaseException:
                pass

    def create_header(self):
        """Create a modern application header with logo and controls"""
        # Create header frame with gradient background
        self.header_frame = ctk.CTkFrame(
            self.main_container,
            fg_color=self.colors["bg_dark"],
            corner_radius=0,
            height=90
        )
        self.header_frame.pack(fill="x", pady=0)
        self.header_frame.pack_propagate(False)

        # Create gradient effect for header
        self.header_canvas = ctk.CTkCanvas(
            self.header_frame,
            bg=self.colors["bg_dark"],
            highlightthickness=0,
            height=90
        )
        self.header_canvas.pack(fill="x", side="top")

        # Draw gradient
        def draw_gradient():
            width = self.header_canvas.winfo_width()
            if width <= 1:  # Not yet properly initialized
                self.app.after(100, draw_gradient)
                return

            height = 90
            # Create a more sophisticated gradient
            for i in range(width):
                # Calculate gradient position (0 to 1)
                pos = i / width

                # Create a gradient with accent color highlights
                if pos < 0.2:  # First section - dark to medium with accent hint
                    ratio = pos / 0.2
                    r1, g1, b1 = self.hex_to_rgb(self.colors["bg_dark"])
                    r2, g2, b2 = self.hex_to_rgb(self.colors["bg_medium"])
                    r3, g3, b3 = self.hex_to_rgb(self.colors["accent_primary"])

                    # Mix colors with a hint of accent
                    r = r1 + (r2 - r1) * ratio + (r3 - r1) * ratio * 0.1
                    g = g1 + (g2 - g1) * ratio + (g3 - g1) * ratio * 0.1
                    b = b1 + (b2 - b1) * ratio + (b3 - b1) * ratio * 0.1
                elif pos < 0.8:  # Middle section - medium to medium with subtle variation
                    ratio = (pos - 0.2) / 0.6
                    r1, g1, b1 = self.hex_to_rgb(self.colors["bg_medium"])
                    r2, g2, b2 = self.hex_to_rgb(
                        self._adjust_color_brightness(
                            self.colors["bg_medium"], 1.1))

                    r = r1 + (r2 - r1) * ratio
                    g = g1 + (g2 - g1) * ratio
                    b = b1 + (b2 - b1) * ratio
                else:  # Last section - medium to dark with accent hint
                    ratio = (pos - 0.8) / 0.2
                    r1, g1, b1 = self.hex_to_rgb(self.colors["bg_medium"])
                    r2, g2, b2 = self.hex_to_rgb(self.colors["bg_dark"])
                    r3, g3, b3 = self.hex_to_rgb(
                        self.colors["accent_secondary"])

                    # Mix colors with a hint of accent
                    r = r1 + (r2 - r1) * ratio + (r3 - r1) * ratio * 0.1
                    g = g1 + (g2 - g1) * ratio + (g3 - g1) * ratio * 0.1
                    b = b1 + (b2 - b1) * ratio + (b3 - b1) * ratio * 0.1

                color = f'#{int(r):02x}{int(g):02x}{int(b):02x}'
                self.header_canvas.create_line(i, 0, i, height, fill=color)

            # Add accent line at bottom with glow effect
            for i in range(3):
                alpha = 0.3 + (0.7 * (i / 2))  # Increasing opacity
                glow_color = self._adjust_color_brightness(
                    self.colors["accent_primary"], alpha)
            self.header_canvas.create_line(
                0, height - 3 + i, width, height - 3 + i,
                fill=glow_color,
                width=1
            )

        # Schedule gradient drawing
        self.app.after(100, draw_gradient)

        # Create a container for the header content
        header_content = ctk.CTkFrame(
            self.header_frame, fg_color="transparent")
        header_content.place(
            relx=0.5,
            rely=0.5,
            anchor="center",
            relwidth=1,
            relheight=0.8)

        # Left side - Logo and title
        logo_frame = ctk.CTkFrame(header_content, fg_color="transparent")
        logo_frame.pack(side="left", padx=(30, 0))

        # Try to load logo image if available
        try:
            logo_path = os.path.join("src", "assets", "dragon_logo.png")
            if os.path.exists(logo_path):
                logo_image = ctk.CTkImage(
                    light_image=Image.open(logo_path),
                    dark_image=Image.open(logo_path),
                    size=(40, 40)
                )
                logo_label = ctk.CTkLabel(
                    logo_frame,
                    image=logo_image,
                    text=""
                )
                logo_label.pack(side="left", padx=(0, 15))
        except Exception as e:
            logging.error(f"Failed to load logo: {str(e)}")

        # App title with modern styling
        title_label = ctk.CTkLabel(
            logo_frame,
            text="DragonVoice",
            font=self.fonts["header"],
            text_color=self.colors["text_bright"]
        )
        title_label.pack(side="left")

        # Version with pill background
        version_pill = ctk.CTkFrame(
            logo_frame,
            fg_color=self.colors["accent_primary"],
            corner_radius=12,
            height=24
        )
        version_pill.pack(side="left", padx=(10, 0), pady=(8, 0))

        version_label = ctk.CTkLabel(
            version_pill,
            text="v2.0",
            font=self.fonts["small"],
            text_color=self.colors["text_bright"]
        )
        version_label.pack(padx=10, pady=2)

        # Center - Status indicator
        status_frame = ctk.CTkFrame(header_content, fg_color="transparent")
        status_frame.pack(side="left", expand=True)

        # Right side - Controls
        controls_frame = ctk.CTkFrame(header_content, fg_color="transparent")
        controls_frame.pack(side="right", padx=(0, 30))

        # Microphone selector with improved styling
        mic_frame = ctk.CTkFrame(
            controls_frame,
            fg_color=self.colors["bg_light"],
            corner_radius=8
        )
        mic_frame.pack(side="left", padx=(0, 15), pady=5)

        mic_label = ctk.CTkLabel(
            mic_frame,
            text="Microphone:",
            font=self.fonts["small"],
            text_color=self.colors["text_normal"]
        )
        mic_label.pack(side="left", padx=(10, 5), pady=5)

        # Microphone dropdown
        self.mic_var = ctk.StringVar(value="Default Microphone")
        self.mic_dropdown = ctk.CTkOptionMenu(
            mic_frame,
            values=["Default Microphone"],
            variable=self.mic_var,
            width=150,
            dynamic_resizing=True,
            fg_color=self.colors["bg_medium"],
            button_color=self.colors["accent_primary"],
            button_hover_color=self.colors["accent_secondary"],
            dropdown_fg_color=self.colors["bg_medium"]
        )
        self.mic_dropdown.pack(side="left", padx=(0, 10), pady=5)

        # Theme toggle button
        theme_button = ctk.CTkButton(
            controls_frame,
            text="",
            width=36,
            height=36,
            corner_radius=10,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            text_color=self.colors["text_bright"],
            command=self.toggle_theme
        )
        theme_button.pack(side="left", padx=(0, 10))

        # Settings button
        settings_button = ctk.CTkButton(
            controls_frame,
            text="Settings",
            width=100,
            height=36,
            corner_radius=10,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            text_color=self.colors["text_bright"],
            command=self.show_settings
        )
        settings_button.pack(side="left", padx=(0, 10))

        # Help button
        help_button = ctk.CTkButton(
            controls_frame,
            text="Help",
            width=80,
            height=36,
            corner_radius=10,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            text_color=self.colors["text_bright"],
            command=self.show_help
        )
        help_button.pack(side="left")

        # Refresh microphone list
        self.refresh_mic_list()

    def hex_to_rgb(self, hex_color):
        """Convert hex color to RGB tuple"""
        hex_color = hex_color.lstrip('#')
        return tuple(int(hex_color[i:i + 2], 16) for i in (0, 2, 4))

    def show_settings(self):
        """Show the settings dialog"""
        # Switch to the Configuration tab
        self.tab_view.set("Configuration")

    def show_help(self):
        """Show the help dialog"""
        # Create a new top-level window
        help_window = ctk.CTkToplevel(self.app)
        help_window.title("DragonVoice Help")
        help_window.geometry("800x600")
        help_window.minsize(800, 600)
        help_window.grab_set()  # Make window modal

        # Set window icon
        if platform.system() == "Windows":
            try:
                icon_path = os.path.join(
                    os.path.dirname(
                        os.path.abspath(__file__)),
                    "assets",
                    "dragon_icon.ico")
                if os.path.exists(icon_path):
                    help_window.iconbitmap(icon_path)
            except Exception as e:
                print(f"Could not set help window icon: {e}")

        # Create tab view for help content
        help_tabs = ctk.CTkTabview(
            help_window,
            fg_color=self.colors["bg_dark"],
            segmented_button_fg_color=self.colors["bg_medium"],
            segmented_button_selected_color=self.colors["accent_primary"],
            segmented_button_selected_hover_color=self.colors["accent_secondary"],
            segmented_button_unselected_color=self.colors["bg_medium"],
            segmented_button_unselected_hover_color=self.colors["bg_light"])
        help_tabs.pack(fill="both", expand=True, padx=20, pady=20)

        # Add tabs
        help_tabs.add("Getting Started")
        help_tabs.add("Voice Commands")
        help_tabs.add("Chatbots")
        help_tabs.add("Troubleshooting")
        help_tabs.add("About")

        # Create content for each tab
        self.create_help_getting_started(help_tabs.tab("Getting Started"))
        self.create_help_voice_commands(help_tabs.tab("Voice Commands"))
        self.create_help_chatbots(help_tabs.tab("Chatbots"))
        self.create_help_troubleshooting(help_tabs.tab("Troubleshooting"))
        self.create_help_about(help_tabs.tab("About"))

        # Add close button at bottom
        button_frame = ctk.CTkFrame(help_window, fg_color="transparent")
        button_frame.pack(fill="x", padx=20, pady=(0, 20))

        close_button = ctk.CTkButton(
            button_frame,
            text="Close",
            command=help_window.destroy,
            width=100,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        close_button.pack(side="right")

    def create_footer(self):
        """Create the footer with status information"""
        # Create footer container
        self.footer = ctk.CTkFrame(
            self.app,
            fg_color=self.colors["bg_dark"],
            height=30
        )
        self.footer.pack(fill="x", side="bottom")
        self.footer.pack_propagate(False)

        # Create canvas for gradient background
        footer_canvas = ctk.CTkCanvas(
            self.footer,
            bg=self.colors["bg_dark"],
            highlightthickness=0,
            height=30
        )
        footer_canvas.pack(fill="x")

        # Draw gradient
        def draw_gradient():
            width = footer_canvas.winfo_width()
            if width <= 1:  # Not properly rendered yet
                self.app.after(100, draw_gradient)
                return

            height = 30
            # Create gradient from dark to slightly lighter
            for i in range(height):
                # Calculate color based on position
                r, g, b = self.hex_to_rgb(self.colors["bg_dark"])
                factor = i / height * 0.2  # Subtle gradient
                r = min(255, int(r + (255 - r) * factor))
                g = min(255, int(g + (255 - g) * factor))
                b = min(255, int(b + (255 - b) * factor))
                color = f'#{r:02x}{g:02x}{b:02x}'

                # Draw line
                footer_canvas.create_line(0, i, width, i, fill=color)

        # Schedule gradient drawing after the window is rendered
        self.app.after(100, draw_gradient)

        # Status label
        self.status_label = ctk.CTkLabel(
            footer_canvas,
            text="Ready",
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        self.status_label.place(relx=0.01, rely=0.5, anchor="w")

        # Version label
        version_label = ctk.CTkLabel(
            footer_canvas,
            text="DragonVoice v2.0",
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        version_label.place(relx=0.99, rely=0.5, anchor="e")

        # Log successful creation
        logging.info(
            "Footer created successfully with status_label initialized")

    def create_tabs(self):
        """Create the main tab view and tabs"""
        # Create the main tab container
        self.tab_container = ctk.CTkFrame(self.app, fg_color="transparent")
        self.tab_container.pack(
            fill="both",
            expand=True,
            padx=20,
            pady=(
                0,
                20))

        # Create the tab view
        self.tab_view = ctk.CTkTabview(
            self.tab_container,
            fg_color=self.colors["bg_dark"],
            segmented_button_fg_color=self.colors["bg_medium"],
            segmented_button_selected_color=self.colors["accent_primary"],
            segmented_button_selected_hover_color=self.colors["accent_secondary"],
            segmented_button_unselected_color=self.colors["bg_medium"],
            segmented_button_unselected_hover_color=self.colors["bg_light"])
        self.tab_view.pack(fill="both", expand=True)

        # Add tabs
        self.tab_view.add("Dashboard")
        self.tab_view.add("Chatbots")
        self.tab_view.add("History")
        self.tab_view.add("Configuration")
        self.tab_view.add("About")

        # Set default tab
        self.tab_view.set("Dashboard")

        # Create tab contents
        self.create_dashboard_tab()
        self.create_chatbots_tab()
        self.create_history_tab()
        self.create_config_tab()
        self.create_about_tab()

    def create_dashboard_tab(self):
        """Create the dashboard tab content"""
        # Main container with gradient background
        dashboard_container = ctk.CTkScrollableFrame(
            self.tab_view.tab("Dashboard"),
            fg_color="transparent"
        )
        dashboard_container.pack(fill="both", expand=True, padx=20, pady=0)  # Reduced top padding

        # Create a grid layout for dashboard widgets
        dashboard_container.columnconfigure(0, weight=2)
        dashboard_container.columnconfigure(1, weight=1)
        dashboard_container.rowconfigure(0, weight=1)
        dashboard_container.rowconfigure(1, weight=1)
        dashboard_container.rowconfigure(2, weight=1)

        # Status panel (top left)
        status_panel = self.create_status_panel(dashboard_container)
        status_panel.grid(row=0, column=0, sticky="nsew", padx=(0, 10), pady=(0, 10))

        # Voice assistant control panel (top right)
        control_panel = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=15,
            border_width=1,
            border_color=self.colors["bg_light"]
        )
        control_panel.grid(row=0, column=1, sticky="nsew", padx=(10, 0), pady=(0, 10))

        # Control panel header with icon
        control_header = ctk.CTkFrame(control_panel, fg_color="transparent", height=50)
        control_header.pack(fill="x", padx=20, pady=(15, 5))

        # Control panel title with icon
        control_title = ctk.CTkLabel(
            control_header,
            text="Voice Assistant",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        control_title.pack(side="left")

        # Start/Stop button with improved styling
        self.toggle_button = ctk.CTkButton(
            control_panel,
            text="Start Voice Assistant",
            command=self.toggle_voice_assistant,
            fg_color=self.colors["status_green"],
            hover_color=self._adjust_color_brightness(self.colors["status_green"], 0.8),
            height=60,
            corner_radius=10,
            font=self.fonts["subtitle"],
            border_width=1,
            border_color=self._adjust_color_brightness(self.colors["status_green"], 1.2)
        )
        self.toggle_button.pack(fill="x", padx=20, pady=15)
        
        # Recording buttons container
        recording_buttons_frame = ctk.CTkFrame(control_panel, fg_color="transparent")
        recording_buttons_frame.pack(fill="x", padx=20, pady=10)

        # Record button
        self.record_button = ctk.CTkButton(
            recording_buttons_frame,
            text="Record",
            command=self.start_manual_recording,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            height=40,
            width=150,
            corner_radius=10
        )
        self.record_button.pack(side="left", fill="x", expand=True, padx=(0, 5))

        # Stop Recording button
        self.stop_record_button = ctk.CTkButton(
            recording_buttons_frame,
            text="Stop Recording",
            command=self.stop_manual_recording,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            height=40,
            width=150,
            corner_radius=10,
            state="disabled"
        )
        self.stop_record_button.pack(side="right", fill="x", expand=True, padx=(5, 0))

        # Add synthesizer bar to show voice detection
        self.synth_bar = SynthesizerBar(control_panel, self.colors, self.fonts)

        # Microphone sensitivity slider
        sensitivity_frame = ctk.CTkFrame(
            control_panel,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        sensitivity_frame.pack(fill="x", padx=20, pady=10)

        sensitivity_label = ctk.CTkLabel(
            sensitivity_frame,
            text="Microphone Sensitivity",
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"]
        )
        sensitivity_label.pack(anchor="w", padx=15, pady=(10, 5))

        sensitivity_control = ctk.CTkFrame(sensitivity_frame, fg_color="transparent")
        sensitivity_control.pack(fill="x", padx=15, pady=(0, 10))

        self.sensitivity_var = ctk.DoubleVar(value=0.5)
        self.sensitivity_slider = ctk.CTkSlider(
            sensitivity_control,
            from_=0.1,
            to=1.0,
            variable=self.sensitivity_var,
            width=200,
            progress_color=self.colors["accent_primary"],
            button_color=self.colors["accent_secondary"],
            button_hover_color=self.colors["accent_primary"]
        )
        self.sensitivity_slider.pack(side="left", fill="x", expand=True, padx=(0, 10))

        self.sensitivity_value = ctk.CTkLabel(
            sensitivity_control,
            text=f"{int(self.sensitivity_var.get() * 100)}%",
            font=self.fonts["small"],
            width=40,
            text_color=self.colors["text_dim"]
        )
        self.sensitivity_value.pack(side="right")

        # Update sensitivity value when slider changes
        def update_sensitivity(*args):
            self.sensitivity_value.configure(text=f"{int(self.sensitivity_var.get() * 100)}%")
            if hasattr(self, 'gain_var'):
                self.gain_var.set(self.sensitivity_var.get())

        self.sensitivity_var.trace_add("write", update_sensitivity)
        
        # Initialize gain variable for level meter
        self.gain_var = ctk.DoubleVar(value=self.sensitivity_var.get())

        # Status indicator with improved styling
        status_frame = ctk.CTkFrame(
            control_panel,
            fg_color=self.colors["bg_light"],
            corner_radius=10,
            height=50
        )
        status_frame.pack(fill="x", padx=20, pady=10)
        status_frame.pack_propagate(False)

        status_label = ctk.CTkLabel(
            status_frame,
            text="Status: Idle",
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"]
        )
        status_label.pack(side="left", padx=15, pady=10)

        self.status_indicator = ctk.CTkFrame(
            status_frame,
            fg_color=self.colors["status_gray"],
            width=20,
            height=20,
            corner_radius=10
        )
        self.status_indicator.pack(side="right", padx=15)

        # Transcription section (middle)
        transcription_frame = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=15,
            border_width=1,
            border_color=self.colors["bg_light"]
        )
        transcription_frame.grid(row=1, column=0, columnspan=2, sticky="nsew", pady=(0, 10))
            
        # Transcription header
        transcription_header = ctk.CTkFrame(transcription_frame, fg_color="transparent", height=50)
        transcription_header.pack(fill="x", padx=20, pady=(15, 5))
        
        transcription_title = ctk.CTkLabel(
            transcription_header,
            text="📝 Transcription",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        transcription_title.pack(side="left")
        
        # Controls frame
        controls = ctk.CTkFrame(transcription_header, fg_color="transparent")
        controls.pack(side="right")
        
        # Clear button
        clear_button = ctk.CTkButton(
            controls,
            text="Clear",
            command=lambda: self.clear_transcription(),
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            width=80
        )
        clear_button.pack(side="right", padx=(0, 10))
        
        # Enter button
        self.enter_button = ctk.CTkButton(
            controls,
            text="Enter",
            command=self.process_transcription,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            width=100,
            state="disabled"
        )
        self.enter_button.pack(side="right")
        
        # Transcription display
        self.transcription_display = ctk.CTkTextbox(
            transcription_frame,
            fg_color=self.colors["bg_light"],
            text_color=self.colors["text_bright"],
            font=self.fonts["large"],
            corner_radius=10,
            border_width=1,
            border_color=self.colors["bg_light"],
            height=150
        )
        self.transcription_display.pack(fill="both", expand=True, padx=20, pady=(5, 20))
        
        # Configure text tags
        self.transcription_display._textbox.tag_configure("timestamp", foreground=self.colors["accent_secondary"])
        self.transcription_display._textbox.tag_configure("transcription", foreground=self.colors["text_bright"])
        
        # Add initial message
        self.transcription_display.configure(state="normal")
        self.transcription_display.insert("end", "Transcribed text will appear here...")
        self.transcription_display.configure(state="disabled")

        # Voice commands section (bottom)
        text_display_frame = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=15,
            border_width=1,
            border_color=self.colors["bg_light"]
        )
        text_display_frame.grid(row=2, column=0, columnspan=2, sticky="nsew")
                
        # Text display header
        text_header = ctk.CTkFrame(text_display_frame, fg_color="transparent", height=50)
        text_header.pack(fill="x", padx=20, pady=(15, 5))
        
        text_title = ctk.CTkLabel(
            text_header,
            text="🔊 Voice Commands",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        text_title.pack(side="left")
        
        # Clear button for text display
        clear_text_button = ctk.CTkButton(
            text_header,
            text="Clear",
            command=lambda: self.clear_text_display(),
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            width=80
        )
        clear_text_button.pack(side="right")
        
        # Text display area
        self.text_display = ctk.CTkTextbox(
            text_display_frame,
            fg_color=self.colors["bg_light"],
            text_color=self.colors["text_bright"],
            font=self.fonts["large"],
            corner_radius=10,
            border_width=1,
            border_color=self.colors["bg_light"],
            height=200
        )
        self.text_display.pack(fill="both", expand=True, padx=20, pady=(5, 20))
        
        # Configure text tags
        self.text_display._textbox.tag_configure("timestamp", foreground=self.colors["accent_secondary"])
        self.text_display._textbox.tag_configure("command", foreground=self.colors["accent_primary"])
        self.text_display._textbox.tag_configure("system", foreground=self.colors["status_blue"])
        
        # Add initial message
        self.text_display.configure(state="normal")
        self.text_display.insert("end", "Voice commands will appear here after starting the voice assistant...")
        self.text_display.configure(state="disabled")

        # Initialize monitor visualization
        self.app.after(500, self.refresh_monitor_visualization)

    def create_synthesizer_bar(self, parent):
        """Create a synthesizer bar to visualize voice detection"""
        # Use the new SynthesizerBar class if available
        try:
            from synthesizer_bar import SynthesizerBar
            self.synth_bar = SynthesizerBar(parent, self.colors, self.fonts)
            return
        except ImportError:
            logging.warning(
                "SynthesizerBar class not found, using fallback implementation")

        # Fallback implementation
        synth_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10,
            height=80
        )
        synth_frame.pack(fill="x", padx=20, pady=10)

        # Synthesizer label
        synth_label = ctk.CTkLabel(
            synth_frame,
            text="Voice Detection",
            font=self.fonts["normal"],
            text_color=self.colors["text_bright"]
        )
        synth_label.pack(anchor="w", padx=15, pady=(10, 5))

        # Create level meter canvas
        self.level_canvas = ctk.CTkCanvas(
            synth_frame,
            bg=self.colors["bg_dark"],
            highlightthickness=0,
            height=30
        )
        self.level_canvas.pack(fill="x", padx=15, pady=(0, 10))

        # Initialize level meter with zero level
        self.app.after(100, lambda: self._update_level_meter(0))

    def create_chatbots_tab(self):
        """Create the chatbots tab content"""
        # Main container
        chatbots_container = ctk.CTkFrame(
            self.tab_view.tab("Chatbots"),
            fg_color="transparent"
        )
        chatbots_container.pack(fill="both", expand=True, padx=20, pady=20)

        # Title and add button row
        title_frame = ctk.CTkFrame(chatbots_container, fg_color="transparent")
        title_frame.pack(fill="x", pady=(0, 15))

        # Title with icon
        title_label = ctk.CTkLabel(
            title_frame,
            text="Chatbot Management",
            font=ctk.CTkFont(size=24, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title_label.pack(side="left")

        # Add chatbot button
        add_button = ctk.CTkButton(
            title_frame,
            text="Add New Chatbot",
            command=self.show_add_chatbot_dialog,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            width=120
        )
        add_button.pack(side="right")

        # Search frame
        search_frame = ctk.CTkFrame(
            chatbots_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=10,
            height=50
        )
        search_frame.pack(fill="x", pady=(0, 15))
        search_frame.pack_propagate(False)

        # Search icon
        search_icon = ctk.CTkLabel(
            search_frame,
            text="🔍",
            font=ctk.CTkFont(size=16),
            width=30
        )
        search_icon.pack(side="left", padx=(15, 0))

        # Search entry
        self.search_var = ctk.StringVar()
        self.search_var.trace_add(
            "write", lambda *args: self.filter_chatbot_list())
        search_entry = ctk.CTkEntry(
            search_frame,
            placeholder_text="Search chatbots...",
            textvariable=self.search_var,
            border_width=0,
            fg_color="transparent",
            height=40
        )
        search_entry.pack(side="left", fill="x", expand=True, padx=10)

        # Chatbot list container
        self.chatbot_list_frame = ctk.CTkScrollableFrame(
            chatbots_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        self.chatbot_list_frame.pack(fill="both", expand=True)

        # Refresh chatbot list
        self.refresh_chatbots()

    def create_about_tab(self):
        """Create the about tab content"""
        # Main container
        about_container = ctk.CTkFrame(
            self.tab_view.tab("About"),
            fg_color="transparent"
        )
        about_container.pack(fill="both", expand=True, padx=20, pady=20)

        # Create a scrollable frame for the about content
        about_scroll = ctk.CTkScrollableFrame(
            about_container,
            fg_color="transparent"
        )
        about_scroll.pack(fill="both", expand=True)

        # Logo and title
        logo_frame = ctk.CTkFrame(about_scroll, fg_color="transparent")
        logo_frame.pack(fill="x", pady=(0, 20))

        # App title
        title_label = ctk.CTkLabel(
            logo_frame,
            text="DragonVoice",
            font=ctk.CTkFont(size=32, weight="bold"),
            text_color=self.colors["accent_primary"]
        )
        title_label.pack(pady=(0, 5))

        # Version
        version_label = ctk.CTkLabel(
            logo_frame,
            text="Version 2.0",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"]
        )
        version_label.pack()

        # Description
        description_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        description_frame.pack(fill="x", pady=10, padx=5)

        description_label = ctk.CTkLabel(
            description_frame,
            text="DragonVoice is an advanced voice assistant that integrates with multiple AI chatbots.\n"
            "It provides a seamless voice interface for interacting with AI models and controlling your computer.",
            font=ctk.CTkFont(
                size=14),
            text_color=self.colors["text_normal"],
            wraplength=600,
            justify="left")
        description_label.pack(padx=20, pady=20)

        # Features
        features_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        features_frame.pack(fill="x", pady=10, padx=5)

        features_title = ctk.CTkLabel(
            features_frame,
            text="Key Features",
            font=ctk.CTkFont(size=18, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        features_title.pack(anchor="w", padx=20, pady=(15, 10))

        features = [
            "🎤 Voice recognition with OpenAI Whisper",
            "🤖 Multiple AI chatbot integrations",
            "⌨️ System control through voice commands",
            "📊 Real-time system monitoring",
            "🎨 Customizable themes and appearance",
            "🔧 Advanced configuration options"
        ]

        for feature in features:
            feature_label = ctk.CTkLabel(
                features_frame,
                text=feature,
                font=ctk.CTkFont(size=14),
                text_color=self.colors["text_normal"],
                anchor="w"
            )
            feature_label.pack(anchor="w", padx=20, pady=5)

        # Credits
        credits_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        credits_frame.pack(fill="x", pady=10, padx=5)

        credits_title = ctk.CTkLabel(
            credits_frame,
            text="Credits",
            font=ctk.CTkFont(size=18, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        credits_title.pack(anchor="w", padx=20, pady=(15, 10))

        credits_label = ctk.CTkLabel(
            credits_frame,
            text="Developed by: DragonVoice Team\n"
                 "UI Framework: CustomTkinter\n"
                 "Voice Recognition: OpenAI Whisper\n"
                 "Special thanks to all contributors and testers",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            justify="left"
        )
        credits_label.pack(anchor="w", padx=20, pady=(0, 15))

        # Links
        links_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        links_frame.pack(fill="x", pady=10, padx=5)

        links_title = ctk.CTkLabel(
            links_frame,
            text="Links",
            font=ctk.CTkFont(size=18, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        links_title.pack(anchor="w", padx=20, pady=(15, 10))

        # Function to open links
        def open_link(url):
            import webbrowser
            webbrowser.open(url)

        # Website link
        website_button = ctk.CTkButton(
            links_frame,
            text="Visit Website",
            command=lambda: open_link("https://dragonvoice.ai"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        website_button.pack(anchor="w", padx=20, pady=5)

        # Documentation link
        docs_button = ctk.CTkButton(
            links_frame,
            text="Documentation",
            command=lambda: open_link("https://docs.dragonvoice.ai"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        docs_button.pack(anchor="w", padx=20, pady=5)

        # GitHub link
        github_button = ctk.CTkButton(
            links_frame,
            text="GitHub Repository",
            command=lambda: open_link("https://github.com/dragonvoice/dragonvoice"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"])
        github_button.pack(anchor="w", padx=20, pady=(5, 15))

    def create_settings_advanced_tab(self, parent):
        """Create the advanced settings tab content"""
        # Main container
        container = ctk.CTkFrame(parent, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)

        # Logging settings section
        logging_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        logging_frame.pack(fill="x", pady=(0, 15))

        # Section title
        logging_title = ctk.CTkLabel(
            logging_frame,
            text="Logging Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        logging_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Log level
        log_level_frame = ctk.CTkFrame(logging_frame, fg_color="transparent")
        log_level_frame.pack(fill="x", padx=15, pady=5)

        log_level_label = ctk.CTkLabel(
            log_level_frame,
            text="Log Level",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        log_level_label.pack(side="left")

        self.log_level_var = ctk.StringVar(value="INFO")
        log_level_dropdown = ctk.CTkOptionMenu(
            log_level_frame,
            values=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
            variable=self.log_level_var,
            width=200
        )
        log_level_dropdown.pack(side="left", padx=10)

        # Enable file logging
        file_logging_frame = ctk.CTkFrame(
            logging_frame, fg_color="transparent")
        file_logging_frame.pack(fill="x", padx=15, pady=5)

        file_logging_label = ctk.CTkLabel(
            file_logging_frame,
            text="File Logging",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        file_logging_label.pack(side="left")

        self.file_logging_var = ctk.BooleanVar(value=True)
        file_logging_switch = ctk.CTkSwitch(
            file_logging_frame,
            text="",
            variable=self.file_logging_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        file_logging_switch.pack(side="left", padx=10)

        # Performance settings section
        performance_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        performance_frame.pack(fill="x", pady=(0, 15))

        # Section title
        performance_title = ctk.CTkLabel(
            performance_frame,
            text="Performance Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        performance_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Hardware acceleration
        hardware_frame = ctk.CTkFrame(
            performance_frame, fg_color="transparent")
        hardware_frame.pack(fill="x", padx=15, pady=5)

        hardware_label = ctk.CTkLabel(
            hardware_frame,
            text="Hardware Acceleration",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        hardware_label.pack(side="left")

        self.hardware_var = ctk.BooleanVar(value=True)
        hardware_switch = ctk.CTkSwitch(
            hardware_frame,
            text="",
            variable=self.hardware_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        hardware_switch.pack(side="left", padx=10)

        # Thread count
        thread_frame = ctk.CTkFrame(performance_frame, fg_color="transparent")
        thread_frame.pack(fill="x", padx=15, pady=5)

        thread_label = ctk.CTkLabel(
            thread_frame,
            text="Worker Threads",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        thread_label.pack(side="left")

        self.thread_var = ctk.IntVar(value=4)
        thread_slider = ctk.CTkSlider(
            thread_frame,
            from_=1,
            to=16,
            number_of_steps=15,
            variable=self.thread_var,
            width=200
        )
        thread_slider.pack(side="left", padx=10)

        thread_value = ctk.CTkLabel(
            thread_frame,
            textvariable=self.thread_var,
            width=30
        )
        thread_value.pack(side="left", padx=5)

        # Memory limit
        memory_frame = ctk.CTkFrame(performance_frame, fg_color="transparent")
        memory_frame.pack(fill="x", padx=15, pady=5)

        memory_label = ctk.CTkLabel(
            memory_frame,
            text="Memory Limit (MB)",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        memory_label.pack(side="left")

        self.memory_var = ctk.IntVar(value=1024)
        memory_slider = ctk.CTkSlider(
            memory_frame,
            from_=256,
            to=4096,
            number_of_steps=15,
            variable=self.memory_var,
            width=200
        )
        memory_slider.pack(side="left", padx=10)

        memory_value = ctk.CTkLabel(
            memory_frame,
            textvariable=self.memory_var,
            width=50
        )
        memory_value.pack(side="left", padx=5)

        # Reset button
        reset_button = ctk.CTkButton(
            container,
            text="Reset to Defaults",
            command=lambda: self.reset_advanced_settings(),
            fg_color=self.colors["bg_medium"],
            hover_color=self.colors["bg_light"],
            width=150
        )
        reset_button.pack(anchor="e", pady=10)

        return container

    def reset_advanced_settings(self):
        """Reset advanced settings to defaults"""
        self.log_level_var.set("INFO")
        self.file_logging_var.set(True)
        self.hardware_var.set(True)
        self.thread_var.set(4)
        self.memory_var.set(1024)
        self.update_status("Advanced settings reset to defaults")

    def apply_theme(self, theme_name):
        """Apply the selected theme"""
        if theme_name in self.color_schemes:
            self.colors = self.color_schemes[theme_name]
            self.config["theme"] = theme_name
            self.save_configuration(show_notification=False)
            # Refresh UI with new theme
            self.setup_theme()
            self.refresh_ui()

    def show_add_chatbot_dialog(self):
        """Show dialog to add a new chatbot"""
        dialog = ctk.CTkToplevel(self.app)
        dialog.title("Add New Chatbot")
        dialog.geometry("400x500")
        dialog.transient(self.app)
        dialog.grab_set()

        # Create form fields
        name_label = ctk.CTkLabel(
            dialog,
            text="Chatbot Name",
            text_color=self.colors["text_bright"]
        )
        name_label.pack(anchor="w", padx=20, pady=(20, 0))

        name_entry = ctk.CTkEntry(dialog, width=360)
        name_entry.pack(anchor="w", padx=20, pady=(0, 10))

        type_label = ctk.CTkLabel(
            dialog,
            text="Chatbot Type",
            text_color=self.colors["text_bright"]
        )
        type_label.pack(anchor="w", padx=20, pady=(10, 0))

        type_var = ctk.StringVar(value="GPT")
        type_dropdown = ctk.CTkOptionMenu(
            dialog,
            values=["GPT", "Claude", "Gemini", "Custom"],
            variable=type_var,
            width=360
        )
        type_dropdown.pack(anchor="w", padx=20, pady=(0, 10))

        api_key_label = ctk.CTkLabel(
            dialog,
            text="API Key",
            text_color=self.colors["text_bright"]
        )
        api_key_label.pack(anchor="w", padx=20, pady=(10, 0))

        api_key_entry = ctk.CTkEntry(dialog, width=360, show="*")
        api_key_entry.pack(anchor="w", padx=20, pady=(0, 10))

        # Add chatbot button
        def add_chatbot():
            name = name_entry.get()
            chatbot_type = type_var.get()
            api_key = api_key_entry.get()

            if name and chatbot_type and api_key:
                # Add to config
                if "chatbots" not in self.config:
                    self.config["chatbots"] = {}

                self.config["chatbots"][name] = {
                    "type": chatbot_type,
                    "api_key": api_key,
                    "status": "Ready",
                    "color": self.colors["accent_primary"],
                    "icon": "🤖"
                }

                self.save_configuration()
                self.refresh_chatbot_list()
                dialog.destroy()
            else:
                # Show error
                error_label.configure(text="Please fill in all fields")

        add_button = ctk.CTkButton(
            dialog,
            text="Add Chatbot",
            command=add_chatbot,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        add_button.pack(anchor="center", pady=20)

        # Error label
        error_label = ctk.CTkLabel(
            dialog,
            text="",
            text_color=self.colors["error"]
        )
        error_label.pack(anchor="center")

    def refresh_chatbot_list(self):
        """Refresh the list of chatbots in settings"""
        # Clear existing items
        for widget in self.chatbot_list_frame.winfo_children():
            widget.destroy()

        # Add header
        header = ctk.CTkFrame(
            self.chatbot_list_frame,
            fg_color="transparent"
        )
        header.pack(fill="x", padx=15, pady=5)

        ctk.CTkLabel(
            header,
            text="Name",
            font=ctk.CTkFont(weight="bold"),
            text_color=self.colors["text_bright"],
            width=100
        ).pack(side="left")

        ctk.CTkLabel(
            header,
            text="Type",
            font=ctk.CTkFont(weight="bold"),
            text_color=self.colors["text_bright"],
            width=100
        ).pack(side="left")

        ctk.CTkLabel(
            header,
            text="Status",
            font=ctk.CTkFont(weight="bold"),
            text_color=self.colors["text_bright"],
            width=100
        ).pack(side="left")

        # Add chatbots
        for name, config in self.config.get("chatbots", {}).items():
            self.add_chatbot_list_item(name, config)

    def add_chatbot_list_item(self, name, config):
        """Add a single chatbot item to the list"""
        # Create item frame with hover effect
        item = ctk.CTkFrame(
            self.chatbot_list_frame,
            fg_color=self.colors["bg_dark"],
            corner_radius=10,
            height=70
        )
        item.pack(fill="x", padx=5, pady=5)
        item.pack_propagate(False)

        # Add hover effect
        def on_enter(e):
            item.configure(fg_color=self.colors["bg_light"])

        def on_leave(e):
            item.configure(fg_color=self.colors["bg_dark"])

        item.bind("<Enter>", on_enter)
        item.bind("<Leave>", on_leave)

        # Icon and name container
        info_frame = ctk.CTkFrame(
            item,
            fg_color="transparent"
        )
        info_frame.pack(side="left", fill="y", padx=10)

        # Icon with colored background
        icon_frame = ctk.CTkFrame(
            info_frame,
            fg_color=config.get("color", self.colors["accent_primary"]),
            width=40,
            height=40,
            corner_radius=20
        )
        icon_frame.pack(side="left", padx=(0, 10))
        icon_frame.pack_propagate(False)

        icon_label = ctk.CTkLabel(
            icon_frame,
            text=config.get("icon", "🤖"),
            font=ctk.CTkFont(size=20)
        )
        icon_label.place(relx=0.5, rely=0.5, anchor="center")

        # Name and type
        text_frame = ctk.CTkFrame(
            info_frame,
            fg_color="transparent"
        )
        text_frame.pack(side="left", fill="y")

        name_label = ctk.CTkLabel(
            text_frame,
            text=name,
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        name_label.pack(anchor="w")

        type_label = ctk.CTkLabel(
            text_frame,
            text=config.get("type", "Unknown"),
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        type_label.pack(anchor="w")

        # Status indicator
        status_color = self.colors["status_green"] if config.get(
            "status") == "Ready" else self.colors["status_red"]
        status_frame = ctk.CTkFrame(
            item,
            fg_color="transparent"
        )
        status_frame.pack(side="right", fill="y", padx=10)

        status_dot = ctk.CTkLabel(
            status_frame,
            text="●",
            font=ctk.CTkFont(size=20),
            text_color=status_color
        )
        status_dot.pack(side="right", padx=5)

        status_label = ctk.CTkLabel(
            status_frame,
            text=config.get("status", "Unknown"),
            font=ctk.CTkFont(size=12),
            text_color=status_color
        )
        status_label.pack(side="right")

        # Make the entire item clickable
        item.bind(
            "<Button-1>",
            lambda e: self.show_chatbot_settings(
                name,
                config))

    def delete_chatbot(self, name):
        """Delete a chatbot from the configuration"""
        if name in self.config.get("chatbots", {}):
            del self.config["chatbots"][name]
            self.save_configuration()
            self.refresh_chatbot_list()
            # Also refresh the dashboard
            self.add_sample_chatbot_cards()

    def run(self):
        """Run the application main loop"""
        try:
            # Log startup
            logging.info("Starting DragonVoice application")

            # Update status
            self.update_status("Application started successfully")

            # Start the main event loop
            self.app.mainloop()

        except Exception as e:
            logging.error(f"Error in main loop: {str(e)}")
            raise

    def create_help_getting_started(self, parent):
        """Create the getting started help content"""
        # Welcome section
        welcome_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        welcome_frame.pack(fill="x", padx=20, pady=10)

        welcome_label = ctk.CTkLabel(
            welcome_frame,
            text="Welcome to DragonVoice",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        welcome_label.pack(anchor="w", padx=15, pady=(10, 5))

        welcome_text = ctk.CTkTextbox(
            welcome_frame,
            height=100,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        welcome_text.pack(fill="x", padx=15, pady=(0, 10))
        welcome_text.insert(
            "1.0",
            """DragonVoice is a powerful voice-controlled interface for interacting with multiple AI chatbots. This guide will help you get started with the basic features and setup.""")
        welcome_text.configure(state="disabled")

        # Quick Start Guide
        quickstart_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        quickstart_frame.pack(fill="x", padx=20, pady=10)

        quickstart_label = ctk.CTkLabel(
            quickstart_frame,
            text="Quick Start Guide",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        quickstart_label.pack(anchor="w", padx=15, pady=(10, 5))

        steps_text = ctk.CTkTextbox(
            quickstart_frame,
            height=200,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        steps_text.pack(fill="x", padx=15, pady=(0, 10))
        steps_text.insert("1.0", """1. Configure Your Chatbots
• Click the Settings button (⚙️) in the top right
• Go to the Chatbots tab
• Click "Add New Chatbot" and enter your API keys

2. Start Voice Assistant
• Click the "Start Voice Assistant" button in the header
• Wait for the status to show "Ready"
• Say your wake word (default: "Hey Dragon")

3. Issue Commands
• After the wake word, speak your command
• Example: "Ask what are the latest treatments for hypertension"
• The command will be sent to the appropriate chatbot

4. View Responses
• Responses appear in the chatbot windows
• You can interact with multiple chatbots simultaneously
• Use voice commands to switch between chatbots""")
        steps_text.configure(state="disabled")

    def create_help_voice_commands(self, parent):
        """Create the voice commands help content"""
        # Available Commands
        commands_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        commands_frame.pack(fill="x", padx=20, pady=10)

        commands_label = ctk.CTkLabel(
            commands_frame,
            text="Available Voice Commands",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        commands_label.pack(anchor="w", padx=15, pady=(10, 5))

        commands_text = ctk.CTkTextbox(
            commands_frame,
            height=400,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        commands_text.pack(fill="x", padx=15, pady=(0, 10))
        commands_text.insert("1.0", """Basic Commands:
• "Hey Dragon" - Wake word to start listening
• "Ask [question]" - Send a question to the active chatbot
• "Switch to [chatbot name]" - Change the active chatbot
• "Stop listening" - Deactivate voice recognition
• "Clear chat" - Clear the current conversation

Chatbot Control:
• "New conversation" - Start a fresh chat session
• "Save conversation" - Save the current chat history
• "Load conversation" - Restore a previous chat session
• "Export as PDF" - Export the conversation to PDF

Window Management:
• "Maximize window" - Expand the current chatbot window
• "Minimize window" - Minimize the current chatbot window
• "Arrange windows" - Organize all chatbot windows
• "Close window" - Close the current chatbot window

System Commands:
• "Open settings" - Show the settings dialog
• "Show help" - Display this help window
• "Check status" - Report system status
• "Exit program" - Close DragonVoice

Tips:
• Speak clearly and at a normal pace
• Wait for the "Listening..." indicator
• You can customize the wake word in settings
• Commands are case-insensitive""")
        commands_text.configure(state="disabled")

    def create_help_chatbots(self, parent):
        """Create the chatbots help content"""
        # Chatbot Overview
        overview_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        overview_frame.pack(fill="x", padx=20, pady=10)

        overview_label = ctk.CTkLabel(
            overview_frame,
            text="Working with Chatbots",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        overview_label.pack(anchor="w", padx=15, pady=(10, 5))

        overview_text = ctk.CTkTextbox(
            overview_frame,
            height=300,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        overview_text.pack(fill="x", padx=15, pady=(0, 10))
        overview_text.insert(
            "1.0", """DragonVoice supports multiple AI chatbots, allowing you to:
• Interact with different AI models simultaneously
• Compare responses across different chatbots
• Use specialized models for specific tasks
• Maintain separate conversation contexts

Supported Chatbots:
1. GPT (OpenAI)
   • Requires OpenAI API key
   • Supports GPT-3.5 and GPT-4
   • Best for general knowledge and coding

2. Claude (Anthropic)
   • Requires Anthropic API key
   • Excellent for analysis and writing
   • Strong ethical considerations

3. Gemini (Google)
   • Requires Google API key
   • Good at mathematical reasoning
   • Supports image understanding

4. Custom Chatbots
   • Add your own API integrations
   • Configure custom endpoints
   • Define specialized behaviors

Setting Up Chatbots:
1. Obtain API keys from providers
2. Add chatbots in Settings > Chatbots
3. Configure any special parameters
4. Test the connection

Best Practices:
• Keep API keys secure
• Monitor usage and costs
• Regular backup conversations
• Update chatbot configs as needed""")
        overview_text.configure(state="disabled")

    def create_help_troubleshooting(self, parent):
        """Create the troubleshooting help content"""
        # Common Issues
        issues_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        issues_frame.pack(fill="x", padx=20, pady=10)

        issues_label = ctk.CTkLabel(
            issues_frame,
            text="Common Issues",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        issues_label.pack(anchor="w", padx=15, pady=(10, 5))

        issues_text = ctk.CTkTextbox(
            issues_frame,
            height=400,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        issues_text.pack(fill="x", padx=15, pady=(0, 10))
        issues_text.insert("1.0", """Voice Recognition Issues:
1. Microphone Not Detected
   • Check microphone connections
   • Verify Windows permissions
   • Select correct input device in settings
   • Try restarting the application

2. Poor Recognition Accuracy
   • Adjust microphone sensitivity
   • Reduce background noise
   • Speak clearly and at normal pace
   • Check for latest updates

Chatbot Connection Problems:
1. API Key Errors
   • Verify API key is valid
   • Check for sufficient credits
   • Ensure correct API endpoint
   • Look for error messages in logs

2. Slow Responses
   • Check internet connection
   • Verify server status
   • Adjust timeout settings
   • Consider upgrading API tier

Interface Issues:
1. Display Problems
   • Update graphics drivers
   • Check resolution settings
   • Try different theme
   • Restart application

2. Performance Issues
   • Close unused applications
   • Check CPU/memory usage
   • Reduce number of active chatbots
   • Clear conversation history

Getting Help:
• Check application logs
• Visit our support forum
• Submit bug reports
• Contact technical support""")
        issues_text.configure(state="disabled")

    def create_help_about(self, parent):
        """Create the about help content"""
        # About Information
        about_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        about_frame.pack(fill="x", padx=20, pady=10)

        # Logo/Icon placeholder
        logo_label = ctk.CTkLabel(
            about_frame,
            text="🐉",
            font=ctk.CTkFont(size=48),
            text_color=self.colors["accent_primary"]
        )
        logo_label.pack(anchor="center", pady=20)

        # App title
        title_label = ctk.CTkLabel(
            about_frame,
            text="DragonVoice",
            font=ctk.CTkFont(size=24, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title_label.pack(anchor="center")

        # Version
        version_label = ctk.CTkLabel(
            about_frame,
            text="Version 2.0",
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        version_label.pack(anchor="center", pady=(0, 20))

        # Description
        description_text = ctk.CTkTextbox(
            about_frame,
            height=100,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        description_text.pack(fill="x", padx=15, pady=(0, 10))
        description_text.insert(
            "1.0",
            """DragonVoice is a powerful voice-controlled interface for medical professionals to interact with multiple AI chatbots simultaneously. It provides a seamless way to access and compare AI insights while maintaining focus on patient care.""")
        description_text.configure(state="disabled")

        # Credits
        credits_label = ctk.CTkLabel(
            about_frame,
            text="Credits",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        credits_label.pack(anchor="w", padx=15, pady=(10, 5))

        credits_text = ctk.CTkTextbox(
            about_frame,
            height=100,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        credits_text.pack(fill="x", padx=15, pady=(0, 10))
        credits_text.insert("1.0", """• OpenAI Whisper - Speech Recognition
• CustomTkinter - GUI Framework
• Various AI Models - Chatbot Integration
• Open Source Community - Libraries and Tools

Special thanks to all contributors and users who have helped improve DragonVoice.""")
        credits_text.configure(state="disabled")

        # Links
        links_frame = ctk.CTkFrame(
            about_frame,
            fg_color="transparent"
        )
        links_frame.pack(fill="x", padx=15, pady=10)

        website_button = ctk.CTkButton(
            links_frame,
            text="Website",
            width=100,
            command=lambda: webbrowser.open("https://dragonvoice.ai")
        )
        website_button.pack(side="left", padx=5)

        docs_button = ctk.CTkButton(
            links_frame,
            text="Documentation",
            width=100,
            command=lambda: webbrowser.open("https://docs.dragonvoice.ai")
        )
        docs_button.pack(side="left", padx=5)

        github_button = ctk.CTkButton(
            links_frame,
            text="GitHub",
            width=100,
            command=lambda: webbrowser.open("https://github.com/dragonvoice")
        )
        github_button.pack(side="left", padx=5)

    def toggle_theme(self):
        """Toggle between light and dark themes"""
        try:
            # Get current appearance mode
            current_mode = ctk.get_appearance_mode()

            # Toggle mode
            new_mode = "Light" if current_mode == "Dark" else "Dark"
            ctk.set_appearance_mode(new_mode)

            # Update status
            self.update_status(f"Theme changed to {new_mode} mode")

        except Exception as e:
            logging.error(f"Error toggling theme: {str(e)}")
            self.update_status(f"Failed to toggle theme: {str(e)}", "error")

    def start_system_monitoring(self):
        """Start monitoring system resources"""
        try:
            # Initialize status variables if they don't exist
            if not hasattr(self, 'cpu_usage'):
                self.cpu_usage = 0
            if not hasattr(self, 'memory_usage'):
                self.memory_usage = 0
            if not hasattr(self, 'disk_usage'):
                self.disk_usage = 0
            if not hasattr(self, 'voice_status'):
                self.voice_status = "Idle"

            def update_system_info():
                try:
                    # Update CPU usage
                    self.cpu_usage = psutil.cpu_percent(interval=None)

                    # Update memory usage
                    memory = psutil.virtual_memory()
                    self.memory_usage = memory.percent

                    # Update disk usage
                    disk = psutil.disk_usage('/')
                    self.disk_usage = disk.percent

                    # Update status indicators if they exist
                    for i, (value, color) in enumerate([
                        (self.cpu_usage, self.get_resource_color(self.cpu_usage)),
                        (self.memory_usage, self.get_resource_color(self.memory_usage)),
                        (self.disk_usage, self.get_resource_color(self.disk_usage))
                    ]):
                        status_indicator = getattr(self, f'status_indicator_{i}', None)
                        status_value = getattr(self, f'status_value_{i}', None)
                        if status_indicator and status_value:
                            status_indicator.configure(fg_color=color)
                            status_value.configure(
                                text=f"{value:.1f}%",
                                text_color=self.colors["text_bright"]
                            )

                    # Update voice status
                    if hasattr(self, 'recording_active'):
                        voice_status = "Recording" if self.recording_active else "Idle"
                        status_color = self.colors["status_green"] if self.recording_active else self.colors["status_gray"]
                        
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=status_color)
                        if hasattr(self, 'status_value_3'):
                            self.status_value_3.configure(
                                text=voice_status,
                                text_color=self.colors["text_bright"]
                            )

                    # Schedule next update
                    self.app.after(1000, update_system_info)

                except Exception as e:
                    logging.error(f"Error updating system info: {str(e)}")
                    # Try again later
                    self.app.after(5000, update_system_info)

            # Start the update loop
            update_system_info()

        except Exception as e:
            logging.error(f"Error starting system monitoring: {str(e)}")

    def get_resource_color(self, value):
        """Get color based on resource usage percentage"""
        if value < 60:
            return self.colors["status_green"]  # Green for normal
        elif value < 80:
            return self.colors["status_yellow"]  # Yellow for warning
        else:
            return self.colors["status_red"]  # Red for critical

    def filter_chatbot_list(self):
        """Filter the chatbot list based on search text"""
        search_text = self.search_var.get().lower()

        # Clear existing items
        for widget in self.chatbot_list_frame.winfo_children():
            widget.destroy()

        # Add filtered chatbots
        for name, config in self.config.get("chatbots", {}).items():
            if search_text in name.lower():
                self.add_chatbot_list_item(name, config)

    def show_chatbot_settings(self, name, config):
        """Show settings for the selected chatbot"""
        # Update header
        self.selected_chatbot_label.configure(text=f"Settings: {name}")

        # Clear existing settings
        for widget in self.settings_content.winfo_children():
            widget.destroy()

        # Create settings sections
        sections = [
            ("General Settings", self.create_general_settings),
            ("API Configuration", self.create_api_settings),
            ("Model Settings", self.create_model_settings),
            ("Response Settings", self.create_response_settings),
            ("Advanced Options", self.create_advanced_settings)
        ]

        for title, create_func in sections:
            section = create_func(self.settings_content, name, config)
            section.pack(fill="x", padx=10, pady=5)

    def create_general_settings(self, parent, name, config):
        """Create general settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="General Settings",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # Display name
        name_frame = ctk.CTkFrame(frame, fg_color="transparent")
        name_frame.pack(fill="x", padx=15, pady=5)

        name_label = ctk.CTkLabel(
            name_frame,
            text="Display Name:",
            width=120,
            anchor="w"
        )
        name_label.pack(side="left")

        name_entry = ctk.CTkEntry(
            name_frame,
            width=200,
            placeholder_text="Enter display name"
        )
        name_entry.insert(0, name)
        name_entry.pack(side="left", padx=10)

        # Icon selection
        icon_frame = ctk.CTkFrame(frame, fg_color="transparent")
        icon_frame.pack(fill="x", padx=15, pady=5)

        icon_label = ctk.CTkLabel(
            icon_frame,
            text="Icon:",
            width=120,
            anchor="w"
        )
        icon_label.pack(side="left")

        icons = ["🤖", "🧠", "💡", "🔍", "💬", "🌐", "📚", "⚡"]
        icon_var = ctk.StringVar(value=config.get("icon", "🤖"))

        for icon in icons:
            btn = ctk.CTkButton(
                icon_frame,
                text=icon,
                width=40,
                height=40,
                corner_radius=20,
                fg_color=self.colors["bg_medium"] if icon != icon_var.get() else self.colors["accent_primary"],
                hover_color=self.colors["accent_secondary"],
                command=lambda i=icon: [
                    icon_var.set(i),
                    self.update_chatbot_config(
                        name,
                        "icon",
                        i)])
            btn.pack(side="left", padx=2)

        return frame

    def create_api_settings(self, parent, name, config):
        """Create API settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="API Configuration",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # API Key
        key_frame = ctk.CTkFrame(frame, fg_color="transparent")
        key_frame.pack(fill="x", padx=15, pady=5)

        key_label = ctk.CTkLabel(
            key_frame,
            text="API Key:",
            width=120,
            anchor="w"
        )
        key_label.pack(side="left")

        key_entry = ctk.CTkEntry(
            key_frame,
            width=300,
            placeholder_text="Enter API key",
            show="*"
        )
        key_entry.insert(0, config.get("api_key", ""))
        key_entry.pack(side="left", padx=10)

        show_key = ctk.CTkButton(
            key_frame, text="👁️", width=40, command=lambda: key_entry.configure(
                show="" if key_entry.cget("show") == "*" else "*"))
        show_key.pack(side="left")

        # API Endpoint
        endpoint_frame = ctk.CTkFrame(frame, fg_color="transparent")
        endpoint_frame.pack(fill="x", padx=15, pady=5)

        endpoint_label = ctk.CTkLabel(
            endpoint_frame,
            text="API Endpoint:",
            width=120,
            anchor="w"
        )
        endpoint_label.pack(side="left")

        endpoint_entry = ctk.CTkEntry(
            endpoint_frame,
            width=300,
            placeholder_text="Enter API endpoint"
        )
        endpoint_entry.insert(0, config.get("endpoint", ""))
        endpoint_entry.pack(side="left", padx=10)

        # Test connection button
        test_button = ctk.CTkButton(
            frame,
            text="Test Connection",
            command=lambda: self.test_chatbot_connection(name),
            fg_color=self.colors["accent_secondary"]
        )
        test_button.pack(anchor="e", padx=15, pady=10)

        return frame

    def create_model_settings(self, parent, name, config):
        """Create model settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="Model Settings",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # Model selection
        model_frame = ctk.CTkFrame(frame, fg_color="transparent")
        model_frame.pack(fill="x", padx=15, pady=5)

        model_label = ctk.CTkLabel(
            model_frame,
            text="Model:",
            width=120,
            anchor="w"
        )
        model_label.pack(side="left")

        models = {
            "GPT": ["gpt-4", "gpt-3.5-turbo", "gpt-3.5-turbo-16k"],
            "Claude": ["claude-2", "claude-instant"],
            "Gemini": ["gemini-pro", "gemini-pro-vision"],
            "Custom": ["custom-model"]
        }

        model_type = config.get("type", "GPT")
        model_var = ctk.StringVar(
            value=config.get(
                "model", models[model_type][0]))

        model_combo = ctk.CTkComboBox(
            model_frame,
            width=200,
            values=models[model_type],
            variable=model_var,
            state="readonly"
        )
        model_combo.pack(side="left", padx=10)

        # Temperature
        temp_frame = ctk.CTkFrame(frame, fg_color="transparent")
        temp_frame.pack(fill="x", padx=15, pady=5)

        temp_label = ctk.CTkLabel(
            temp_frame,
            text="Temperature:",
            width=120,
            anchor="w"
        )
        temp_label.pack(side="left")

        temp_var = ctk.DoubleVar(value=config.get("temperature", 0.7))
        temp_slider = ctk.CTkSlider(
            temp_frame,
            from_=0.0,
            to=2.0,
            variable=temp_var,
            width=200
        )
        temp_slider.pack(side="left", padx=10)

        temp_value = ctk.CTkLabel(
            temp_frame,
            textvariable=temp_var,
            width=50
        )
        temp_value.pack(side="left")

        return frame

    def create_response_settings(self, parent, name, config):
        """Create response settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="Response Settings",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # Max tokens
        tokens_frame = ctk.CTkFrame(frame, fg_color="transparent")
        tokens_frame.pack(fill="x", padx=15, pady=5)

        tokens_label = ctk.CTkLabel(
            tokens_frame,
            text="Max Tokens:",
            width=120,
            anchor="w"
        )
        tokens_label.pack(side="left")

        tokens_var = ctk.IntVar(value=config.get("max_tokens", 2000))
        tokens_slider = ctk.CTkSlider(
            tokens_frame,
            from_=100,
            to=4000,
            variable=tokens_var,
            width=200
        )
        tokens_slider.pack(side="left", padx=10)

        tokens_value = ctk.CTkLabel(
            tokens_frame,
            textvariable=tokens_var,
            width=50
        )
        tokens_value.pack(side="left")

        # Response format
        format_frame = ctk.CTkFrame(frame, fg_color="transparent")
        format_frame.pack(fill="x", padx=15, pady=5)

        format_label = ctk.CTkLabel(
            format_frame,
            text="Format:",
            width=120,
            anchor="w"
        )
        format_label.pack(side="left")

        format_var = ctk.StringVar(value=config.get("format", "markdown"))
        formats = ["markdown", "html", "plain"]

        format_combo = ctk.CTkComboBox(
            format_frame,
            width=200,
            values=formats,
            variable=format_var,
            state="readonly"
        )
        format_combo.pack(side="left", padx=10)

        return frame

    def create_advanced_settings(self, parent, name, config):
        """Create advanced settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="Advanced Options",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # System prompt
        prompt_label = ctk.CTkLabel(
            frame,
            text="System Prompt:",
            anchor="w"
        )
        prompt_label.pack(anchor="w", padx=15, pady=(5, 0))

        prompt_text = ctk.CTkTextbox(
            frame,
            height=100,
            wrap="word"
        )
        prompt_text.pack(fill="x", padx=15, pady=5)
        prompt_text.insert("1.0", config.get("system_prompt", ""))

        # Checkboxes
        options_frame = ctk.CTkFrame(frame, fg_color="transparent")
        options_frame.pack(fill="x", padx=15, pady=5)

        stream_var = ctk.BooleanVar(value=config.get("stream", True))
        stream_cb = ctk.CTkCheckBox(
            options_frame,
            text="Stream responses",
            variable=stream_var
        )
        stream_cb.pack(anchor="w")

        history_var = ctk.BooleanVar(value=config.get("keep_history", True))
        history_cb = ctk.CTkCheckBox(
            options_frame,
            text="Keep conversation history",
            variable=history_var
        )
        history_cb.pack(anchor="w", pady=5)

        # Action buttons
        buttons_frame = ctk.CTkFrame(frame, fg_color="transparent")
        buttons_frame.pack(fill="x", padx=15, pady=10)

        save_button = ctk.CTkButton(
            buttons_frame,
            text="Save Changes",
            command=lambda: self.save_chatbot_settings(name),
            fg_color=self.colors["accent_primary"]
        )
        save_button.pack(side="left", padx=5)

        delete_button = ctk.CTkButton(
            buttons_frame,
            text="Delete Chatbot",
            command=lambda: self.delete_chatbot(name),
            fg_color=self.colors["error"]
        )
        delete_button.pack(side="right", padx=5)

        return frame

    def refresh_chatbots(self):
        """Refresh the chatbot cards and status in the dashboard"""
        # Update the chatbot list in the dedicated chatbots tab if it exists
        if hasattr(
                self,
                'chatbot_list_frame') and self.chatbot_list_frame.winfo_exists():
            self.refresh_chatbot_list()

        # Update status
        self.update_status("Chatbots refreshed", "info")

        # Refresh the monitor visualization
        if hasattr(self, 'monitor_canvas'):
            self.refresh_monitor_visualization()

        return True

    def load_config(self) -> dict:
        """Load the configuration from the JSON file"""
        try:
            with open(self.config_path, "r") as f:
                config = json.load(f)
                logging.info("Configuration loaded successfully")
                return config
        except FileNotFoundError:
            logging.error(f"Configuration file not found: {self.config_path}")
            return {}
        except json.JSONDecodeError:
            logging.error(
                f"Invalid JSON in configuration file: {self.config_path}")
            return {}

    def toggle_voice_assistant(self):
        """Toggle the voice assistant on/off"""
        # Check if we're in recording mode
        if hasattr(self, 'recording_active') and self.recording_active:
            # Update button text and color
            if hasattr(self, 'toggle_button'):
                self.toggle_button.configure(
                    text="Start Voice Assistant",
                    fg_color=self.colors["status_green"]  # Green when off
                )

            # Stop recording and transcribe
            if self.stop_manual_recording():
                # Transcribe the recording
                self.transcribe_last_recording()
                # Disable continuous recording
                self.continuous_recording = False

            # Update status indicator
            if hasattr(self, 'status_indicator'):
                self.status_indicator.configure(
                    fg_color=self.colors["status_gray"])
                
            # Enable record button, disable stop button
            if hasattr(self, 'record_button'):
                self.record_button.configure(state="normal")
            if hasattr(self, 'stop_record_button'):
                self.stop_record_button.configure(state="disabled")
        else:
            # Update button text and color
            if hasattr(self, 'toggle_button'):
                self.toggle_button.configure(
                    text="Stop Voice Assistant",
                    fg_color=self.colors["status_red"]  # Red when recording
                )

            # Start recording
            success = self.start_manual_recording()
            if success:
                # Enable continuous recording
                self.continuous_recording = True
                self.recording_active = True

                # Update status indicator
                if hasattr(self, 'status_indicator'):
                    self.status_indicator.configure(
                        fg_color=self.colors["status_green"])
                        
                # Disable record button, enable stop button
                if hasattr(self, 'record_button'):
                    self.record_button.configure(state="disabled")
                if hasattr(self, 'stop_record_button'):
                    self.stop_record_button.configure(state="normal")

                if hasattr(self, 'text_display'):
                    # Update the text display to show that voice assistant is active
                    self.text_display.configure(state="normal")
                    timestamp = datetime.now().strftime("%H:%M:%S")

                    # Add system message with formatting
                    system_pos = self.text_display.index("end-1c")
                    self.text_display.insert(
                        "end", f"[{timestamp}] Voice Assistant activated. Speak now...\n\n")
                    self.text_display._textbox.tag_add(
                        "system", system_pos, self.text_display.index("end-2c"))

                    self.text_display.see("end")
                    self.text_display.configure(state="disabled")
                    # Update status
                    self.update_status(
                        "Voice Assistant activated. Speak now...",
                        log_level="info")

    def start_manual_recording(self):
        """Start manual recording"""
        if not hasattr(self, 'whisper_recognizer') or self.whisper_recognizer is None:
            self.update_status("Whisper recognizer not initialized", log_level="error")
            return False

        try:
            # Get the selected microphone device if available
            device_id = None
            if hasattr(self, 'mic_device_var') and self.mic_device_var.get() != "Default":
                # Extract device ID from the selection string
                device_str = self.mic_device_var.get()
                if ":" in device_str:
                    device_id = int(device_str.split(":")[0].strip())
            
            # Log the device being used
            logging.info(f"Started recording audio with device_id: {device_id}")
            
            # Start recording with the selected device
            self.whisper_recognizer.start_recording(device=device_id)
            self.recording_active = True

            # Start level meter animation
            self.animate_level_meter()

            # Update UI
            if hasattr(self, 'toggle_button'):
                self.toggle_button.configure(text="Stop Voice Assistant")
                
            # Update status
            self.update_status("Voice Assistant activated. Speak now...", log_level="info")
            return True
        except Exception as e:
            self.update_status(f"Failed to start recording: {str(e)}", log_level="error")
            return False

    def stop_manual_recording(self):
        """Stop recording audio manually"""
        if not hasattr(self, 'whisper_recognizer'):
            self.update_status(
                "Whisper recognizer not initialized",
                log_level="error")
            return False

        try:
            # Stop recording
            success = self.whisper_recognizer.stop_recording()
            if success:
                self.update_status("Recording stopped", log_level="info")
                # Update UI to show stopped state
                self.toggle_button.configure(
                    text="Start Voice Assistant",
                    fg_color=self.colors["status_green"]
                )
                # Enable transcribe button after recording
                if hasattr(self, 'transcribe_button'):
                    self.transcribe_button.configure(state="normal")
                # Stop level meter animation
                self.recording_active = False

                # Update text display to show that voice assistant is stopped
                if hasattr(self, 'text_display'):
                    self.text_display.configure(state="normal")
                    timestamp = datetime.now().strftime("%H:%M:%S")

                    # Add system message with formatting
                    system_pos = self.text_display.index("end-1c")
                    self.text_display.insert(
                        "end", f"[{timestamp}] Voice Assistant stopped.\n\n")
                    self.text_display._textbox.tag_add(
                        "system", system_pos, self.text_display.index("end-2c"))

                    self.text_display.see("end")
                    self.text_display.configure(state="disabled")

                # Transcribe the recording
                self.transcribe_last_recording()

                return True
            else:
                self.update_status("No recording to stop", log_level="warning")
                return False
        except Exception as e:
            self.update_status(
                f"Error stopping recording: {str(e)}",
                log_level="error")
            return False

    def transcribe_last_recording(self):
        """Transcribe the last recording using Whisper API"""
        try:
            # Check if whisper recognizer is initialized
            if not hasattr(self, 'whisper_recognizer') or self.whisper_recognizer is None:
                self.update_status("Whisper recognizer not initialized")
                logging.warning("Attempted to transcribe without initialized recognizer")
                return
                
            # Save audio to file and check if we have audio data
            if not hasattr(self, 'audio_data') or self.audio_data is None or len(self.audio_data) == 0:
                self.update_status("No audio data available for transcription")
                logging.warning("No audio data available for transcription")
                return
                
            # Update status
            self.update_status("Transcribing audio...")
            
            # Transcribe the audio
            transcription = self.whisper_recognizer.transcribe_audio(self.audio_data)
            
            if transcription:
                # Update status
                self.update_status(f"Transcription successful: {transcription[:30]}...")
                
                # Add to transcription display
                self.add_to_transcription(transcription)
                
                # Add to voice commands display
                self.add_to_text_display(transcription)
                
                # Auto-start recording if continuous mode is enabled
                if self.continuous_recording:
                    self.start_manual_recording()
            else:
                self.update_status("Transcription failed or returned empty result")
                logging.warning("Transcription failed or returned empty result")
                
        except Exception as e:
            self.update_status(f"Error during transcription: {str(e)}")
            logging.error(f"Error during transcription: {str(e)}", exc_info=True)
            
        # Disable the transcribe button after transcription
        if hasattr(self, 'transcribe_button'):
            self.transcribe_button.configure(state="disabled")

    def animate_level_meter(self):
        """Animate the microphone level meter during recording"""
        if not hasattr(self, 'recording_active') or not self.recording_active:
            # Even when not recording, update with zero level to show the meter
            if hasattr(self, 'synth_bar'):
                self.synth_bar.update(0)
            return

        try:
            # Get the latest audio data if available
            if hasattr(self, 'whisper_recognizer') and self.whisper_recognizer.audio_data:
                latest_chunk = self.whisper_recognizer.audio_data[-1]
                
                # Calculate volume (RMS)
                volume = np.sqrt(np.mean(latest_chunk**2))
                
                # Apply sensitivity/gain from the slider
                if hasattr(self, 'sensitivity_var'):
                    # Apply a logarithmic scaling for more natural sensitivity control
                    sensitivity = self.sensitivity_var.get()
                    volume = volume * (np.exp(sensitivity * 2) - 1)
                
                # Add noise floor threshold to filter out background noise
                noise_floor = 0.01  # Adjust this value based on testing
                if volume < noise_floor:
                    volume = 0
                
                # Scale for visualization (0-100) with more moderate scaling
                volume = min(100, volume * 150)  # Reduced from 300 to 150

                # Update the level meter
                if hasattr(self, 'synth_bar'):
                    self.synth_bar.update(volume)
                
                # Update voice status indicator
                if hasattr(self, 'status_value_3'):
                    if volume > 70:  # High volume
                        self.status_value_3.configure(text="Speaking")
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=self.colors["status_red"])
                    elif volume > 30:  # Medium volume
                        self.status_value_3.configure(text="Active")
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=self.colors["status_yellow"])
                    else:  # Low/no volume
                        self.status_value_3.configure(text="Listening")
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=self.colors["status_green"])
            else:
                # If no audio data, show no activity
                if hasattr(self, 'synth_bar'):
                    self.synth_bar.update(0)
            
            # Continue animation if recording is still active
            if self.recording_active:
                self.app.after(50, self.animate_level_meter)  # Faster updates for smoother animation
                
        except Exception as e:
            logging.error(f"Error in level meter animation: {str(e)}")
            # Try to continue animation despite error
            if hasattr(self, 'recording_active') and self.recording_active:
                self.app.after(100, self.animate_level_meter)

    def refresh_monitor_visualization(self):
        """Update the system monitor visualization"""
        try:
            # Check if monitor_canvas exists
            if not hasattr(self, 'monitor_canvas'):
                logging.warning("monitor_canvas not initialized yet")
                return

            # Clear previous visualization
            self.monitor_canvas.delete("all")

            # Get system metrics
            import psutil
            cpu_percent = psutil.cpu_percent()
            memory_percent = psutil.virtual_memory().percent
            disk_percent = psutil.disk_usage('/').percent

            # Canvas dimensions
            width = self.monitor_canvas.winfo_width()
            height = self.monitor_canvas.winfo_height()

            # Ensure we have valid dimensions
            if width <= 1 or height <= 1:
                # Canvas not properly sized yet, schedule another update
                self.app.after(1000, self.refresh_monitor_visualization)
                return

            # Bar width and spacing
            bar_width = width / 4
            spacing = width / 12

            # Draw CPU bar
            cpu_color = self.get_resource_color(cpu_percent)
            cpu_height = (cpu_percent / 100) * height
            self.monitor_canvas.create_rectangle(
                spacing, height - cpu_height,
                spacing + bar_width, height,
                fill=cpu_color, outline=""
            )
            self.monitor_canvas.create_text(
                spacing + bar_width / 2, height - cpu_height - 15,
                text=f"CPU\n{cpu_percent}%",
                fill=self.colors["text_bright"],
                font=("Helvetica", 10, "bold"),
                justify="center"
            )

            # Draw Memory bar
            mem_color = self.get_resource_color(memory_percent)
            mem_height = (memory_percent / 100) * height
            self.monitor_canvas.create_rectangle(
                spacing * 2 + bar_width, height - mem_height,
                spacing * 2 + bar_width * 2, height,
                fill=mem_color, outline=""
            )
            self.monitor_canvas.create_text(
                spacing * 2 + bar_width * 1.5, height - mem_height - 15,
                text=f"RAM\n{memory_percent}%",
                fill=self.colors["text_bright"],
                font=("Helvetica", 10, "bold"),
                justify="center"
            )

            # Draw Disk bar
            disk_color = self.get_resource_color(disk_percent)
            disk_height = (disk_percent / 100) * height
            self.monitor_canvas.create_rectangle(
                spacing * 3 + bar_width * 2, height - disk_height,
                spacing * 3 + bar_width * 3, height,
                fill=disk_color, outline=""
            )
            self.monitor_canvas.create_text(
                spacing * 3 + bar_width * 2.5, height - disk_height - 15,
                text=f"Disk\n{disk_percent}%",
                fill=self.colors["text_bright"],
                font=("Helvetica", 10, "bold"),
                justify="center"
            )

            # Schedule next update
            self.app.after(2000, self.refresh_monitor_visualization)

        except Exception as e:
            logging.error(f"Error updating monitor visualization: {str(e)}")
            # Try again later
            self.app.after(5000, self.refresh_monitor_visualization)

    def update_status(self, message, log_level="info"):
        """Update the status message in the footer"""
        try:
            # Log the message with appropriate level
            if log_level == "info":
                logging.info(message)
            elif log_level == "warning":
                logging.warning(message)
            elif log_level == "error":
                logging.error(message)

            # Check if status_label exists before updating
            if hasattr(self, 'status_label') and self.status_label is not None:
                self.status_label.configure(text=message)
            else:
                logging.warning(
                    "Status label not initialized yet, can't update status")

        except Exception as e:
            logging.error(f"Error updating status: {str(e)}")
            # Don't raise the exception to avoid crashing the app

    def _adjust_color_brightness(self, hex_color, factor):
        """Adjust the brightness of a hex color"""
        # Convert hex to RGB
        r, g, b = self.hex_to_rgb(hex_color)
        
        # Adjust brightness
        r = max(0, min(255, int(r * factor)))
        g = max(0, min(255, int(g * factor)))
        b = max(0, min(255, int(b * factor)))
        
        # Convert back to hex
        return f'#{r:02x}{g:02x}{b:02x}'
        
    def clear_transcription(self):
        """Clear the transcription display"""
        self.transcription_display.configure(state="normal")
        self.transcription_display.delete("1.0", "end")
        self.transcription_display.insert("end", "Transcribed text will appear here...")
        self.transcription_display.configure(state="disabled")
        self.enter_button.configure(state="disabled")
        
    def clear_text_display(self):
        """Clear the text display"""
        self.text_display.configure(state="normal")
        self.text_display.delete("1.0", "end")
        self.text_display.insert("end", "Voice commands will appear here after starting the voice assistant...")
        self.text_display.configure(state="disabled")

    def toggle_fullscreen(self):
        """Toggle fullscreen mode for the application window"""
        try:
            # Track fullscreen state
            if not hasattr(self, 'is_fullscreen'):
                self.is_fullscreen = False

            # Toggle state
            self.is_fullscreen = not self.is_fullscreen

            # Apply the change
            self.app.attributes("-fullscreen", self.is_fullscreen)

            # Update status
            status = "Fullscreen mode enabled" if self.is_fullscreen else "Fullscreen mode disabled"
            self.update_status(status)

        except Exception as e:
            logging.error(f"Error toggling fullscreen: {str(e)}")
            self.update_status(
                f"Failed to toggle fullscreen: {str(e)}", "error")

    def create_settings_general_tab(self, parent):
        """Create the general settings tab content"""
        # Main container
        container = ctk.CTkFrame(parent, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)

        # Interface settings section
        interface_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        interface_frame.pack(fill="x", pady=(0, 15))

        # Section title
        interface_title = ctk.CTkLabel(
            interface_frame,
            text="Interface Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        interface_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Language setting
        language_frame = ctk.CTkFrame(interface_frame, fg_color="transparent")
        language_frame.pack(fill="x", padx=15, pady=5)

        language_label = ctk.CTkLabel(
            language_frame,
            text="Interface Language",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        language_label.pack(side="left")

        self.language_var = ctk.StringVar(value="English")
        language_dropdown = ctk.CTkOptionMenu(
            language_frame,
            values=[
                "English",
                "Spanish",
                "French",
                "German",
                "Chinese",
                "Japanese"],
            variable=self.language_var,
            width=200)
        language_dropdown.pack(side="left", padx=10)

        # Startup settings section
        startup_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        startup_frame.pack(fill="x", pady=(0, 15))

        # Section title
        startup_title = ctk.CTkLabel(
            startup_frame,
            text="Startup Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        startup_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Auto-start setting
        autostart_frame = ctk.CTkFrame(startup_frame, fg_color="transparent")
        autostart_frame.pack(fill="x", padx=15, pady=5)

        autostart_label = ctk.CTkLabel(
            autostart_frame,
            text="Start with Windows",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        autostart_label.pack(side="left")

        self.autostart_var = ctk.BooleanVar(value=False)
        autostart_switch = ctk.CTkSwitch(
            autostart_frame,
            text="",
            variable=self.autostart_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        autostart_switch.pack(side="left", padx=10)

        # Start minimized setting
        minimized_frame = ctk.CTkFrame(startup_frame, fg_color="transparent")
        minimized_frame.pack(fill="x", padx=15, pady=5)

        minimized_label = ctk.CTkLabel(
            minimized_frame,
            text="Start Minimized",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        minimized_label.pack(side="left")

        self.minimized_var = ctk.BooleanVar(value=False)
        minimized_switch = ctk.CTkSwitch(
            minimized_frame,
            text="",
            variable=self.minimized_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        minimized_switch.pack(side="left", padx=10)

        # Auto-activate voice assistant
        autoactivate_frame = ctk.CTkFrame(
            startup_frame, fg_color="transparent")
        autoactivate_frame.pack(fill="x", padx=15, pady=5)

        autoactivate_label = ctk.CTkLabel(
            autoactivate_frame,
            text="Auto-activate Voice Assistant",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        autoactivate_label.pack(side="left")

        self.autoactivate_var = ctk.BooleanVar(value=False)
        autoactivate_switch = ctk.CTkSwitch(
            autoactivate_frame,
            text="",
            variable=self.autoactivate_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        autoactivate_switch.pack(side="left", padx=10)

        return container

    def create_settings_appearance_tab(self, parent):
        """Create the appearance settings tab content"""
        # Main container
        container = ctk.CTkFrame(parent, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)

        # Theme settings section
        theme_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        theme_frame.pack(fill="x", pady=(0, 15))

        # Section title
        theme_title = ctk.CTkLabel(
            theme_frame,
            text="Theme Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        theme_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Theme selection
        theme_selection_frame = ctk.CTkFrame(
            theme_frame, fg_color="transparent")
        theme_selection_frame.pack(fill="x", padx=15, pady=5)

        theme_label = ctk.CTkLabel(
            theme_selection_frame,
            text="Color Theme",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        theme_label.pack(side="left")

        self.theme_var = ctk.StringVar(value="medical")
        theme_dropdown = ctk.CTkOptionMenu(
            theme_selection_frame,
            values=["medical", "midnight", "cyberpunk"],
            variable=self.theme_var,
            width=200,
            command=self.apply_theme
        )
        theme_dropdown.pack(side="left", padx=10)

        # Appearance mode
        appearance_frame = ctk.CTkFrame(theme_frame, fg_color="transparent")
        appearance_frame.pack(fill="x", padx=15, pady=5)

        appearance_label = ctk.CTkLabel(
            appearance_frame,
            text="Appearance Mode",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        appearance_label.pack(side="left")

        self.appearance_var = ctk.StringVar(value="Dark")
        appearance_dropdown = ctk.CTkOptionMenu(
            appearance_frame,
            values=["Dark", "Light", "System"],
            variable=self.appearance_var,
            width=200,
            command=lambda value: ctk.set_appearance_mode(value)
        )
        appearance_dropdown.pack(side="left", padx=10)

        # Font settings section
        font_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        font_frame.pack(fill="x", pady=(0, 15))

        # Section title
        font_title = ctk.CTkLabel(
            font_frame,
            text="Font Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        font_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Font size
        font_size_frame = ctk.CTkFrame(font_frame, fg_color="transparent")
        font_size_frame.pack(fill="x", padx=15, pady=5)

        font_size_label = ctk.CTkLabel(
            font_size_frame,
            text="Font Size",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        font_size_label.pack(side="left")

        self.font_size_var = ctk.IntVar(value=12)
        font_size_slider = ctk.CTkSlider(
            font_size_frame,
            from_=8,
            to=16,
            number_of_steps=8,
            variable=self.font_size_var,
            width=200
        )
        font_size_slider.pack(side="left", padx=10)

        font_size_value = ctk.CTkLabel(
            font_size_frame,
            textvariable=self.font_size_var,
            width=30
        )
        font_size_value.pack(side="left", padx=5)

        # Preview section
        preview_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        preview_frame.pack(fill="x", pady=(0, 15))

        # Section title
        preview_title = ctk.CTkLabel(
            preview_frame,
            text="Theme Preview",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        preview_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Preview content
        preview_content = ctk.CTkFrame(
            preview_frame,
            fg_color=self.colors["bg_medium"],
            corner_radius=5,
            height=100
        )
        preview_content.pack(fill="x", padx=15, pady=(0, 15))
        preview_content.pack_propagate(False)

        preview_label = ctk.CTkLabel(
            preview_content,
            text="Sample Text",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"]
        )
        preview_label.pack(anchor="center", pady=10)

        preview_button = ctk.CTkButton(
            preview_content,
            text="Sample Button",
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            width=150
        )
        preview_button.pack(anchor="center")

        return container

    def create_settings_voice_tab(self, parent):
        """Create the voice settings tab content"""
        # Main container with gradient background
        container = ctk.CTkFrame(parent, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)

        # Microphone settings section
        mic_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        mic_frame.pack(fill="x", pady=(0, 15))

        # Section title
        mic_title = ctk.CTkLabel(
            mic_frame,
            text="Microphone Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        mic_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Microphone selection
        mic_selection_frame = ctk.CTkFrame(mic_frame, fg_color="transparent")
        mic_selection_frame.pack(fill="x", padx=15, pady=5)

        mic_label = ctk.CTkLabel(
            mic_selection_frame,
            text="Input Device",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        mic_label.pack(side="left")

        # Create a frame for the dropdown and refresh button
        mic_dropdown_frame = ctk.CTkFrame(
            mic_selection_frame, fg_color="transparent")
        mic_dropdown_frame.pack(side="left", fill="x", expand=True)

        # Microphone dropdown
        self.mic_var = ctk.StringVar(value="Default Microphone")
        self.mic_dropdown = ctk.CTkOptionMenu(
            mic_dropdown_frame,
            values=["Default Microphone"],
            variable=self.mic_var,
            width=200
        )
        self.mic_dropdown.pack(side="left", padx=(0, 10))

        # Refresh button
        refresh_button = ctk.CTkButton(
            mic_dropdown_frame,
            text="Refresh",
            command=self.refresh_mic_list,
            fg_color=self.colors["bg_medium"],
            hover_color=self.colors["bg_light"],
            width=80
        )
        refresh_button.pack(side="left")

        # Microphone level visualization
        level_frame = ctk.CTkFrame(mic_frame, fg_color="transparent")
        level_frame.pack(fill="x", padx=15, pady=5)

        level_label = ctk.CTkLabel(
            level_frame,
            text="Input Level",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        level_label.pack(side="left")

        # Level meter canvas
        self.level_canvas = ctk.CTkCanvas(
            level_frame,
            height=24,
            width=200,
            bg=self.colors["bg_dark"],
            highlightthickness=0
        )
        self.level_canvas.pack(side="left", padx=10)

        # Test microphone button
        test_button = ctk.CTkButton(
            level_frame,
            text="Test",
            command=self.test_microphone,
            fg_color=self.colors["accent_secondary"],
            hover_color=self.colors["accent_primary"],
            width=80
        )
        test_button.pack(side="left")

        # Advanced microphone settings
        advanced_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        advanced_frame.pack(fill="x", pady=(0, 15))

        # Section title
        advanced_title = ctk.CTkLabel(
            advanced_frame,
            text="Advanced Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        advanced_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Input gain
        gain_frame = ctk.CTkFrame(advanced_frame, fg_color="transparent")
        gain_frame.pack(fill="x", padx=15, pady=5)

        gain_label = ctk.CTkLabel(
            gain_frame,
            text="Input Gain",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        gain_label.pack(side="left")

        self.gain_var = ctk.DoubleVar(value=1.0)
        gain_slider = ctk.CTkSlider(
            gain_frame,
            from_=0.1,
            to=2.0,
            variable=self.gain_var,
            width=200
        )
        gain_slider.pack(side="left", padx=10)

        gain_value = ctk.CTkLabel(
            gain_frame,
            text=f"{self.gain_var.get():.1f}",
            width=30
        )
        gain_value.pack(side="left", padx=5)

        # Noise threshold
        threshold_frame = ctk.CTkFrame(advanced_frame, fg_color="transparent")
        threshold_frame.pack(fill="x", padx=15, pady=5)

        threshold_label = ctk.CTkLabel(
            threshold_frame,
            text="Noise Threshold",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        threshold_label.pack(side="left")

        self.threshold_var = ctk.DoubleVar(value=0.2)
        threshold_slider = ctk.CTkSlider(
            threshold_frame,
            from_=0.0,
            to=0.5,
            variable=self.threshold_var,
            width=200
        )
        threshold_slider.pack(side="left", padx=10)

        threshold_value = ctk.CTkLabel(
            threshold_frame,
            text=f"{self.threshold_var.get():.2f}",
            width=30
        )
        threshold_value.pack(side="left", padx=5)

        # Echo cancellation
        echo_frame = ctk.CTkFrame(advanced_frame, fg_color="transparent")
        echo_frame.pack(fill="x", padx=15, pady=5)

        echo_label = ctk.CTkLabel(
            echo_frame,
            text="Echo Cancellation",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        echo_label.pack(side="left")

        self.echo_var = ctk.BooleanVar(value=True)
        echo_switch = ctk.CTkSwitch(
            echo_frame,
            text="",
            variable=self.echo_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        echo_switch.pack(side="left", padx=10)

        # Noise reduction
        noise_frame = ctk.CTkFrame(advanced_frame, fg_color="transparent")
        noise_frame.pack(fill="x", padx=15, pady=5)

        noise_label = ctk.CTkLabel(
            noise_frame,
            text="Noise Reduction",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        noise_label.pack(side="left")

        self.noise_var = ctk.BooleanVar(value=True)
        noise_switch = ctk.CTkSwitch(
            noise_frame,
            text="",
            variable=self.noise_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        noise_switch.pack(side="left", padx=10)

        # Initialize microphone list
        self.refresh_mic_list()

        return container

    def refresh_mic_list(self):
        """Refresh the list of available microphones."""
        try:
            devices = sd.query_devices()
            input_devices = []

            # Add a default option
            input_devices.append("Default Microphone")

            # Add all input devices with their IDs for easier identification
            for i, device in enumerate(devices):
                if device['max_input_channels'] > 0:
                    input_devices.append(f"{device['name']} (ID: {i})")

            # Update dropdown
            self.mic_dropdown.configure(values=input_devices)

            # Set default selection
            if input_devices:
                self.mic_var.set(input_devices[0])

            # Update status
            self.update_status(f"Found {len(input_devices)-1} input devices")

        except Exception as e:
            logging.error(f"Error refreshing microphone list: {str(e)}")
            self.update_status("Failed to refresh microphone list", "error")
            # Ensure at least the default option is available
            self.mic_dropdown.configure(values=["Default Microphone"])
            self.mic_var.set("Default Microphone")

    def test_microphone(self):
        """Test the selected microphone by recording and playing back audio."""
        try:
            device_str = self.mic_var.get()
            device_id = None

            # Extract device ID if it's not the default microphone
            if device_str != "Default Microphone":
                try:
                    device_id = int(device_str.split("ID: ")[1].strip(")"))
                    logging.info(f"Testing microphone with ID: {device_id}")
                except Exception as e:
                    logging.error(f"Error parsing device ID: {str(e)}")
                    device_id = None
                    logging.info("Using default microphone instead")

            # Create a modern dialog to show recording status
            dialog = ctk.CTkToplevel(self.app)
            dialog.title("Microphone Test")
            dialog.geometry("400x300")
            dialog.resizable(False, False)
            dialog.transient(self.app)
            dialog.grab_set()

            # Set dialog theme
            dialog.configure(fg_color=self.colors["bg_medium"])

            # Center the dialog
            dialog.update_idletasks()
            width = dialog.winfo_width()
            height = dialog.winfo_height()
            x = (dialog.winfo_screenwidth() // 2) - (width // 2)
            y = (dialog.winfo_screenheight() // 2) - (height // 2)
            dialog.geometry(f"{width}x{height}+{x}+{y}")

            # Title with icon
            title_frame = ctk.CTkFrame(dialog, fg_color="transparent")
            title_frame.pack(fill="x", padx=20, pady=(20, 10))

            title_label = ctk.CTkLabel(
                title_frame,
                text="Microphone Test",
                font=ctk.CTkFont(size=20, weight="bold"),
                text_color=self.colors["text_bright"]
            )
            title_label.pack(side="left")

            # Status label with modern styling
            status_frame = ctk.CTkFrame(
                dialog, fg_color=self.colors["bg_light"], corner_radius=10)
            status_frame.pack(fill="x", padx=20, pady=10)

            status_label = ctk.CTkLabel(
                status_frame,
                text="Initializing microphone test...",
                font=ctk.CTkFont(size=14),
                text_color=self.colors["text_bright"],
                wraplength=350
            )
            status_label.pack(pady=15, padx=15)

            # Progress bar with custom styling
            progress_frame = ctk.CTkFrame(dialog, fg_color="transparent")
            progress_frame.pack(fill="x", padx=20, pady=5)

            progress_label = ctk.CTkLabel(
                progress_frame,
                text="Progress:",
                font=ctk.CTkFont(size=12),
                text_color=self.colors["text_normal"]
            )
            progress_label.pack(anchor="w")

            progress = ctk.CTkProgressBar(
                progress_frame,
                width=360,
                height=15,
                corner_radius=5,
                fg_color=self.colors["bg_dark"],
                progress_color=self.colors["accent_primary"]
            )
            progress.pack(pady=5)
            progress.set(0)

            # Level meter with improved visualization
            level_frame = ctk.CTkFrame(dialog, fg_color="transparent")
            level_frame.pack(fill="x", padx=20, pady=5)

            level_label = ctk.CTkLabel(
                level_frame,
                text="Audio Level:",
                font=ctk.CTkFont(size=12),
                text_color=self.colors["text_normal"]
            )
            level_label.pack(anchor="w")

            meter_bg = ctk.CTkFrame(
                level_frame,
                fg_color=self.colors["bg_dark"],
                height=30,
                width=360,
                corner_radius=5
            )
            meter_bg.pack(pady=5)

            level_indicator = ctk.CTkFrame(
                meter_bg,
                fg_color=self.colors["accent_primary"],
                height=30,
                width=1,
                corner_radius=5
            )
            level_indicator.place(x=0, y=0)

            level_text = ctk.CTkLabel(
                meter_bg,
                text="0%",
                font=ctk.CTkFont(size=12, weight="bold"),
                text_color=self.colors["text_bright"]
            )
            level_text.place(relx=0.5, rely=0.5, anchor="center")

            # Button frame
            button_frame = ctk.CTkFrame(dialog, fg_color="transparent")
            button_frame.pack(fill="x", padx=20, pady=(15, 20))

            # Cancel button
            cancel_button = ctk.CTkButton(
                button_frame,
                text="Cancel",
                command=dialog.destroy,
                fg_color=self.colors["bg_light"],
                hover_color=self.colors["bg_medium"],
                text_color=self.colors["text_normal"],
                width=100
            )
            cancel_button.pack(side="left", padx=(0, 10))

            # Close button (initially disabled)
            close_button = ctk.CTkButton(
                button_frame,
                text="Close",
                command=dialog.destroy,
                state="disabled",
                fg_color=self.colors["accent_primary"],
                hover_color=self.colors["accent_secondary"],
                width=100
            )
            close_button.pack(side="right")

            # Get device info
            try:
                device_info = sd.query_devices(device_id)
                samplerate = int(device_info['default_samplerate'])

                # Show device info in status
                status_label.configure(
                    text=f"Testing: {device_info['name']}\nPlease speak now to test your microphone.")
            except Exception as e:
                status_label.configure(
                    text=f"Error: {str(e)}\nCould not initialize the selected microphone.")
                close_button.configure(state="normal")
                return

            # Duration of recording
            duration = 5  # seconds

            # Function to update progress
            def update_progress(current, total):
                progress.set(current / total)
                progress_label.configure(
                    text=f"Progress: {int(current/total*100)}%")
                dialog.update()

            # Function to update level indicator
            def update_level(volume):
                # Scale volume (0-1) to width
                width = min(360, int(volume * 360))
                level_indicator.configure(width=width)

                # Update color based on level
                if volume < 0.3:
                    level_indicator.configure(
                        fg_color=self.colors["status_green"])
                elif volume < 0.7:
                    level_indicator.configure(
                        fg_color=self.colors["status_yellow"])
                else:
                    level_indicator.configure(
                        fg_color=self.colors["status_red"])

                # Update text
                level_text.configure(text=f"{int(volume * 100)}%")
                dialog.update()

            # Function to record audio
            def record_audio():
                status_label.configure(
                    text=f"Recording from: {device_info['name']}\nPlease speak now...")

                # Create array to store audio data
                audio_data = []

                # Start time
                start_time = time.time()

                # Callback function for audio stream
                def audio_callback(indata, frames, time_info, status):
                    if status:
                        logging.warning(f"Audio status: {status}")

                    # Copy audio data
                    audio_data.append(indata.copy())

                    # Calculate volume level (RMS)
                    volume = np.sqrt(np.mean(indata**2))

                    # Apply gain if available
                    if hasattr(self, 'gain_var'):
                        volume *= self.gain_var.get()

                    # Update level indicator
                    dialog.after(0, lambda: update_level(min(1.0, volume * 2)))

                    # Update progress
                    elapsed = time.time() - start_time
                    if elapsed < duration:
                        dialog.after(
                            0, lambda: update_progress(
                                elapsed, duration))

                # Start audio stream
                try:
                    with sd.InputStream(
                        device=device_id,
                        channels=1,
                        callback=audio_callback,
                        samplerate=samplerate,
                        blocksize=int(samplerate * 0.1)  # 100ms blocks
                    ):
                        # Wait for duration
                        sd.sleep(int(duration * 1000))
                except Exception as e:
                    error_msg = f"Error recording: {str(e)}"
                    logging.error(error_msg)
                    status_label.configure(text=error_msg)
                    close_button.configure(state="normal")
                    return None

                # Combine all audio chunks
                if audio_data:
                    return np.concatenate(audio_data)
                return None

            # Function to play audio
            def play_audio(audio_data):
                status_label.configure(text="Playing back recording...")
                progress.set(0)

                try:
                    # Start time
                    start_time = time.time()

                    # Play audio
                    sd.play(audio_data, samplerate)

                    # Update progress during playback
                    def update_playback_progress():
                        elapsed = time.time() - start_time
                        if elapsed < duration and not dialog.winfo_exists():
                            return

                        if elapsed < duration:
                            update_progress(elapsed, duration)
                            dialog.after(100, update_playback_progress)
                        else:
                            progress.set(1.0)
#!/usr/bin/env python3
"""
Dragon Voice GUI - Main application interface for Dragon Voice Project
"""

from whisper_integration import WhisperRecognizer
import os
import sys
import json
import time
import logging
import webbrowser
import threading
from datetime import datetime
from pathlib import Path

# GUI libraries
import tkinter as tk
from tkinter import messagebox
import customtkinter as ctk
from PIL import Image, ImageTk

# System monitoring
import psutil
import platform

# Window management
import pygetwindow as gw
import pyautogui
import sounddevice as sd
import numpy as np
import tempfile
import os
import time
import threading

# Custom components
from synthesizer_bar import SynthesizerBar

# Try to import soundfile, but don't fail if it's not available
try:
    import soundfile as sf
    SOUNDFILE_AVAILABLE = True
except ImportError:
    SOUNDFILE_AVAILABLE = False
    print("Warning: soundfile module not found. Some audio features will be limited.")

# Configure logging
logging.basicConfig(
    level=logging.WARNING,  # Changed from INFO to WARNING
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("dragon_gui.log"),
        logging.StreamHandler()
    ]
)

# Constants
DEFAULT_CONFIG_PATH = "src/config.json"
ASSETS_DIR = os.path.join("src", "assets")

# Add Whisper integration


class DragonVoiceGUI:
    """
    Main GUI class for the Dragon Voice Project

    Provides a modern, feature-rich interface for controlling the voice assistant,
    managing chatbots, and configuring system settings.
    """

    def __init__(self, config_path=DEFAULT_CONFIG_PATH):
        """Initialize the DragonVoice GUI application"""
        logging.info("Initializing DragonVoiceGUI")
        logging.info("Initializing DragonVoice GUI")

        try:
            # Initialize logging
            self.setup_logging()

            # Initialize state variables
            self.recording_active = False
            self.continuous_recording = False  # Flag for continuous recording
            self.is_fullscreen = False

            # Create main application window
            self.app = ctk.CTk()
            self.app.title("DragonVoice")
            self.app.geometry("1200x800")
            self.app.minsize(900, 600)
            
            # Center window on screen
            screen_width = self.app.winfo_screenwidth()
            screen_height = self.app.winfo_screenheight()
            x = (screen_width - 1200) // 2
            y = (screen_height - 800) // 2
            self.app.geometry(f"1200x800+{x}+{y}")

            # Load configuration
            self.config_path = config_path
            self.config = self.load_config()
            logging.info(f"Configuration loaded from {config_path}")

            # Set up theme and colors
            self.setup_theme()

            # Initialize Whisper recognizer
            self.init_whisper_recognizer()

            # Set up UI components
            self.setup_ui()

            # Start system monitoring
            self.start_system_monitoring()

        except Exception as e:
            logging.error(f"Error initializing DragonVoiceGUI: {str(e)}")
            raise

    def setup_logging(self):
        """Set up logging configuration"""
        # Check if logging is already configured
        if not logging.getLogger().handlers:
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - %(message)s'
            )
        logging.info("Logging setup complete")

    def setup_theme(self):
        """Set up the theme and colors for the application"""
        # Set appearance mode
        ctk.set_appearance_mode("dark")

        # Define color schemes
        self.color_schemes = {
            "dark": {
                "bg_dark": "#1A1A2E",
                "bg_medium": "#16213E",
                "bg_light": "#0F3460",
                "accent_primary": "#E94560",
                "accent_secondary": "#0F52BA",
                "text_bright": "#FFFFFF",
                "text_normal": "#E0E0E0",
                "text_dim": "#A0A0A0",
                "status_green": "#4CAF50",
                "status_yellow": "#FFC107",
                "status_red": "#F44336",
                "status_blue": "#2196F3",
                "status_gray": "#757575"
            },
            "light": {
                "bg_dark": "#F0F0F0",
                "bg_medium": "#E0E0E0",
                "bg_light": "#D0D0D0",
                "accent_primary": "#E94560",
                "accent_secondary": "#0F52BA",
                "text_bright": "#000000",
                "text_normal": "#202020",
                "text_dim": "#505050",
                "status_green": "#4CAF50",
                "status_yellow": "#FFC107",
                "status_red": "#F44336",
                "status_blue": "#2196F3",
                "status_gray": "#757575"
            },
            "dragon": {
                "bg_dark": "#0A1931",
                "bg_medium": "#150E56",
                "bg_light": "#1A1A40",
                "accent_primary": "#D82148",
                "accent_secondary": "#6EBF8B",
                "text_bright": "#FFFFFF",
                "text_normal": "#E0E0E0",
                "text_dim": "#A0A0A0",
                "status_green": "#4CAF50",
                "status_yellow": "#FFC107",
                "status_red": "#F44336",
                "status_blue": "#2196F3",
                "status_gray": "#757575"
            }
        }

        # Set default color scheme
        self.colors = self.color_schemes["dragon"]

        # Define fonts
        self.fonts = {
            "header": ctk.CTkFont(family="Segoe UI", size=28, weight="bold"),
            "title": ctk.CTkFont(family="Segoe UI", size=20, weight="bold"),
            "subtitle": ctk.CTkFont(family="Segoe UI", size=16, weight="bold"),
            "normal": ctk.CTkFont(family="Segoe UI", size=14),
            "small": ctk.CTkFont(family="Segoe UI", size=12),
            "tiny": ctk.CTkFont(family="Segoe UI", size=10),
            "mono": ctk.CTkFont(family="Consolas", size=12),
            # Added the 'large' font definition
            "large": ctk.CTkFont(family="Segoe UI", size=18)
        }

    def init_whisper_recognizer(self):
        """Initialize the Whisper recognizer"""
        try:
            # Initialize API keys with default values
            self.openai_api_key = "j3ydNXEmQFyDKwl5mWxSzcvdZcTLJw1t"
            self.base_url = "https://api.deepinfra.com/v1/openai"
            
            # Initialize WhisperRecognizer with error handling
            if self.openai_api_key:
                self.whisper_recognizer = WhisperRecognizer(
                    api_key=self.openai_api_key,
                    base_url=self.base_url
                )
                # Initialize recording state
                self.recording_active = False
                self.continuous_recording = False
                self.audio_data = []
                logging.info("WhisperRecognizer initialized successfully")
            else:
                logging.warning("No OpenAI API key found, WhisperRecognizer not initialized")
                self.whisper_recognizer = None
        except Exception as e:
            logging.error(f"Failed to initialize WhisperRecognizer: {str(e)}")
            self.whisper_recognizer = None

    def setup_ui(self):
        """Set up the main UI components"""
        try:
            # Create the main container
            self.main_container = ctk.CTkFrame(
                self.app, fg_color="transparent")
            self.main_container.pack(fill="both", expand=True)

            # Create UI components in the correct order
            self.create_footer()  # Create footer first to ensure status_label exists
            self.create_header()
            self.create_tabs()

            # Start system monitoring
            self.start_system_monitoring()

            # Update status
            self.update_status("Application initialized successfully")

            # Log successful UI setup
            logging.info("UI setup completed successfully")

        except Exception as e:
            logging.error(f"Error setting up UI: {str(e)}", exc_info=True)
            # Show error in a messagebox if possible
            try:
                import tkinter.messagebox as messagebox
                messagebox.showerror(
                    "UI Setup Error",
                    f"Error setting up UI:\n{str(e)}")
            except BaseException:
                pass

    def create_header(self):
        """Create a modern application header with logo and controls"""
        # Create header frame with gradient background
        self.header_frame = ctk.CTkFrame(
            self.main_container,
            fg_color=self.colors["bg_dark"],
            corner_radius=0,
            height=90
        )
        self.header_frame.pack(fill="x", pady=0)
        self.header_frame.pack_propagate(False)

        # Create gradient effect for header
        self.header_canvas = ctk.CTkCanvas(
            self.header_frame,
            bg=self.colors["bg_dark"],
            highlightthickness=0,
            height=90
        )
        self.header_canvas.pack(fill="x", side="top")

        # Draw gradient
        def draw_gradient():
            width = self.header_canvas.winfo_width()
            if width <= 1:  # Not yet properly initialized
                self.app.after(100, draw_gradient)
                return

            height = 90
            # Create a more sophisticated gradient
            for i in range(width):
                # Calculate gradient position (0 to 1)
                pos = i / width

                # Create a gradient with accent color highlights
                if pos < 0.2:  # First section - dark to medium with accent hint
                    ratio = pos / 0.2
                    r1, g1, b1 = self.hex_to_rgb(self.colors["bg_dark"])
                    r2, g2, b2 = self.hex_to_rgb(self.colors["bg_medium"])
                    r3, g3, b3 = self.hex_to_rgb(self.colors["accent_primary"])

                    # Mix colors with a hint of accent
                    r = r1 + (r2 - r1) * ratio + (r3 - r1) * ratio * 0.1
                    g = g1 + (g2 - g1) * ratio + (g3 - g1) * ratio * 0.1
                    b = b1 + (b2 - b1) * ratio + (b3 - b1) * ratio * 0.1
                elif pos < 0.8:  # Middle section - medium to medium with subtle variation
                    ratio = (pos - 0.2) / 0.6
                    r1, g1, b1 = self.hex_to_rgb(self.colors["bg_medium"])
                    r2, g2, b2 = self.hex_to_rgb(
                        self._adjust_color_brightness(
                            self.colors["bg_medium"], 1.1))

                    r = r1 + (r2 - r1) * ratio
                    g = g1 + (g2 - g1) * ratio
                    b = b1 + (b2 - b1) * ratio
                else:  # Last section - medium to dark with accent hint
                    ratio = (pos - 0.8) / 0.2
                    r1, g1, b1 = self.hex_to_rgb(self.colors["bg_medium"])
                    r2, g2, b2 = self.hex_to_rgb(self.colors["bg_dark"])
                    r3, g3, b3 = self.hex_to_rgb(
                        self.colors["accent_secondary"])

                    # Mix colors with a hint of accent
                    r = r1 + (r2 - r1) * ratio + (r3 - r1) * ratio * 0.1
                    g = g1 + (g2 - g1) * ratio + (g3 - g1) * ratio * 0.1
                    b = b1 + (b2 - b1) * ratio + (b3 - b1) * ratio * 0.1

                color = f'#{int(r):02x}{int(g):02x}{int(b):02x}'
                self.header_canvas.create_line(i, 0, i, height, fill=color)

            # Add accent line at bottom with glow effect
            for i in range(3):
                alpha = 0.3 + (0.7 * (i / 2))  # Increasing opacity
                glow_color = self._adjust_color_brightness(
                    self.colors["accent_primary"], alpha)
            self.header_canvas.create_line(
                0, height - 3 + i, width, height - 3 + i,
                fill=glow_color,
                width=1
            )

        # Schedule gradient drawing
        self.app.after(100, draw_gradient)

        # Create a container for the header content
        header_content = ctk.CTkFrame(
            self.header_frame, fg_color="transparent")
        header_content.place(
            relx=0.5,
            rely=0.5,
            anchor="center",
            relwidth=1,
            relheight=0.8)

        # Left side - Logo and title
        logo_frame = ctk.CTkFrame(header_content, fg_color="transparent")
        logo_frame.pack(side="left", padx=(30, 0))

        # Try to load logo image if available
        try:
            logo_path = os.path.join("src", "assets", "dragon_logo.png")
            if os.path.exists(logo_path):
                logo_image = ctk.CTkImage(
                    light_image=Image.open(logo_path),
                    dark_image=Image.open(logo_path),
                    size=(40, 40)
                )
                logo_label = ctk.CTkLabel(
                    logo_frame,
                    image=logo_image,
                    text=""
                )
                logo_label.pack(side="left", padx=(0, 15))
        except Exception as e:
            logging.error(f"Failed to load logo: {str(e)}")

        # App title with modern styling
        title_label = ctk.CTkLabel(
            logo_frame,
            text="DragonVoice",
            font=self.fonts["header"],
            text_color=self.colors["text_bright"]
        )
        title_label.pack(side="left")

        # Version with pill background
        version_pill = ctk.CTkFrame(
            logo_frame,
            fg_color=self.colors["accent_primary"],
            corner_radius=12,
            height=24
        )
        version_pill.pack(side="left", padx=(10, 0), pady=(8, 0))

        version_label = ctk.CTkLabel(
            version_pill,
            text="v2.0",
            font=self.fonts["small"],
            text_color=self.colors["text_bright"]
        )
        version_label.pack(padx=10, pady=2)

        # Center - Status indicator
        status_frame = ctk.CTkFrame(header_content, fg_color="transparent")
        status_frame.pack(side="left", expand=True)

        # Right side - Controls
        controls_frame = ctk.CTkFrame(header_content, fg_color="transparent")
        controls_frame.pack(side="right", padx=(0, 30))

        # Microphone selector with improved styling
        mic_frame = ctk.CTkFrame(
            controls_frame,
            fg_color=self.colors["bg_light"],
            corner_radius=8
        )
        mic_frame.pack(side="left", padx=(0, 15), pady=5)

        mic_label = ctk.CTkLabel(
            mic_frame,
            text="Microphone:",
            font=self.fonts["small"],
            text_color=self.colors["text_normal"]
        )
        mic_label.pack(side="left", padx=(10, 5), pady=5)

        # Microphone dropdown
        self.mic_var = ctk.StringVar(value="Default Microphone")
        self.mic_dropdown = ctk.CTkOptionMenu(
            mic_frame,
            values=["Default Microphone"],
            variable=self.mic_var,
            width=150,
            dynamic_resizing=True,
            fg_color=self.colors["bg_medium"],
            button_color=self.colors["accent_primary"],
            button_hover_color=self.colors["accent_secondary"],
            dropdown_fg_color=self.colors["bg_medium"]
        )
        self.mic_dropdown.pack(side="left", padx=(0, 10), pady=5)

        # Theme toggle button
        theme_button = ctk.CTkButton(
            controls_frame,
            text="",
            width=36,
            height=36,
            corner_radius=10,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            text_color=self.colors["text_bright"],
            command=self.toggle_theme
        )
        theme_button.pack(side="left", padx=(0, 10))

        # Settings button
        settings_button = ctk.CTkButton(
            controls_frame,
            text="Settings",
            width=100,
            height=36,
            corner_radius=10,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            text_color=self.colors["text_bright"],
            command=self.show_settings
        )
        settings_button.pack(side="left", padx=(0, 10))

        # Help button
        help_button = ctk.CTkButton(
            controls_frame,
            text="Help",
            width=80,
            height=36,
            corner_radius=10,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            text_color=self.colors["text_bright"],
            command=self.show_help
        )
        help_button.pack(side="left")

        # Refresh microphone list
        self.refresh_mic_list()

    def hex_to_rgb(self, hex_color):
        """Convert hex color to RGB tuple"""
        hex_color = hex_color.lstrip('#')
        return tuple(int(hex_color[i:i + 2], 16) for i in (0, 2, 4))

    def show_settings(self):
        """Show the settings dialog"""
        # Switch to the Configuration tab
        self.tab_view.set("Configuration")

    def show_help(self):
        """Show the help dialog"""
        # Create a new top-level window
        help_window = ctk.CTkToplevel(self.app)
        help_window.title("DragonVoice Help")
        help_window.geometry("800x600")
        help_window.minsize(800, 600)
        help_window.grab_set()  # Make window modal

        # Set window icon
        if platform.system() == "Windows":
            try:
                icon_path = os.path.join(
                    os.path.dirname(
                        os.path.abspath(__file__)),
                    "assets",
                    "dragon_icon.ico")
                if os.path.exists(icon_path):
                    help_window.iconbitmap(icon_path)
            except Exception as e:
                print(f"Could not set help window icon: {e}")

        # Create tab view for help content
        help_tabs = ctk.CTkTabview(
            help_window,
            fg_color=self.colors["bg_dark"],
            segmented_button_fg_color=self.colors["bg_medium"],
            segmented_button_selected_color=self.colors["accent_primary"],
            segmented_button_selected_hover_color=self.colors["accent_secondary"],
            segmented_button_unselected_color=self.colors["bg_medium"],
            segmented_button_unselected_hover_color=self.colors["bg_light"])
        help_tabs.pack(fill="both", expand=True, padx=20, pady=20)

        # Add tabs
        help_tabs.add("Getting Started")
        help_tabs.add("Voice Commands")
        help_tabs.add("Chatbots")
        help_tabs.add("Troubleshooting")
        help_tabs.add("About")

        # Create content for each tab
        self.create_help_getting_started(help_tabs.tab("Getting Started"))
        self.create_help_voice_commands(help_tabs.tab("Voice Commands"))
        self.create_help_chatbots(help_tabs.tab("Chatbots"))
        self.create_help_troubleshooting(help_tabs.tab("Troubleshooting"))
        self.create_help_about(help_tabs.tab("About"))

        # Add close button at bottom
        button_frame = ctk.CTkFrame(help_window, fg_color="transparent")
        button_frame.pack(fill="x", padx=20, pady=(0, 20))

        close_button = ctk.CTkButton(
            button_frame,
            text="Close",
            command=help_window.destroy,
            width=100,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        close_button.pack(side="right")

    def create_footer(self):
        """Create the footer with status information"""
        # Create footer container
        self.footer = ctk.CTkFrame(
            self.app,
            fg_color=self.colors["bg_dark"],
            height=30
        )
        self.footer.pack(fill="x", side="bottom")
        self.footer.pack_propagate(False)

        # Create canvas for gradient background
        footer_canvas = ctk.CTkCanvas(
            self.footer,
            bg=self.colors["bg_dark"],
            highlightthickness=0,
            height=30
        )
        footer_canvas.pack(fill="x")

        # Draw gradient
        def draw_gradient():
            width = footer_canvas.winfo_width()
            if width <= 1:  # Not properly rendered yet
                self.app.after(100, draw_gradient)
                return

            height = 30
            # Create gradient from dark to slightly lighter
            for i in range(height):
                # Calculate color based on position
                r, g, b = self.hex_to_rgb(self.colors["bg_dark"])
                factor = i / height * 0.2  # Subtle gradient
                r = min(255, int(r + (255 - r) * factor))
                g = min(255, int(g + (255 - g) * factor))
                b = min(255, int(b + (255 - b) * factor))
                color = f'#{r:02x}{g:02x}{b:02x}'

                # Draw line
                footer_canvas.create_line(0, i, width, i, fill=color)

        # Schedule gradient drawing after the window is rendered
        self.app.after(100, draw_gradient)

        # Status label
        self.status_label = ctk.CTkLabel(
            footer_canvas,
            text="Ready",
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        self.status_label.place(relx=0.01, rely=0.5, anchor="w")

        # Version label
        version_label = ctk.CTkLabel(
            footer_canvas,
            text="DragonVoice v2.0",
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        version_label.place(relx=0.99, rely=0.5, anchor="e")

        # Log successful creation
        logging.info(
            "Footer created successfully with status_label initialized")

    def create_tabs(self):
        """Create the main tab view and tabs"""
        # Create the main tab container
        self.tab_container = ctk.CTkFrame(self.app, fg_color="transparent")
        self.tab_container.pack(
            fill="both",
            expand=True,
            padx=20,
            pady=(
                0,
                20))

        # Create the tab view
        self.tab_view = ctk.CTkTabview(
            self.tab_container,
            fg_color=self.colors["bg_dark"],
            segmented_button_fg_color=self.colors["bg_medium"],
            segmented_button_selected_color=self.colors["accent_primary"],
            segmented_button_selected_hover_color=self.colors["accent_secondary"],
            segmented_button_unselected_color=self.colors["bg_medium"],
            segmented_button_unselected_hover_color=self.colors["bg_light"])
        self.tab_view.pack(fill="both", expand=True)

        # Add tabs
        self.tab_view.add("Dashboard")
        self.tab_view.add("Chatbots")
        self.tab_view.add("History")
        self.tab_view.add("Configuration")
        self.tab_view.add("About")

        # Set default tab
        self.tab_view.set("Dashboard")

        # Create tab contents
        self.create_dashboard_tab()
        self.create_chatbots_tab()
        self.create_history_tab()
        self.create_config_tab()
        self.create_about_tab()

    def create_dashboard_tab(self):
        """Create the dashboard tab content"""
        # Main container with gradient background
        dashboard_container = ctk.CTkScrollableFrame(
            self.tab_view.tab("Dashboard"),
            fg_color="transparent"
        )
        dashboard_container.pack(fill="both", expand=True, padx=20, pady=0)  # Reduced top padding

        # Create a grid layout for dashboard widgets
        dashboard_container.columnconfigure(0, weight=2)
        dashboard_container.columnconfigure(1, weight=1)
        dashboard_container.rowconfigure(0, weight=1)
        dashboard_container.rowconfigure(1, weight=1)
        dashboard_container.rowconfigure(2, weight=1)

        # Status panel (top left)
        status_panel = self.create_status_panel(dashboard_container)
        status_panel.grid(row=0, column=0, sticky="nsew", padx=(0, 10), pady=(0, 10))

        # Voice assistant control panel (top right)
        control_panel = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=15,
            border_width=1,
            border_color=self.colors["bg_light"]
        )
        control_panel.grid(row=0, column=1, sticky="nsew", padx=(10, 0), pady=(0, 10))

        # Control panel header with icon
        control_header = ctk.CTkFrame(control_panel, fg_color="transparent", height=50)
        control_header.pack(fill="x", padx=20, pady=(15, 5))

        # Control panel title with icon
        control_title = ctk.CTkLabel(
            control_header,
            text="Voice Assistant",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        control_title.pack(side="left")

        # Start/Stop button with improved styling
        self.toggle_button = ctk.CTkButton(
            control_panel,
            text="Start Voice Assistant",
            command=self.toggle_voice_assistant,
            fg_color=self.colors["status_green"],
            hover_color=self._adjust_color_brightness(self.colors["status_green"], 0.8),
            height=60,
            corner_radius=10,
            font=self.fonts["subtitle"],
            border_width=1,
            border_color=self._adjust_color_brightness(self.colors["status_green"], 1.2)
        )
        self.toggle_button.pack(fill="x", padx=20, pady=15)
        
        # Recording buttons container
        recording_buttons_frame = ctk.CTkFrame(control_panel, fg_color="transparent")
        recording_buttons_frame.pack(fill="x", padx=20, pady=10)

        # Record button
        self.record_button = ctk.CTkButton(
            recording_buttons_frame,
            text="Record",
            command=self.start_manual_recording,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            height=40,
            width=150,
            corner_radius=10
        )
        self.record_button.pack(side="left", fill="x", expand=True, padx=(0, 5))

        # Stop Recording button
        self.stop_record_button = ctk.CTkButton(
            recording_buttons_frame,
            text="Stop Recording",
            command=self.stop_manual_recording,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            height=40,
            width=150,
            corner_radius=10,
            state="disabled"
        )
        self.stop_record_button.pack(side="right", fill="x", expand=True, padx=(5, 0))

        # Add synthesizer bar to show voice detection
        self.synth_bar = SynthesizerBar(control_panel, self.colors, self.fonts)

        # Microphone sensitivity slider
        sensitivity_frame = ctk.CTkFrame(
            control_panel,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        sensitivity_frame.pack(fill="x", padx=20, pady=10)

        sensitivity_label = ctk.CTkLabel(
            sensitivity_frame,
            text="Microphone Sensitivity",
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"]
        )
        sensitivity_label.pack(anchor="w", padx=15, pady=(10, 5))

        sensitivity_control = ctk.CTkFrame(sensitivity_frame, fg_color="transparent")
        sensitivity_control.pack(fill="x", padx=15, pady=(0, 10))

        self.sensitivity_var = ctk.DoubleVar(value=0.5)
        self.sensitivity_slider = ctk.CTkSlider(
            sensitivity_control,
            from_=0.1,
            to=1.0,
            variable=self.sensitivity_var,
            width=200,
            progress_color=self.colors["accent_primary"],
            button_color=self.colors["accent_secondary"],
            button_hover_color=self.colors["accent_primary"]
        )
        self.sensitivity_slider.pack(side="left", fill="x", expand=True, padx=(0, 10))

        self.sensitivity_value = ctk.CTkLabel(
            sensitivity_control,
            text=f"{int(self.sensitivity_var.get() * 100)}%",
            font=self.fonts["small"],
            width=40,
            text_color=self.colors["text_dim"]
        )
        self.sensitivity_value.pack(side="right")

        # Update sensitivity value when slider changes
        def update_sensitivity(*args):
            self.sensitivity_value.configure(text=f"{int(self.sensitivity_var.get() * 100)}%")
            if hasattr(self, 'gain_var'):
                self.gain_var.set(self.sensitivity_var.get())

        self.sensitivity_var.trace_add("write", update_sensitivity)
        
        # Initialize gain variable for level meter
        self.gain_var = ctk.DoubleVar(value=self.sensitivity_var.get())

        # Status indicator with improved styling
        status_frame = ctk.CTkFrame(
            control_panel,
            fg_color=self.colors["bg_light"],
            corner_radius=10,
            height=50
        )
        status_frame.pack(fill="x", padx=20, pady=10)
        status_frame.pack_propagate(False)

        status_label = ctk.CTkLabel(
            status_frame,
            text="Status: Idle",
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"]
        )
        status_label.pack(side="left", padx=15, pady=10)

        self.status_indicator = ctk.CTkFrame(
            status_frame,
            fg_color=self.colors["status_gray"],
            width=20,
            height=20,
            corner_radius=10
        )
        self.status_indicator.pack(side="right", padx=15)

        # Transcription section (middle)
        transcription_frame = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=15,
            border_width=1,
            border_color=self.colors["bg_light"]
        )
        transcription_frame.grid(row=1, column=0, columnspan=2, sticky="nsew", pady=(0, 10))
            
        # Transcription header
        transcription_header = ctk.CTkFrame(transcription_frame, fg_color="transparent", height=50)
        transcription_header.pack(fill="x", padx=20, pady=(15, 5))
        
        transcription_title = ctk.CTkLabel(
            transcription_header,
            text="📝 Transcription",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        transcription_title.pack(side="left")
        
        # Controls frame
        controls = ctk.CTkFrame(transcription_header, fg_color="transparent")
        controls.pack(side="right")
        
        # Clear button
        clear_button = ctk.CTkButton(
            controls,
            text="Clear",
            command=lambda: self.clear_transcription(),
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            width=80
        )
        clear_button.pack(side="right", padx=(0, 10))
        
        # Enter button
        self.enter_button = ctk.CTkButton(
            controls,
            text="Enter",
            command=self.process_transcription,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            width=100,
            state="disabled"
        )
        self.enter_button.pack(side="right")
        
        # Transcription display
        self.transcription_display = ctk.CTkTextbox(
            transcription_frame,
            fg_color=self.colors["bg_light"],
            text_color=self.colors["text_bright"],
            font=self.fonts["large"],
            corner_radius=10,
            border_width=1,
            border_color=self.colors["bg_light"],
            height=150
        )
        self.transcription_display.pack(fill="both", expand=True, padx=20, pady=(5, 20))
        
        # Configure text tags
        self.transcription_display._textbox.tag_configure("timestamp", foreground=self.colors["accent_secondary"])
        self.transcription_display._textbox.tag_configure("transcription", foreground=self.colors["text_bright"])
        
        # Add initial message
        self.transcription_display.configure(state="normal")
        self.transcription_display.insert("end", "Transcribed text will appear here...")
        self.transcription_display.configure(state="disabled")

        # Voice commands section (bottom)
        text_display_frame = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=15,
            border_width=1,
            border_color=self.colors["bg_light"]
        )
        text_display_frame.grid(row=2, column=0, columnspan=2, sticky="nsew")
                
        # Text display header
        text_header = ctk.CTkFrame(text_display_frame, fg_color="transparent", height=50)
        text_header.pack(fill="x", padx=20, pady=(15, 5))
        
        text_title = ctk.CTkLabel(
            text_header,
            text="🔊 Voice Commands",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        text_title.pack(side="left")
        
        # Clear button for text display
        clear_text_button = ctk.CTkButton(
            text_header,
            text="Clear",
            command=lambda: self.clear_text_display(),
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            width=80
        )
        clear_text_button.pack(side="right")
        
        # Text display area
        self.text_display = ctk.CTkTextbox(
            text_display_frame,
            fg_color=self.colors["bg_light"],
            text_color=self.colors["text_bright"],
            font=self.fonts["large"],
            corner_radius=10,
            border_width=1,
            border_color=self.colors["bg_light"],
            height=200
        )
        self.text_display.pack(fill="both", expand=True, padx=20, pady=(5, 20))
        
        # Configure text tags
        self.text_display._textbox.tag_configure("timestamp", foreground=self.colors["accent_secondary"])
        self.text_display._textbox.tag_configure("command", foreground=self.colors["accent_primary"])
        self.text_display._textbox.tag_configure("system", foreground=self.colors["status_blue"])
        
        # Add initial message
        self.text_display.configure(state="normal")
        self.text_display.insert("end", "Voice commands will appear here after starting the voice assistant...")
        self.text_display.configure(state="disabled")

        # Initialize monitor visualization
        self.app.after(500, self.refresh_monitor_visualization)

    def create_synthesizer_bar(self, parent):
        """Create a synthesizer bar to visualize voice detection"""
        # Use the new SynthesizerBar class if available
        try:
            from synthesizer_bar import SynthesizerBar
            self.synth_bar = SynthesizerBar(parent, self.colors, self.fonts)
            return
        except ImportError:
            logging.warning(
                "SynthesizerBar class not found, using fallback implementation")

        # Fallback implementation
        synth_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10,
            height=80
        )
        synth_frame.pack(fill="x", padx=20, pady=10)

        # Synthesizer label
        synth_label = ctk.CTkLabel(
            synth_frame,
            text="Voice Detection",
            font=self.fonts["normal"],
            text_color=self.colors["text_bright"]
        )
        synth_label.pack(anchor="w", padx=15, pady=(10, 5))

        # Create level meter canvas
        self.level_canvas = ctk.CTkCanvas(
            synth_frame,
            bg=self.colors["bg_dark"],
            highlightthickness=0,
            height=30
        )
        self.level_canvas.pack(fill="x", padx=15, pady=(0, 10))

        # Initialize level meter with zero level
        self.app.after(100, lambda: self._update_level_meter(0))

    def create_chatbots_tab(self):
        """Create the chatbots tab content"""
        # Main container
        chatbots_container = ctk.CTkFrame(
            self.tab_view.tab("Chatbots"),
            fg_color="transparent"
        )
        chatbots_container.pack(fill="both", expand=True, padx=20, pady=20)

        # Title and add button row
        title_frame = ctk.CTkFrame(chatbots_container, fg_color="transparent")
        title_frame.pack(fill="x", pady=(0, 15))

        # Title with icon
        title_label = ctk.CTkLabel(
            title_frame,
            text="Chatbot Management",
            font=ctk.CTkFont(size=24, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title_label.pack(side="left")

        # Add chatbot button
        add_button = ctk.CTkButton(
            title_frame,
            text="Add New Chatbot",
            command=self.show_add_chatbot_dialog,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            width=120
        )
        add_button.pack(side="right")

        # Search frame
        search_frame = ctk.CTkFrame(
            chatbots_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=10,
            height=50
        )
        search_frame.pack(fill="x", pady=(0, 15))
        search_frame.pack_propagate(False)

        # Search icon
        search_icon = ctk.CTkLabel(
            search_frame,
            text="🔍",
            font=ctk.CTkFont(size=16),
            width=30
        )
        search_icon.pack(side="left", padx=(15, 0))

        # Search entry
        self.search_var = ctk.StringVar()
        self.search_var.trace_add(
            "write", lambda *args: self.filter_chatbot_list())
        search_entry = ctk.CTkEntry(
            search_frame,
            placeholder_text="Search chatbots...",
            textvariable=self.search_var,
            border_width=0,
            fg_color="transparent",
            height=40
        )
        search_entry.pack(side="left", fill="x", expand=True, padx=10)

        # Chatbot list container
        self.chatbot_list_frame = ctk.CTkScrollableFrame(
            chatbots_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        self.chatbot_list_frame.pack(fill="both", expand=True)

        # Refresh chatbot list
        self.refresh_chatbots()

    def create_about_tab(self):
        """Create the about tab content"""
        # Main container
        about_container = ctk.CTkFrame(
            self.tab_view.tab("About"),
            fg_color="transparent"
        )
        about_container.pack(fill="both", expand=True, padx=20, pady=20)

        # Create a scrollable frame for the about content
        about_scroll = ctk.CTkScrollableFrame(
            about_container,
            fg_color="transparent"
        )
        about_scroll.pack(fill="both", expand=True)

        # Logo and title
        logo_frame = ctk.CTkFrame(about_scroll, fg_color="transparent")
        logo_frame.pack(fill="x", pady=(0, 20))

        # App title
        title_label = ctk.CTkLabel(
            logo_frame,
            text="DragonVoice",
            font=ctk.CTkFont(size=32, weight="bold"),
            text_color=self.colors["accent_primary"]
        )
        title_label.pack(pady=(0, 5))

        # Version
        version_label = ctk.CTkLabel(
            logo_frame,
            text="Version 2.0",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"]
        )
        version_label.pack()

        # Description
        description_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        description_frame.pack(fill="x", pady=10, padx=5)

        description_label = ctk.CTkLabel(
            description_frame,
            text="DragonVoice is an advanced voice assistant that integrates with multiple AI chatbots.\n"
            "It provides a seamless voice interface for interacting with AI models and controlling your computer.",
            font=ctk.CTkFont(
                size=14),
            text_color=self.colors["text_normal"],
            wraplength=600,
            justify="left")
        description_label.pack(padx=20, pady=20)

        # Features
        features_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        features_frame.pack(fill="x", pady=10, padx=5)

        features_title = ctk.CTkLabel(
            features_frame,
            text="Key Features",
            font=ctk.CTkFont(size=18, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        features_title.pack(anchor="w", padx=20, pady=(15, 10))

        features = [
            "🎤 Voice recognition with OpenAI Whisper",
            "🤖 Multiple AI chatbot integrations",
            "⌨️ System control through voice commands",
            "📊 Real-time system monitoring",
            "🎨 Customizable themes and appearance",
            "🔧 Advanced configuration options"
        ]

        for feature in features:
            feature_label = ctk.CTkLabel(
                features_frame,
                text=feature,
                font=ctk.CTkFont(size=14),
                text_color=self.colors["text_normal"],
                anchor="w"
            )
            feature_label.pack(anchor="w", padx=20, pady=5)

        # Credits
        credits_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        credits_frame.pack(fill="x", pady=10, padx=5)

        credits_title = ctk.CTkLabel(
            credits_frame,
            text="Credits",
            font=ctk.CTkFont(size=18, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        credits_title.pack(anchor="w", padx=20, pady=(15, 10))

        credits_label = ctk.CTkLabel(
            credits_frame,
            text="Developed by: DragonVoice Team\n"
                 "UI Framework: CustomTkinter\n"
                 "Voice Recognition: OpenAI Whisper\n"
                 "Special thanks to all contributors and testers",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            justify="left"
        )
        credits_label.pack(anchor="w", padx=20, pady=(0, 15))

        # Links
        links_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        links_frame.pack(fill="x", pady=10, padx=5)

        links_title = ctk.CTkLabel(
            links_frame,
            text="Links",
            font=ctk.CTkFont(size=18, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        links_title.pack(anchor="w", padx=20, pady=(15, 10))

        # Function to open links
        def open_link(url):
            import webbrowser
            webbrowser.open(url)

        # Website link
        website_button = ctk.CTkButton(
            links_frame,
            text="Visit Website",
            command=lambda: open_link("https://dragonvoice.ai"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        website_button.pack(anchor="w", padx=20, pady=5)

        # Documentation link
        docs_button = ctk.CTkButton(
            links_frame,
            text="Documentation",
            command=lambda: open_link("https://docs.dragonvoice.ai"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        docs_button.pack(anchor="w", padx=20, pady=5)

        # GitHub link
        github_button = ctk.CTkButton(
            links_frame,
            text="GitHub Repository",
            command=lambda: open_link("https://github.com/dragonvoice/dragonvoice"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"])
        github_button.pack(anchor="w", padx=20, pady=(5, 15))

    def create_settings_advanced_tab(self, parent):
        """Create the advanced settings tab content"""
        # Main container
        container = ctk.CTkFrame(parent, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)

        # Logging settings section
        logging_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        logging_frame.pack(fill="x", pady=(0, 15))

        # Section title
        logging_title = ctk.CTkLabel(
            logging_frame,
            text="Logging Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        logging_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Log level
        log_level_frame = ctk.CTkFrame(logging_frame, fg_color="transparent")
        log_level_frame.pack(fill="x", padx=15, pady=5)

        log_level_label = ctk.CTkLabel(
            log_level_frame,
            text="Log Level",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        log_level_label.pack(side="left")

        self.log_level_var = ctk.StringVar(value="INFO")
        log_level_dropdown = ctk.CTkOptionMenu(
            log_level_frame,
            values=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
            variable=self.log_level_var,
            width=200
        )
        log_level_dropdown.pack(side="left", padx=10)

        # Enable file logging
        file_logging_frame = ctk.CTkFrame(
            logging_frame, fg_color="transparent")
        file_logging_frame.pack(fill="x", padx=15, pady=5)

        file_logging_label = ctk.CTkLabel(
            file_logging_frame,
            text="File Logging",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        file_logging_label.pack(side="left")

        self.file_logging_var = ctk.BooleanVar(value=True)
        file_logging_switch = ctk.CTkSwitch(
            file_logging_frame,
            text="",
            variable=self.file_logging_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        file_logging_switch.pack(side="left", padx=10)

        # Performance settings section
        performance_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        performance_frame.pack(fill="x", pady=(0, 15))

        # Section title
        performance_title = ctk.CTkLabel(
            performance_frame,
            text="Performance Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        performance_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Hardware acceleration
        hardware_frame = ctk.CTkFrame(
            performance_frame, fg_color="transparent")
        hardware_frame.pack(fill="x", padx=15, pady=5)

        hardware_label = ctk.CTkLabel(
            hardware_frame,
            text="Hardware Acceleration",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        hardware_label.pack(side="left")

        self.hardware_var = ctk.BooleanVar(value=True)
        hardware_switch = ctk.CTkSwitch(
            hardware_frame,
            text="",
            variable=self.hardware_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        hardware_switch.pack(side="left", padx=10)

        # Thread count
        thread_frame = ctk.CTkFrame(performance_frame, fg_color="transparent")
        thread_frame.pack(fill="x", padx=15, pady=5)

        thread_label = ctk.CTkLabel(
            thread_frame,
            text="Worker Threads",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        thread_label.pack(side="left")

        self.thread_var = ctk.IntVar(value=4)
        thread_slider = ctk.CTkSlider(
            thread_frame,
            from_=1,
            to=16,
            number_of_steps=15,
            variable=self.thread_var,
            width=200
        )
        thread_slider.pack(side="left", padx=10)

        thread_value = ctk.CTkLabel(
            thread_frame,
            textvariable=self.thread_var,
            width=30
        )
        thread_value.pack(side="left", padx=5)

        # Memory limit
        memory_frame = ctk.CTkFrame(performance_frame, fg_color="transparent")
        memory_frame.pack(fill="x", padx=15, pady=5)

        memory_label = ctk.CTkLabel(
            memory_frame,
            text="Memory Limit (MB)",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        memory_label.pack(side="left")

        self.memory_var = ctk.IntVar(value=1024)
        memory_slider = ctk.CTkSlider(
            memory_frame,
            from_=256,
            to=4096,
            number_of_steps=15,
            variable=self.memory_var,
            width=200
        )
        memory_slider.pack(side="left", padx=10)

        memory_value = ctk.CTkLabel(
            memory_frame,
            textvariable=self.memory_var,
            width=50
        )
        memory_value.pack(side="left", padx=5)

        # Reset button
        reset_button = ctk.CTkButton(
            container,
            text="Reset to Defaults",
            command=lambda: self.reset_advanced_settings(),
            fg_color=self.colors["bg_medium"],
            hover_color=self.colors["bg_light"],
            width=150
        )
        reset_button.pack(anchor="e", pady=10)

        return container

    def reset_advanced_settings(self):
        """Reset advanced settings to defaults"""
        self.log_level_var.set("INFO")
        self.file_logging_var.set(True)
        self.hardware_var.set(True)
        self.thread_var.set(4)
        self.memory_var.set(1024)
        self.update_status("Advanced settings reset to defaults")

    def apply_theme(self, theme_name):
        """Apply the selected theme"""
        if theme_name in self.color_schemes:
            self.colors = self.color_schemes[theme_name]
            self.config["theme"] = theme_name
            self.save_configuration(show_notification=False)
            # Refresh UI with new theme
            self.setup_theme()
            self.refresh_ui()

    def show_add_chatbot_dialog(self):
        """Show dialog to add a new chatbot"""
        dialog = ctk.CTkToplevel(self.app)
        dialog.title("Add New Chatbot")
        dialog.geometry("400x500")
        dialog.transient(self.app)
        dialog.grab_set()

        # Create form fields
        name_label = ctk.CTkLabel(
            dialog,
            text="Chatbot Name",
            text_color=self.colors["text_bright"]
        )
        name_label.pack(anchor="w", padx=20, pady=(20, 0))

        name_entry = ctk.CTkEntry(dialog, width=360)
        name_entry.pack(anchor="w", padx=20, pady=(0, 10))

        type_label = ctk.CTkLabel(
            dialog,
            text="Chatbot Type",
            text_color=self.colors["text_bright"]
        )
        type_label.pack(anchor="w", padx=20, pady=(10, 0))

        type_var = ctk.StringVar(value="GPT")
        type_dropdown = ctk.CTkOptionMenu(
            dialog,
            values=["GPT", "Claude", "Gemini", "Custom"],
            variable=type_var,
            width=360
        )
        type_dropdown.pack(anchor="w", padx=20, pady=(0, 10))

        api_key_label = ctk.CTkLabel(
            dialog,
            text="API Key",
            text_color=self.colors["text_bright"]
        )
        api_key_label.pack(anchor="w", padx=20, pady=(10, 0))

        api_key_entry = ctk.CTkEntry(dialog, width=360, show="*")
        api_key_entry.pack(anchor="w", padx=20, pady=(0, 10))

        # Add chatbot button
        def add_chatbot():
            name = name_entry.get()
            chatbot_type = type_var.get()
            api_key = api_key_entry.get()

            if name and chatbot_type and api_key:
                # Add to config
                if "chatbots" not in self.config:
                    self.config["chatbots"] = {}

                self.config["chatbots"][name] = {
                    "type": chatbot_type,
                    "api_key": api_key,
                    "status": "Ready",
                    "color": self.colors["accent_primary"],
                    "icon": "🤖"
                }

                self.save_configuration()
                self.refresh_chatbot_list()
                dialog.destroy()
            else:
                # Show error
                error_label.configure(text="Please fill in all fields")

        add_button = ctk.CTkButton(
            dialog,
            text="Add Chatbot",
            command=add_chatbot,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        add_button.pack(anchor="center", pady=20)

        # Error label
        error_label = ctk.CTkLabel(
            dialog,
            text="",
            text_color=self.colors["error"]
        )
        error_label.pack(anchor="center")

    def refresh_chatbot_list(self):
        """Refresh the list of chatbots in settings"""
        # Clear existing items
        for widget in self.chatbot_list_frame.winfo_children():
            widget.destroy()

        # Add header
        header = ctk.CTkFrame(
            self.chatbot_list_frame,
            fg_color="transparent"
        )
        header.pack(fill="x", padx=15, pady=5)

        ctk.CTkLabel(
            header,
            text="Name",
            font=ctk.CTkFont(weight="bold"),
            text_color=self.colors["text_bright"],
            width=100
        ).pack(side="left")

        ctk.CTkLabel(
            header,
            text="Type",
            font=ctk.CTkFont(weight="bold"),
            text_color=self.colors["text_bright"],
            width=100
        ).pack(side="left")

        ctk.CTkLabel(
            header,
            text="Status",
            font=ctk.CTkFont(weight="bold"),
            text_color=self.colors["text_bright"],
            width=100
        ).pack(side="left")

        # Add chatbots
        for name, config in self.config.get("chatbots", {}).items():
            self.add_chatbot_list_item(name, config)

    def add_chatbot_list_item(self, name, config):
        """Add a single chatbot item to the list"""
        # Create item frame with hover effect
        item = ctk.CTkFrame(
            self.chatbot_list_frame,
            fg_color=self.colors["bg_dark"],
            corner_radius=10,
            height=70
        )
        item.pack(fill="x", padx=5, pady=5)
        item.pack_propagate(False)

        # Add hover effect
        def on_enter(e):
            item.configure(fg_color=self.colors["bg_light"])

        def on_leave(e):
            item.configure(fg_color=self.colors["bg_dark"])

        item.bind("<Enter>", on_enter)
        item.bind("<Leave>", on_leave)

        # Icon and name container
        info_frame = ctk.CTkFrame(
            item,
            fg_color="transparent"
        )
        info_frame.pack(side="left", fill="y", padx=10)

        # Icon with colored background
        icon_frame = ctk.CTkFrame(
            info_frame,
            fg_color=config.get("color", self.colors["accent_primary"]),
            width=40,
            height=40,
            corner_radius=20
        )
        icon_frame.pack(side="left", padx=(0, 10))
        icon_frame.pack_propagate(False)

        icon_label = ctk.CTkLabel(
            icon_frame,
            text=config.get("icon", "🤖"),
            font=ctk.CTkFont(size=20)
        )
        icon_label.place(relx=0.5, rely=0.5, anchor="center")

        # Name and type
        text_frame = ctk.CTkFrame(
            info_frame,
            fg_color="transparent"
        )
        text_frame.pack(side="left", fill="y")

        name_label = ctk.CTkLabel(
            text_frame,
            text=name,
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        name_label.pack(anchor="w")

        type_label = ctk.CTkLabel(
            text_frame,
            text=config.get("type", "Unknown"),
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        type_label.pack(anchor="w")

        # Status indicator
        status_color = self.colors["status_green"] if config.get(
            "status") == "Ready" else self.colors["status_red"]
        status_frame = ctk.CTkFrame(
            item,
            fg_color="transparent"
        )
        status_frame.pack(side="right", fill="y", padx=10)

        status_dot = ctk.CTkLabel(
            status_frame,
            text="●",
            font=ctk.CTkFont(size=20),
            text_color=status_color
        )
        status_dot.pack(side="right", padx=5)

        status_label = ctk.CTkLabel(
            status_frame,
            text=config.get("status", "Unknown"),
            font=ctk.CTkFont(size=12),
            text_color=status_color
        )
        status_label.pack(side="right")

        # Make the entire item clickable
        item.bind(
            "<Button-1>",
            lambda e: self.show_chatbot_settings(
                name,
                config))

    def delete_chatbot(self, name):
        """Delete a chatbot from the configuration"""
        if name in self.config.get("chatbots", {}):
            del self.config["chatbots"][name]
            self.save_configuration()
            self.refresh_chatbot_list()
            # Also refresh the dashboard
            self.add_sample_chatbot_cards()

    def run(self):
        """Run the application main loop"""
        try:
            # Log startup
            logging.info("Starting DragonVoice application")

            # Update status
            self.update_status("Application started successfully")

            # Start the main event loop
            self.app.mainloop()

        except Exception as e:
            logging.error(f"Error in main loop: {str(e)}")
            raise

    def create_help_getting_started(self, parent):
        """Create the getting started help content"""
        # Welcome section
        welcome_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
#!/usr/bin/env python3
"""
Dragon Voice GUI - Main application interface for Dragon Voice Project
"""

from whisper_integration import WhisperRecognizer
import os
import sys
import json
import time
import logging
import webbrowser
import threading
from datetime import datetime
from pathlib import Path

# GUI libraries
import tkinter as tk
from tkinter import messagebox
import customtkinter as ctk
from PIL import Image, ImageTk

# System monitoring
import psutil
import platform

# Window management
import pygetwindow as gw
import pyautogui
import sounddevice as sd
import numpy as np
import tempfile
import os
import time
import threading

# Custom components
from synthesizer_bar import SynthesizerBar

# Try to import soundfile, but don't fail if it's not available
try:
    import soundfile as sf
    SOUNDFILE_AVAILABLE = True
except ImportError:
    SOUNDFILE_AVAILABLE = False
    print("Warning: soundfile module not found. Some audio features will be limited.")

# Configure logging
logging.basicConfig(
    level=logging.WARNING,  # Changed from INFO to WARNING
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("dragon_gui.log"),
        logging.StreamHandler()
    ]
)

# Constants
DEFAULT_CONFIG_PATH = "src/config.json"
ASSETS_DIR = os.path.join("src", "assets")

# Add Whisper integration


class DragonVoiceGUI:
    """
    Main GUI class for the Dragon Voice Project

    Provides a modern, feature-rich interface for controlling the voice assistant,
    managing chatbots, and configuring system settings.
    """

    def __init__(self, config_path=DEFAULT_CONFIG_PATH):
        """Initialize the DragonVoice GUI application"""
        logging.info("Initializing DragonVoiceGUI")
        logging.info("Initializing DragonVoice GUI")

        try:
            # Initialize logging
            self.setup_logging()

            # Initialize state variables
            self.recording_active = False
            self.continuous_recording = False  # Flag for continuous recording
            self.is_fullscreen = False

            # Create main application window
            self.app = ctk.CTk()
            self.app.title("DragonVoice")
            self.app.geometry("1200x800")
            self.app.minsize(900, 600)
            
            # Center window on screen
            screen_width = self.app.winfo_screenwidth()
            screen_height = self.app.winfo_screenheight()
            x = (screen_width - 1200) // 2
            y = (screen_height - 800) // 2
            self.app.geometry(f"1200x800+{x}+{y}")

            # Load configuration
            self.config_path = config_path
            self.config = self.load_config()
            logging.info(f"Configuration loaded from {config_path}")

            # Set up theme and colors
            self.setup_theme()

            # Initialize Whisper recognizer
            self.init_whisper_recognizer()

            # Set up UI components
            self.setup_ui()

            # Start system monitoring
            self.start_system_monitoring()

        except Exception as e:
            logging.error(f"Error initializing DragonVoiceGUI: {str(e)}")
            raise

    def setup_logging(self):
        """Set up logging configuration"""
        # Check if logging is already configured
        if not logging.getLogger().handlers:
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - %(message)s'
            )
        logging.info("Logging setup complete")

    def setup_theme(self):
        """Set up the theme and colors for the application"""
        # Set appearance mode
        ctk.set_appearance_mode("dark")

        # Define color schemes
        self.color_schemes = {
            "dark": {
                "bg_dark": "#1A1A2E",
                "bg_medium": "#16213E",
                "bg_light": "#0F3460",
                "accent_primary": "#E94560",
                "accent_secondary": "#0F52BA",
                "text_bright": "#FFFFFF",
                "text_normal": "#E0E0E0",
                "text_dim": "#A0A0A0",
                "status_green": "#4CAF50",
                "status_yellow": "#FFC107",
                "status_red": "#F44336",
                "status_blue": "#2196F3",
                "status_gray": "#757575"
            },
            "light": {
                "bg_dark": "#F0F0F0",
                "bg_medium": "#E0E0E0",
                "bg_light": "#D0D0D0",
                "accent_primary": "#E94560",
                "accent_secondary": "#0F52BA",
                "text_bright": "#000000",
                "text_normal": "#202020",
                "text_dim": "#505050",
                "status_green": "#4CAF50",
                "status_yellow": "#FFC107",
                "status_red": "#F44336",
                "status_blue": "#2196F3",
                "status_gray": "#757575"
            },
            "dragon": {
                "bg_dark": "#0A1931",
                "bg_medium": "#150E56",
                "bg_light": "#1A1A40",
                "accent_primary": "#D82148",
                "accent_secondary": "#6EBF8B",
                "text_bright": "#FFFFFF",
                "text_normal": "#E0E0E0",
                "text_dim": "#A0A0A0",
                "status_green": "#4CAF50",
                "status_yellow": "#FFC107",
                "status_red": "#F44336",
                "status_blue": "#2196F3",
                "status_gray": "#757575"
            }
        }

        # Set default color scheme
        self.colors = self.color_schemes["dragon"]

        # Define fonts
        self.fonts = {
            "header": ctk.CTkFont(family="Segoe UI", size=28, weight="bold"),
            "title": ctk.CTkFont(family="Segoe UI", size=20, weight="bold"),
            "subtitle": ctk.CTkFont(family="Segoe UI", size=16, weight="bold"),
            "normal": ctk.CTkFont(family="Segoe UI", size=14),
            "small": ctk.CTkFont(family="Segoe UI", size=12),
            "tiny": ctk.CTkFont(family="Segoe UI", size=10),
            "mono": ctk.CTkFont(family="Consolas", size=12),
            # Added the 'large' font definition
            "large": ctk.CTkFont(family="Segoe UI", size=18)
        }

    def init_whisper_recognizer(self):
        """Initialize the Whisper recognizer"""
        try:
            # Initialize API keys with default values
            self.openai_api_key = "j3ydNXEmQFyDKwl5mWxSzcvdZcTLJw1t"
            self.base_url = "https://api.deepinfra.com/v1/openai"
            
            # Initialize WhisperRecognizer with error handling
            if self.openai_api_key:
                self.whisper_recognizer = WhisperRecognizer(
                    api_key=self.openai_api_key,
                    base_url=self.base_url
                )
                # Initialize recording state
                self.recording_active = False
                self.continuous_recording = False
                self.audio_data = []
                logging.info("WhisperRecognizer initialized successfully")
            else:
                logging.warning("No OpenAI API key found, WhisperRecognizer not initialized")
                self.whisper_recognizer = None
        except Exception as e:
            logging.error(f"Failed to initialize WhisperRecognizer: {str(e)}")
            self.whisper_recognizer = None

    def setup_ui(self):
        """Set up the main UI components"""
        try:
            # Create the main container
            self.main_container = ctk.CTkFrame(
                self.app, fg_color="transparent")
            self.main_container.pack(fill="both", expand=True)

            # Create UI components in the correct order
            self.create_footer()  # Create footer first to ensure status_label exists
            self.create_header()
            self.create_tabs()

            # Start system monitoring
            self.start_system_monitoring()

            # Update status
            self.update_status("Application initialized successfully")

            # Log successful UI setup
            logging.info("UI setup completed successfully")

        except Exception as e:
            logging.error(f"Error setting up UI: {str(e)}", exc_info=True)
            # Show error in a messagebox if possible
            try:
                import tkinter.messagebox as messagebox
                messagebox.showerror(
                    "UI Setup Error",
                    f"Error setting up UI:\n{str(e)}")
            except BaseException:
                pass

    def create_header(self):
        """Create a modern application header with logo and controls"""
        # Create header frame with gradient background
        self.header_frame = ctk.CTkFrame(
            self.main_container,
            fg_color=self.colors["bg_dark"],
            corner_radius=0,
            height=90
        )
        self.header_frame.pack(fill="x", pady=0)
        self.header_frame.pack_propagate(False)

        # Create gradient effect for header
        self.header_canvas = ctk.CTkCanvas(
            self.header_frame,
            bg=self.colors["bg_dark"],
            highlightthickness=0,
            height=90
        )
        self.header_canvas.pack(fill="x", side="top")

        # Draw gradient
        def draw_gradient():
            width = self.header_canvas.winfo_width()
            if width <= 1:  # Not yet properly initialized
                self.app.after(100, draw_gradient)
                return

            height = 90
            # Create a more sophisticated gradient
            for i in range(width):
                # Calculate gradient position (0 to 1)
                pos = i / width

                # Create a gradient with accent color highlights
                if pos < 0.2:  # First section - dark to medium with accent hint
                    ratio = pos / 0.2
                    r1, g1, b1 = self.hex_to_rgb(self.colors["bg_dark"])
                    r2, g2, b2 = self.hex_to_rgb(self.colors["bg_medium"])
                    r3, g3, b3 = self.hex_to_rgb(self.colors["accent_primary"])

                    # Mix colors with a hint of accent
                    r = r1 + (r2 - r1) * ratio + (r3 - r1) * ratio * 0.1
                    g = g1 + (g2 - g1) * ratio + (g3 - g1) * ratio * 0.1
                    b = b1 + (b2 - b1) * ratio + (b3 - b1) * ratio * 0.1
                elif pos < 0.8:  # Middle section - medium to medium with subtle variation
                    ratio = (pos - 0.2) / 0.6
                    r1, g1, b1 = self.hex_to_rgb(self.colors["bg_medium"])
                    r2, g2, b2 = self.hex_to_rgb(
                        self._adjust_color_brightness(
                            self.colors["bg_medium"], 1.1))

                    r = r1 + (r2 - r1) * ratio
                    g = g1 + (g2 - g1) * ratio
                    b = b1 + (b2 - b1) * ratio
                else:  # Last section - medium to dark with accent hint
                    ratio = (pos - 0.8) / 0.2
                    r1, g1, b1 = self.hex_to_rgb(self.colors["bg_medium"])
                    r2, g2, b2 = self.hex_to_rgb(self.colors["bg_dark"])
                    r3, g3, b3 = self.hex_to_rgb(
                        self.colors["accent_secondary"])

                    # Mix colors with a hint of accent
                    r = r1 + (r2 - r1) * ratio + (r3 - r1) * ratio * 0.1
                    g = g1 + (g2 - g1) * ratio + (g3 - g1) * ratio * 0.1
                    b = b1 + (b2 - b1) * ratio + (b3 - b1) * ratio * 0.1

                color = f'#{int(r):02x}{int(g):02x}{int(b):02x}'
                self.header_canvas.create_line(i, 0, i, height, fill=color)

            # Add accent line at bottom with glow effect
            for i in range(3):
                alpha = 0.3 + (0.7 * (i / 2))  # Increasing opacity
                glow_color = self._adjust_color_brightness(
                    self.colors["accent_primary"], alpha)
            self.header_canvas.create_line(
                0, height - 3 + i, width, height - 3 + i,
                fill=glow_color,
                width=1
            )

        # Schedule gradient drawing
        self.app.after(100, draw_gradient)

        # Create a container for the header content
        header_content = ctk.CTkFrame(
            self.header_frame, fg_color="transparent")
        header_content.place(
            relx=0.5,
            rely=0.5,
            anchor="center",
            relwidth=1,
            relheight=0.8)

        # Left side - Logo and title
        logo_frame = ctk.CTkFrame(header_content, fg_color="transparent")
        logo_frame.pack(side="left", padx=(30, 0))

        # Try to load logo image if available
        try:
            logo_path = os.path.join("src", "assets", "dragon_logo.png")
            if os.path.exists(logo_path):
                logo_image = ctk.CTkImage(
                    light_image=Image.open(logo_path),
                    dark_image=Image.open(logo_path),
                    size=(40, 40)
                )
                logo_label = ctk.CTkLabel(
                    logo_frame,
                    image=logo_image,
                    text=""
                )
                logo_label.pack(side="left", padx=(0, 15))
        except Exception as e:
            logging.error(f"Failed to load logo: {str(e)}")

        # App title with modern styling
        title_label = ctk.CTkLabel(
            logo_frame,
            text="DragonVoice",
            font=self.fonts["header"],
            text_color=self.colors["text_bright"]
        )
        title_label.pack(side="left")

        # Version with pill background
        version_pill = ctk.CTkFrame(
            logo_frame,
            fg_color=self.colors["accent_primary"],
            corner_radius=12,
            height=24
        )
        version_pill.pack(side="left", padx=(10, 0), pady=(8, 0))

        version_label = ctk.CTkLabel(
            version_pill,
            text="v2.0",
            font=self.fonts["small"],
            text_color=self.colors["text_bright"]
        )
        version_label.pack(padx=10, pady=2)

        # Center - Status indicator
        status_frame = ctk.CTkFrame(header_content, fg_color="transparent")
        status_frame.pack(side="left", expand=True)

        # Right side - Controls
        controls_frame = ctk.CTkFrame(header_content, fg_color="transparent")
        controls_frame.pack(side="right", padx=(0, 30))

        # Microphone selector with improved styling
        mic_frame = ctk.CTkFrame(
            controls_frame,
            fg_color=self.colors["bg_light"],
            corner_radius=8
        )
        mic_frame.pack(side="left", padx=(0, 15), pady=5)

        mic_label = ctk.CTkLabel(
            mic_frame,
            text="Microphone:",
            font=self.fonts["small"],
            text_color=self.colors["text_normal"]
        )
        mic_label.pack(side="left", padx=(10, 5), pady=5)

        # Microphone dropdown
        self.mic_var = ctk.StringVar(value="Default Microphone")
        self.mic_dropdown = ctk.CTkOptionMenu(
            mic_frame,
            values=["Default Microphone"],
            variable=self.mic_var,
            width=150,
            dynamic_resizing=True,
            fg_color=self.colors["bg_medium"],
            button_color=self.colors["accent_primary"],
            button_hover_color=self.colors["accent_secondary"],
            dropdown_fg_color=self.colors["bg_medium"]
        )
        self.mic_dropdown.pack(side="left", padx=(0, 10), pady=5)

        # Theme toggle button
        theme_button = ctk.CTkButton(
            controls_frame,
            text="",
            width=36,
            height=36,
            corner_radius=10,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            text_color=self.colors["text_bright"],
            command=self.toggle_theme
        )
        theme_button.pack(side="left", padx=(0, 10))

        # Settings button
        settings_button = ctk.CTkButton(
            controls_frame,
            text="Settings",
            width=100,
            height=36,
            corner_radius=10,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            text_color=self.colors["text_bright"],
            command=self.show_settings
        )
        settings_button.pack(side="left", padx=(0, 10))

        # Help button
        help_button = ctk.CTkButton(
            controls_frame,
            text="Help",
            width=80,
            height=36,
            corner_radius=10,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            text_color=self.colors["text_bright"],
            command=self.show_help
        )
        help_button.pack(side="left")

        # Refresh microphone list
        self.refresh_mic_list()

    def hex_to_rgb(self, hex_color):
        """Convert hex color to RGB tuple"""
        hex_color = hex_color.lstrip('#')
        return tuple(int(hex_color[i:i + 2], 16) for i in (0, 2, 4))

    def show_settings(self):
        """Show the settings dialog"""
        # Switch to the Configuration tab
        self.tab_view.set("Configuration")

    def show_help(self):
        """Show the help dialog"""
        # Create a new top-level window
        help_window = ctk.CTkToplevel(self.app)
        help_window.title("DragonVoice Help")
        help_window.geometry("800x600")
        help_window.minsize(800, 600)
        help_window.grab_set()  # Make window modal

        # Set window icon
        if platform.system() == "Windows":
            try:
                icon_path = os.path.join(
                    os.path.dirname(
                        os.path.abspath(__file__)),
                    "assets",
                    "dragon_icon.ico")
                if os.path.exists(icon_path):
                    help_window.iconbitmap(icon_path)
            except Exception as e:
                print(f"Could not set help window icon: {e}")

        # Create tab view for help content
        help_tabs = ctk.CTkTabview(
            help_window,
            fg_color=self.colors["bg_dark"],
            segmented_button_fg_color=self.colors["bg_medium"],
            segmented_button_selected_color=self.colors["accent_primary"],
            segmented_button_selected_hover_color=self.colors["accent_secondary"],
            segmented_button_unselected_color=self.colors["bg_medium"],
            segmented_button_unselected_hover_color=self.colors["bg_light"])
        help_tabs.pack(fill="both", expand=True, padx=20, pady=20)

        # Add tabs
        help_tabs.add("Getting Started")
        help_tabs.add("Voice Commands")
        help_tabs.add("Chatbots")
        help_tabs.add("Troubleshooting")
        help_tabs.add("About")

        # Create content for each tab
        self.create_help_getting_started(help_tabs.tab("Getting Started"))
        self.create_help_voice_commands(help_tabs.tab("Voice Commands"))
        self.create_help_chatbots(help_tabs.tab("Chatbots"))
        self.create_help_troubleshooting(help_tabs.tab("Troubleshooting"))
        self.create_help_about(help_tabs.tab("About"))

        # Add close button at bottom
        button_frame = ctk.CTkFrame(help_window, fg_color="transparent")
        button_frame.pack(fill="x", padx=20, pady=(0, 20))

        close_button = ctk.CTkButton(
            button_frame,
            text="Close",
            command=help_window.destroy,
            width=100,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        close_button.pack(side="right")

    def create_footer(self):
        """Create the footer with status information"""
        # Create footer container
        self.footer = ctk.CTkFrame(
            self.app,
            fg_color=self.colors["bg_dark"],
            height=30
        )
        self.footer.pack(fill="x", side="bottom")
        self.footer.pack_propagate(False)

        # Create canvas for gradient background
        footer_canvas = ctk.CTkCanvas(
            self.footer,
            bg=self.colors["bg_dark"],
            highlightthickness=0,
            height=30
        )
        footer_canvas.pack(fill="x")

        # Draw gradient
        def draw_gradient():
            width = footer_canvas.winfo_width()
            if width <= 1:  # Not properly rendered yet
                self.app.after(100, draw_gradient)
                return

            height = 30
            # Create gradient from dark to slightly lighter
            for i in range(height):
                # Calculate color based on position
                r, g, b = self.hex_to_rgb(self.colors["bg_dark"])
                factor = i / height * 0.2  # Subtle gradient
                r = min(255, int(r + (255 - r) * factor))
                g = min(255, int(g + (255 - g) * factor))
                b = min(255, int(b + (255 - b) * factor))
                color = f'#{r:02x}{g:02x}{b:02x}'

                # Draw line
                footer_canvas.create_line(0, i, width, i, fill=color)

        # Schedule gradient drawing after the window is rendered
        self.app.after(100, draw_gradient)

        # Status label
        self.status_label = ctk.CTkLabel(
            footer_canvas,
            text="Ready",
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        self.status_label.place(relx=0.01, rely=0.5, anchor="w")

        # Version label
        version_label = ctk.CTkLabel(
            footer_canvas,
            text="DragonVoice v2.0",
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        version_label.place(relx=0.99, rely=0.5, anchor="e")

        # Log successful creation
        logging.info(
            "Footer created successfully with status_label initialized")

    def create_tabs(self):
        """Create the main tab view and tabs"""
        # Create the main tab container
        self.tab_container = ctk.CTkFrame(self.app, fg_color="transparent")
        self.tab_container.pack(
            fill="both",
            expand=True,
            padx=20,
            pady=(
                0,
                20))

        # Create the tab view
        self.tab_view = ctk.CTkTabview(
            self.tab_container,
            fg_color=self.colors["bg_dark"],
            segmented_button_fg_color=self.colors["bg_medium"],
            segmented_button_selected_color=self.colors["accent_primary"],
            segmented_button_selected_hover_color=self.colors["accent_secondary"],
            segmented_button_unselected_color=self.colors["bg_medium"],
            segmented_button_unselected_hover_color=self.colors["bg_light"])
        self.tab_view.pack(fill="both", expand=True)

        # Add tabs
        self.tab_view.add("Dashboard")
        self.tab_view.add("Chatbots")
        self.tab_view.add("History")
        self.tab_view.add("Configuration")
        self.tab_view.add("About")

        # Set default tab
        self.tab_view.set("Dashboard")

        # Create tab contents
        self.create_dashboard_tab()
        self.create_chatbots_tab()
        self.create_history_tab()
        self.create_config_tab()
        self.create_about_tab()

    def create_dashboard_tab(self):
        """Create the dashboard tab content"""
        # Main container with gradient background
        dashboard_container = ctk.CTkScrollableFrame(
            self.tab_view.tab("Dashboard"),
            fg_color="transparent"
        )
        dashboard_container.pack(fill="both", expand=True, padx=20, pady=20)

        # Create a grid layout for dashboard widgets
        dashboard_container.columnconfigure(0, weight=2)
        dashboard_container.columnconfigure(1, weight=1)
        dashboard_container.rowconfigure(0, weight=1)
        dashboard_container.rowconfigure(1, weight=1)
        dashboard_container.rowconfigure(2, weight=1)  # Add row for transcription section

        # Status panel (top left) - Enhanced with modern styling
        status_panel = self.create_status_panel(dashboard_container)
        status_panel.grid(
            row=0, column=0, sticky="nsew", padx=(
                0, 10), pady=(
                0, 10))

        # Voice assistant control panel (top right) - Enhanced with modern
        # styling
        control_panel = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=15,
            border_width=1,
            border_color=self.colors["bg_light"]
        )
        control_panel.grid(
            row=0, column=1, sticky="nsew", padx=(
                10, 0), pady=(
                0, 10))

        # Control panel header with icon
        control_header = ctk.CTkFrame(
            control_panel, fg_color="transparent", height=50)
        control_header.pack(fill="x", padx=20, pady=(15, 5))

        # Control panel title with icon
        control_title = ctk.CTkLabel(
            control_header,
            text="Voice Assistant",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        control_title.pack(side="left")

        # Start/Stop button with improved styling
        self.toggle_button = ctk.CTkButton(
            control_panel,
            text="Start Voice Assistant",
            command=self.toggle_voice_assistant,
            fg_color=self.colors["status_green"],  # Start with green
            hover_color=self._adjust_color_brightness(self.colors["status_green"], 0.8),
            height=60,
            corner_radius=10,
            font=self.fonts["subtitle"],
            border_width=1,
            border_color=self._adjust_color_brightness(
                self.colors["status_green"],
                1.2))
        self.toggle_button.pack(fill="x", padx=20, pady=15)
        
        # Recording buttons container
        recording_buttons_frame = ctk.CTkFrame(control_panel, fg_color="transparent")
        recording_buttons_frame.pack(fill="x", padx=20, pady=10)

        # Record button
        self.record_button = ctk.CTkButton(
            recording_buttons_frame,
            text="Record",
            command=self.start_manual_recording,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            height=40,
            width=150,
            corner_radius=10
        )
        self.record_button.pack(side="left", fill="x", expand=True, padx=(0, 5))

        # Stop Recording button
        self.stop_record_button = ctk.CTkButton(
            recording_buttons_frame,
            text="Stop Recording",
            command=self.stop_manual_recording,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            height=40,
            width=150,
            corner_radius=10,
            state="disabled"
        )
        self.stop_record_button.pack(side="right", fill="x", expand=True, padx=(5, 0))

        # Add synthesizer bar to show voice detection
        self.synth_bar = SynthesizerBar(control_panel, self.colors, self.fonts)

        # Microphone sensitivity slider
        sensitivity_frame = ctk.CTkFrame(
            control_panel,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        sensitivity_frame.pack(fill="x", padx=20, pady=10)

        sensitivity_label = ctk.CTkLabel(
            sensitivity_frame,
            text="Microphone Sensitivity",
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"]
        )
        sensitivity_label.pack(anchor="w", padx=15, pady=(10, 5))

        sensitivity_control = ctk.CTkFrame(sensitivity_frame, fg_color="transparent")
        sensitivity_control.pack(fill="x", padx=15, pady=(0, 10))

        self.sensitivity_var = ctk.DoubleVar(value=0.5)
        self.sensitivity_slider = ctk.CTkSlider(
            sensitivity_control,
            from_=0.1,
            to=1.0,
            variable=self.sensitivity_var,
            width=200,
            progress_color=self.colors["accent_primary"],
            button_color=self.colors["accent_secondary"],
            button_hover_color=self.colors["accent_primary"]
        )
        self.sensitivity_slider.pack(side="left", fill="x", expand=True, padx=(0, 10))

        self.sensitivity_value = ctk.CTkLabel(
            sensitivity_control,
            text=f"{int(self.sensitivity_var.get() * 100)}%",
            font=self.fonts["small"],
            width=40,
            text_color=self.colors["text_dim"]
        )
        self.sensitivity_value.pack(side="right")

        # Update sensitivity value when slider changes
        def update_sensitivity(*args):
            self.sensitivity_value.configure(text=f"{int(self.sensitivity_var.get() * 100)}%")
            if hasattr(self, 'gain_var'):
                self.gain_var.set(self.sensitivity_var.get())

        self.sensitivity_var.trace_add("write", update_sensitivity)
        
        # Initialize gain variable for level meter
        self.gain_var = ctk.DoubleVar(value=self.sensitivity_var.get())

        # Status indicator with improved styling
        status_frame = ctk.CTkFrame(
            control_panel,
            fg_color=self.colors["bg_light"],
            corner_radius=10,
            height=50
        )
        status_frame.pack(fill="x", padx=20, pady=10)
        status_frame.pack_propagate(False)

        status_label = ctk.CTkLabel(
            status_frame,
            text="Status: Idle",
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"]
        )
        status_label.pack(side="left", padx=15, pady=10)

        self.status_indicator = ctk.CTkFrame(
            status_frame,
            fg_color=self.colors["status_gray"],
            width=20,
            height=20,
            corner_radius=10
        )
        self.status_indicator.pack(side="right", padx=15)

        # Add text display window for pronounced text
        text_display_frame = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=15,
            border_width=1,
            border_color=self.colors["bg_light"]
        )
        text_display_frame.grid(
            row=1,
            column=0,
            columnspan=2,
            sticky="nsew",
            pady=(10, 10))
                
        # Text display header
        text_header = ctk.CTkFrame(
            text_display_frame, fg_color="transparent", height=50)
        text_header.pack(fill="x", padx=20, pady=(15, 5))
        
        text_title = ctk.CTkLabel(
            text_header,
            text="🔊 Voice Commands",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        text_title.pack(side="left")
        
        # Clear button for text display
        clear_text_button = ctk.CTkButton(
            text_header,
            text="Clear",
            command=lambda: self.clear_text_display(),
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            width=80
        )
        clear_text_button.pack(side="right")
        
        # Text display area
        self.text_display = ctk.CTkTextbox(
            text_display_frame,
            fg_color=self.colors["bg_light"],
            text_color=self.colors["text_bright"],
            font=self.fonts["large"],
            corner_radius=10,
            border_width=1,
            border_color=self.colors["bg_light"],
            height=200
        )
        self.text_display.pack(fill="both", expand=True, padx=20, pady=(5, 20))
        
        # Configure text tags
        self.text_display._textbox.tag_configure(
            "timestamp",
            foreground=self.colors["accent_secondary"]
        )
        self.text_display._textbox.tag_configure(
            "command",
            foreground=self.colors["accent_primary"]
        )
        self.text_display._textbox.tag_configure(
            "system",
            foreground=self.colors["status_blue"]
        )
        
        # Add initial message
        self.text_display.configure(state="normal")
        self.text_display.insert("end", "Voice commands will appear here after starting the voice assistant...")
        self.text_display.configure(state="disabled")
        
        # Add transcription section (bottom)
        transcription_frame = ctk.CTkFrame(
            dashboard_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=15,
            border_width=1,
            border_color=self.colors["bg_light"]
        )
        transcription_frame.grid(
            row=2,
            column=0,
            columnspan=2,
            sticky="nsew",
            pady=(0, 10))
            
        # Transcription header
        transcription_header = ctk.CTkFrame(
            transcription_frame, fg_color="transparent", height=50)
        transcription_header.pack(fill="x", padx=20, pady=(15, 5))
        
        transcription_title = ctk.CTkLabel(
            transcription_header,
            text="📝 Transcription",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        transcription_title.pack(side="left")
        
        # Controls frame
        controls = ctk.CTkFrame(transcription_header, fg_color="transparent")
        controls.pack(side="right")
        
        # Clear button
        clear_button = ctk.CTkButton(
            controls,
            text="Clear",
            command=lambda: self.clear_transcription(),
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            width=80
        )
        clear_button.pack(side="right", padx=(0, 10))
        
        # Enter button
        self.enter_button = ctk.CTkButton(
            controls,
            text="Enter",
            command=self.process_transcription,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            width=100,
            state="disabled"
        )
        self.enter_button.pack(side="right")
        
        # Transcription display
        self.transcription_display = ctk.CTkTextbox(
            transcription_frame,
            fg_color=self.colors["bg_light"],
            text_color=self.colors["text_bright"],
            font=self.fonts["large"],
            corner_radius=10,
            border_width=1,
            border_color=self.colors["bg_light"],
            height=150
        )
        self.transcription_display.pack(fill="both", expand=True, padx=20, pady=(5, 20))
        
        # Configure text tags
        self.transcription_display._textbox.tag_configure(
            "timestamp",
            foreground=self.colors["accent_secondary"]
        )
        self.transcription_display._textbox.tag_configure(
            "transcription",
            foreground=self.colors["text_bright"]
        )
        
        # Add initial message
        self.transcription_display.configure(state="normal")
        self.transcription_display.insert("end", "Transcribed text will appear here...")
        self.transcription_display.configure(state="disabled")

        # Initialize monitor visualization
        self.app.after(500, self.refresh_monitor_visualization)

    def create_synthesizer_bar(self, parent):
        """Create a synthesizer bar to visualize voice detection"""
        # Use the new SynthesizerBar class if available
        try:
            from synthesizer_bar import SynthesizerBar
            self.synth_bar = SynthesizerBar(parent, self.colors, self.fonts)
            return
        except ImportError:
            logging.warning(
                "SynthesizerBar class not found, using fallback implementation")

        # Fallback implementation
        synth_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10,
            height=80
        )
        synth_frame.pack(fill="x", padx=20, pady=10)

        # Synthesizer label
        synth_label = ctk.CTkLabel(
            synth_frame,
            text="Voice Detection",
            font=self.fonts["normal"],
            text_color=self.colors["text_bright"]
        )
        synth_label.pack(anchor="w", padx=15, pady=(10, 5))

        # Create level meter canvas
        self.level_canvas = ctk.CTkCanvas(
            synth_frame,
            bg=self.colors["bg_dark"],
            highlightthickness=0,
            height=30
        )
        self.level_canvas.pack(fill="x", padx=15, pady=(0, 10))

        # Initialize level meter with zero level
        self.app.after(100, lambda: self._update_level_meter(0))

    def create_chatbots_tab(self):
        """Create the chatbots tab content"""
        # Main container
        chatbots_container = ctk.CTkFrame(
            self.tab_view.tab("Chatbots"),
            fg_color="transparent"
        )
        chatbots_container.pack(fill="both", expand=True, padx=20, pady=20)

        # Title and add button row
        title_frame = ctk.CTkFrame(chatbots_container, fg_color="transparent")
        title_frame.pack(fill="x", pady=(0, 15))

        # Title with icon
        title_label = ctk.CTkLabel(
            title_frame,
            text="Chatbot Management",
            font=ctk.CTkFont(size=24, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title_label.pack(side="left")

        # Add chatbot button
        add_button = ctk.CTkButton(
            title_frame,
            text="Add New Chatbot",
            command=self.show_add_chatbot_dialog,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            width=120
        )
        add_button.pack(side="right")

        # Search frame
        search_frame = ctk.CTkFrame(
            chatbots_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=10,
            height=50
        )
        search_frame.pack(fill="x", pady=(0, 15))
        search_frame.pack_propagate(False)

        # Search icon
        search_icon = ctk.CTkLabel(
            search_frame,
            text="🔍",
            font=ctk.CTkFont(size=16),
            width=30
        )
        search_icon.pack(side="left", padx=(15, 0))

        # Search entry
        self.search_var = ctk.StringVar()
        self.search_var.trace_add(
            "write", lambda *args: self.filter_chatbot_list())
        search_entry = ctk.CTkEntry(
            search_frame,
            placeholder_text="Search chatbots...",
            textvariable=self.search_var,
            border_width=0,
            fg_color="transparent",
            height=40
        )
        search_entry.pack(side="left", fill="x", expand=True, padx=10)

        # Chatbot list container
        self.chatbot_list_frame = ctk.CTkScrollableFrame(
            chatbots_container,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        self.chatbot_list_frame.pack(fill="both", expand=True)

        # Refresh chatbot list
        self.refresh_chatbots()

    def create_about_tab(self):
        """Create the about tab content"""
        # Main container
        about_container = ctk.CTkFrame(
            self.tab_view.tab("About"),
            fg_color="transparent"
        )
        about_container.pack(fill="both", expand=True, padx=20, pady=20)

        # Create a scrollable frame for the about content
        about_scroll = ctk.CTkScrollableFrame(
            about_container,
            fg_color="transparent"
        )
        about_scroll.pack(fill="both", expand=True)

        # Logo and title
        logo_frame = ctk.CTkFrame(about_scroll, fg_color="transparent")
        logo_frame.pack(fill="x", pady=(0, 20))

        # App title
        title_label = ctk.CTkLabel(
            logo_frame,
            text="DragonVoice",
            font=ctk.CTkFont(size=32, weight="bold"),
            text_color=self.colors["accent_primary"]
        )
        title_label.pack(pady=(0, 5))

        # Version
        version_label = ctk.CTkLabel(
            logo_frame,
            text="Version 2.0",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"]
        )
        version_label.pack()

        # Description
        description_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        description_frame.pack(fill="x", pady=10, padx=5)

        description_label = ctk.CTkLabel(
            description_frame,
            text="DragonVoice is an advanced voice assistant that integrates with multiple AI chatbots.\n"
            "It provides a seamless voice interface for interacting with AI models and controlling your computer.",
            font=ctk.CTkFont(
                size=14),
            text_color=self.colors["text_normal"],
            wraplength=600,
            justify="left")
        description_label.pack(padx=20, pady=20)

        # Features
        features_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        features_frame.pack(fill="x", pady=10, padx=5)

        features_title = ctk.CTkLabel(
            features_frame,
            text="Key Features",
            font=ctk.CTkFont(size=18, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        features_title.pack(anchor="w", padx=20, pady=(15, 10))

        features = [
            "🎤 Voice recognition with OpenAI Whisper",
            "🤖 Multiple AI chatbot integrations",
            "⌨️ System control through voice commands",
            "📊 Real-time system monitoring",
            "🎨 Customizable themes and appearance",
            "🔧 Advanced configuration options"
        ]

        for feature in features:
            feature_label = ctk.CTkLabel(
                features_frame,
                text=feature,
                font=ctk.CTkFont(size=14),
                text_color=self.colors["text_normal"],
                anchor="w"
            )
            feature_label.pack(anchor="w", padx=20, pady=5)

        # Credits
        credits_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        credits_frame.pack(fill="x", pady=10, padx=5)

        credits_title = ctk.CTkLabel(
            credits_frame,
            text="Credits",
            font=ctk.CTkFont(size=18, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        credits_title.pack(anchor="w", padx=20, pady=(15, 10))

        credits_label = ctk.CTkLabel(
            credits_frame,
            text="Developed by: DragonVoice Team\n"
                 "UI Framework: CustomTkinter\n"
                 "Voice Recognition: OpenAI Whisper\n"
                 "Special thanks to all contributors and testers",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            justify="left"
        )
        credits_label.pack(anchor="w", padx=20, pady=(0, 15))

        # Links
        links_frame = ctk.CTkFrame(
            about_scroll,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        links_frame.pack(fill="x", pady=10, padx=5)

        links_title = ctk.CTkLabel(
            links_frame,
            text="Links",
            font=ctk.CTkFont(size=18, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        links_title.pack(anchor="w", padx=20, pady=(15, 10))

        # Function to open links
        def open_link(url):
            import webbrowser
            webbrowser.open(url)

        # Website link
        website_button = ctk.CTkButton(
            links_frame,
            text="Visit Website",
            command=lambda: open_link("https://dragonvoice.ai"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        website_button.pack(anchor="w", padx=20, pady=5)

        # Documentation link
        docs_button = ctk.CTkButton(
            links_frame,
            text="Documentation",
            command=lambda: open_link("https://docs.dragonvoice.ai"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        docs_button.pack(anchor="w", padx=20, pady=5)

        # GitHub link
        github_button = ctk.CTkButton(
            links_frame,
            text="GitHub Repository",
            command=lambda: open_link("https://github.com/dragonvoice/dragonvoice"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"])
        github_button.pack(anchor="w", padx=20, pady=(5, 15))

    def create_settings_advanced_tab(self, parent):
        """Create the advanced settings tab content"""
        # Main container
        container = ctk.CTkFrame(parent, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)

        # Logging settings section
        logging_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        logging_frame.pack(fill="x", pady=(0, 15))

        # Section title
        logging_title = ctk.CTkLabel(
            logging_frame,
            text="Logging Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        logging_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Log level
        log_level_frame = ctk.CTkFrame(logging_frame, fg_color="transparent")
        log_level_frame.pack(fill="x", padx=15, pady=5)

        log_level_label = ctk.CTkLabel(
            log_level_frame,
            text="Log Level",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        log_level_label.pack(side="left")

        self.log_level_var = ctk.StringVar(value="INFO")
        log_level_dropdown = ctk.CTkOptionMenu(
            log_level_frame,
            values=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
            variable=self.log_level_var,
            width=200
        )
        log_level_dropdown.pack(side="left", padx=10)

        # Enable file logging
        file_logging_frame = ctk.CTkFrame(
            logging_frame, fg_color="transparent")
        file_logging_frame.pack(fill="x", padx=15, pady=5)

        file_logging_label = ctk.CTkLabel(
            file_logging_frame,
            text="File Logging",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        file_logging_label.pack(side="left")

        self.file_logging_var = ctk.BooleanVar(value=True)
        file_logging_switch = ctk.CTkSwitch(
            file_logging_frame,
            text="",
            variable=self.file_logging_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        file_logging_switch.pack(side="left", padx=10)

        # Performance settings section
        performance_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        performance_frame.pack(fill="x", pady=(0, 15))

        # Section title
        performance_title = ctk.CTkLabel(
            performance_frame,
            text="Performance Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        performance_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Hardware acceleration
        hardware_frame = ctk.CTkFrame(
            performance_frame, fg_color="transparent")
        hardware_frame.pack(fill="x", padx=15, pady=5)

        hardware_label = ctk.CTkLabel(
            hardware_frame,
            text="Hardware Acceleration",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        hardware_label.pack(side="left")

        self.hardware_var = ctk.BooleanVar(value=True)
        hardware_switch = ctk.CTkSwitch(
            hardware_frame,
            text="",
            variable=self.hardware_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        hardware_switch.pack(side="left", padx=10)

        # Thread count
        thread_frame = ctk.CTkFrame(performance_frame, fg_color="transparent")
        thread_frame.pack(fill="x", padx=15, pady=5)

        thread_label = ctk.CTkLabel(
            thread_frame,
            text="Worker Threads",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        thread_label.pack(side="left")

        self.thread_var = ctk.IntVar(value=4)
        thread_slider = ctk.CTkSlider(
            thread_frame,
            from_=1,
            to=16,
            number_of_steps=15,
            variable=self.thread_var,
            width=200
        )
        thread_slider.pack(side="left", padx=10)

        thread_value = ctk.CTkLabel(
            thread_frame,
            textvariable=self.thread_var,
            width=30
        )
        thread_value.pack(side="left", padx=5)

        # Memory limit
        memory_frame = ctk.CTkFrame(performance_frame, fg_color="transparent")
        memory_frame.pack(fill="x", padx=15, pady=5)

        memory_label = ctk.CTkLabel(
            memory_frame,
            text="Memory Limit (MB)",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        memory_label.pack(side="left")

        self.memory_var = ctk.IntVar(value=1024)
        memory_slider = ctk.CTkSlider(
            memory_frame,
            from_=256,
            to=4096,
            number_of_steps=15,
            variable=self.memory_var,
            width=200
        )
        memory_slider.pack(side="left", padx=10)

        memory_value = ctk.CTkLabel(
            memory_frame,
            textvariable=self.memory_var,
            width=50
        )
        memory_value.pack(side="left", padx=5)

        # Reset button
        reset_button = ctk.CTkButton(
            container,
            text="Reset to Defaults",
            command=lambda: self.reset_advanced_settings(),
            fg_color=self.colors["bg_medium"],
            hover_color=self.colors["bg_light"],
            width=150
        )
        reset_button.pack(anchor="e", pady=10)

        return container

    def reset_advanced_settings(self):
        """Reset advanced settings to defaults"""
        self.log_level_var.set("INFO")
        self.file_logging_var.set(True)
        self.hardware_var.set(True)
        self.thread_var.set(4)
        self.memory_var.set(1024)
        self.update_status("Advanced settings reset to defaults")

    def apply_theme(self, theme_name):
        """Apply the selected theme"""
        if theme_name in self.color_schemes:
            self.colors = self.color_schemes[theme_name]
            self.config["theme"] = theme_name
            self.save_configuration(show_notification=False)
            # Refresh UI with new theme
            self.setup_theme()
            self.refresh_ui()

    def show_add_chatbot_dialog(self):
        """Show dialog to add a new chatbot"""
        dialog = ctk.CTkToplevel(self.app)
        dialog.title("Add New Chatbot")
        dialog.geometry("400x500")
        dialog.transient(self.app)
        dialog.grab_set()

        # Create form fields
        name_label = ctk.CTkLabel(
            dialog,
            text="Chatbot Name",
            text_color=self.colors["text_bright"]
        )
        name_label.pack(anchor="w", padx=20, pady=(20, 0))

        name_entry = ctk.CTkEntry(dialog, width=360)
        name_entry.pack(anchor="w", padx=20, pady=(0, 10))

        type_label = ctk.CTkLabel(
            dialog,
            text="Chatbot Type",
            text_color=self.colors["text_bright"]
        )
        type_label.pack(anchor="w", padx=20, pady=(10, 0))

        type_var = ctk.StringVar(value="GPT")
        type_dropdown = ctk.CTkOptionMenu(
            dialog,
            values=["GPT", "Claude", "Gemini", "Custom"],
            variable=type_var,
            width=360
        )
        type_dropdown.pack(anchor="w", padx=20, pady=(0, 10))

        api_key_label = ctk.CTkLabel(
            dialog,
            text="API Key",
            text_color=self.colors["text_bright"]
        )
        api_key_label.pack(anchor="w", padx=20, pady=(10, 0))

        api_key_entry = ctk.CTkEntry(dialog, width=360, show="*")
        api_key_entry.pack(anchor="w", padx=20, pady=(0, 10))

        # Add chatbot button
        def add_chatbot():
            name = name_entry.get()
            chatbot_type = type_var.get()
            api_key = api_key_entry.get()

            if name and chatbot_type and api_key:
                # Add to config
                if "chatbots" not in self.config:
                    self.config["chatbots"] = {}

                self.config["chatbots"][name] = {
                    "type": chatbot_type,
                    "api_key": api_key,
                    "status": "Ready",
                    "color": self.colors["accent_primary"],
                    "icon": "🤖"
                }

                self.save_configuration()
                self.refresh_chatbot_list()
                dialog.destroy()
            else:
                # Show error
                error_label.configure(text="Please fill in all fields")

        add_button = ctk.CTkButton(
            dialog,
            text="Add Chatbot",
            command=add_chatbot,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        add_button.pack(anchor="center", pady=20)

        # Error label
        error_label = ctk.CTkLabel(
            dialog,
            text="",
            text_color=self.colors["error"]
        )
        error_label.pack(anchor="center")

    def refresh_chatbot_list(self):
        """Refresh the list of chatbots in settings"""
        # Clear existing items
        for widget in self.chatbot_list_frame.winfo_children():
            widget.destroy()

        # Add header
        header = ctk.CTkFrame(
            self.chatbot_list_frame,
            fg_color="transparent"
        )
        header.pack(fill="x", padx=15, pady=5)

        ctk.CTkLabel(
            header,
            text="Name",
            font=ctk.CTkFont(weight="bold"),
            text_color=self.colors["text_bright"],
            width=100
        ).pack(side="left")

        ctk.CTkLabel(
            header,
            text="Type",
            font=ctk.CTkFont(weight="bold"),
            text_color=self.colors["text_bright"],
            width=100
        ).pack(side="left")

        ctk.CTkLabel(
            header,
            text="Status",
            font=ctk.CTkFont(weight="bold"),
            text_color=self.colors["text_bright"],
            width=100
        ).pack(side="left")

        # Add chatbots
        for name, config in self.config.get("chatbots", {}).items():
            self.add_chatbot_list_item(name, config)

    def add_chatbot_list_item(self, name, config):
        """Add a single chatbot item to the list"""
        # Create item frame with hover effect
        item = ctk.CTkFrame(
            self.chatbot_list_frame,
            fg_color=self.colors["bg_dark"],
            corner_radius=10,
            height=70
        )
        item.pack(fill="x", padx=5, pady=5)
        item.pack_propagate(False)

        # Add hover effect
        def on_enter(e):
            item.configure(fg_color=self.colors["bg_light"])

        def on_leave(e):
            item.configure(fg_color=self.colors["bg_dark"])

        item.bind("<Enter>", on_enter)
        item.bind("<Leave>", on_leave)

        # Icon and name container
        info_frame = ctk.CTkFrame(
            item,
            fg_color="transparent"
        )
        info_frame.pack(side="left", fill="y", padx=10)

        # Icon with colored background
        icon_frame = ctk.CTkFrame(
            info_frame,
            fg_color=config.get("color", self.colors["accent_primary"]),
            width=40,
            height=40,
            corner_radius=20
        )
        icon_frame.pack(side="left", padx=(0, 10))
        icon_frame.pack_propagate(False)

        icon_label = ctk.CTkLabel(
            icon_frame,
            text=config.get("icon", "🤖"),
            font=ctk.CTkFont(size=20)
        )
        icon_label.place(relx=0.5, rely=0.5, anchor="center")

        # Name and type
        text_frame = ctk.CTkFrame(
            info_frame,
            fg_color="transparent"
        )
        text_frame.pack(side="left", fill="y")

        name_label = ctk.CTkLabel(
            text_frame,
            text=name,
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        name_label.pack(anchor="w")

        type_label = ctk.CTkLabel(
            text_frame,
            text=config.get("type", "Unknown"),
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        type_label.pack(anchor="w")

        # Status indicator
        status_color = self.colors["status_green"] if config.get(
            "status") == "Ready" else self.colors["status_red"]
        status_frame = ctk.CTkFrame(
            item,
            fg_color="transparent"
        )
        status_frame.pack(side="right", fill="y", padx=10)

        status_dot = ctk.CTkLabel(
            status_frame,
            text="●",
            font=ctk.CTkFont(size=20),
            text_color=status_color
        )
        status_dot.pack(side="right", padx=5)

        status_label = ctk.CTkLabel(
            status_frame,
            text=config.get("status", "Unknown"),
            font=ctk.CTkFont(size=12),
            text_color=status_color
        )
        status_label.pack(side="right")

        # Make the entire item clickable
        item.bind(
            "<Button-1>",
            lambda e: self.show_chatbot_settings(
                name,
                config))

    def delete_chatbot(self, name):
        """Delete a chatbot from the configuration"""
        if name in self.config.get("chatbots", {}):
            del self.config["chatbots"][name]
            self.save_configuration()
            self.refresh_chatbot_list()
            # Also refresh the dashboard
            self.add_sample_chatbot_cards()

    def run(self):
        """Run the application main loop"""
        try:
            # Log startup
            logging.info("Starting DragonVoice application")

            # Update status
            self.update_status("Application started successfully")

            # Start the main event loop
            self.app.mainloop()

        except Exception as e:
            logging.error(f"Error in main loop: {str(e)}")
            raise

    def create_help_getting_started(self, parent):
        """Create the getting started help content"""
        # Welcome section
        welcome_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        welcome_frame.pack(fill="x", padx=20, pady=10)

        welcome_label = ctk.CTkLabel(
            welcome_frame,
            text="Welcome to DragonVoice",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        welcome_label.pack(anchor="w", padx=15, pady=(10, 5))

        welcome_text = ctk.CTkTextbox(
            welcome_frame,
            height=100,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        welcome_text.pack(fill="x", padx=15, pady=(0, 10))
        welcome_text.insert(
            "1.0",
            """DragonVoice is a powerful voice-controlled interface for interacting with multiple AI chatbots. This guide will help you get started with the basic features and setup.""")
        welcome_text.configure(state="disabled")

        # Quick Start Guide
        quickstart_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        quickstart_frame.pack(fill="x", padx=20, pady=10)

        quickstart_label = ctk.CTkLabel(
            quickstart_frame,
            text="Quick Start Guide",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        quickstart_label.pack(anchor="w", padx=15, pady=(10, 5))

        steps_text = ctk.CTkTextbox(
            quickstart_frame,
            height=200,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        steps_text.pack(fill="x", padx=15, pady=(0, 10))
        steps_text.insert("1.0", """1. Configure Your Chatbots
• Click the Settings button (⚙️) in the top right
• Go to the Chatbots tab
• Click "Add New Chatbot" and enter your API keys

2. Start Voice Assistant
• Click the "Start Voice Assistant" button in the header
• Wait for the status to show "Ready"
• Say your wake word (default: "Hey Dragon")

3. Issue Commands
• After the wake word, speak your command
• Example: "Ask what are the latest treatments for hypertension"
• The command will be sent to the appropriate chatbot

4. View Responses
• Responses appear in the chatbot windows
• You can interact with multiple chatbots simultaneously
• Use voice commands to switch between chatbots""")
        steps_text.configure(state="disabled")

    def create_help_voice_commands(self, parent):
        """Create the voice commands help content"""
        # Available Commands
        commands_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        commands_frame.pack(fill="x", padx=20, pady=10)

        commands_label = ctk.CTkLabel(
            commands_frame,
            text="Available Voice Commands",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        commands_label.pack(anchor="w", padx=15, pady=(10, 5))

        commands_text = ctk.CTkTextbox(
            commands_frame,
            height=400,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        commands_text.pack(fill="x", padx=15, pady=(0, 10))
        commands_text.insert("1.0", """Basic Commands:
• "Hey Dragon" - Wake word to start listening
• "Ask [question]" - Send a question to the active chatbot
• "Switch to [chatbot name]" - Change the active chatbot
• "Stop listening" - Deactivate voice recognition
• "Clear chat" - Clear the current conversation

Chatbot Control:
• "New conversation" - Start a fresh chat session
• "Save conversation" - Save the current chat history
• "Load conversation" - Restore a previous chat session
• "Export as PDF" - Export the conversation to PDF

Window Management:
• "Maximize window" - Expand the current chatbot window
• "Minimize window" - Minimize the current chatbot window
• "Arrange windows" - Organize all chatbot windows
• "Close window" - Close the current chatbot window

System Commands:
• "Open settings" - Show the settings dialog
• "Show help" - Display this help window
• "Check status" - Report system status
• "Exit program" - Close DragonVoice

Tips:
• Speak clearly and at a normal pace
• Wait for the "Listening..." indicator
• You can customize the wake word in settings
• Commands are case-insensitive""")
        commands_text.configure(state="disabled")

    def create_help_chatbots(self, parent):
        """Create the chatbots help content"""
        # Chatbot Overview
        overview_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        overview_frame.pack(fill="x", padx=20, pady=10)

        overview_label = ctk.CTkLabel(
            overview_frame,
            text="Working with Chatbots",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        overview_label.pack(anchor="w", padx=15, pady=(10, 5))

        overview_text = ctk.CTkTextbox(
            overview_frame,
            height=300,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        overview_text.pack(fill="x", padx=15, pady=(0, 10))
        overview_text.insert(
            "1.0", """DragonVoice supports multiple AI chatbots, allowing you to:
• Interact with different AI models simultaneously
• Compare responses across different chatbots
• Use specialized models for specific tasks
• Maintain separate conversation contexts

Supported Chatbots:
1. GPT (OpenAI)
   • Requires OpenAI API key
   • Supports GPT-3.5 and GPT-4
   • Best for general knowledge and coding

2. Claude (Anthropic)
   • Requires Anthropic API key
   • Excellent for analysis and writing
   • Strong ethical considerations

3. Gemini (Google)
   • Requires Google API key
   • Good at mathematical reasoning
   • Supports image understanding

4. Custom Chatbots
   • Add your own API integrations
   • Configure custom endpoints
   • Define specialized behaviors

Setting Up Chatbots:
1. Obtain API keys from providers
2. Add chatbots in Settings > Chatbots
3. Configure any special parameters
4. Test the connection

Best Practices:
• Keep API keys secure
• Monitor usage and costs
• Regular backup conversations
• Update chatbot configs as needed""")
        overview_text.configure(state="disabled")

    def create_help_troubleshooting(self, parent):
        """Create the troubleshooting help content"""
        # Common Issues
        issues_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        issues_frame.pack(fill="x", padx=20, pady=10)

        issues_label = ctk.CTkLabel(
            issues_frame,
            text="Common Issues",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        issues_label.pack(anchor="w", padx=15, pady=(10, 5))

        issues_text = ctk.CTkTextbox(
            issues_frame,
            height=400,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        issues_text.pack(fill="x", padx=15, pady=(0, 10))
        issues_text.insert("1.0", """Voice Recognition Issues:
1. Microphone Not Detected
   • Check microphone connections
   • Verify Windows permissions
   • Select correct input device in settings
   • Try restarting the application

2. Poor Recognition Accuracy
   • Adjust microphone sensitivity
   • Reduce background noise
   • Speak clearly and at normal pace
   • Check for latest updates

Chatbot Connection Problems:
1. API Key Errors
   • Verify API key is valid
   • Check for sufficient credits
   • Ensure correct API endpoint
   • Look for error messages in logs

2. Slow Responses
   • Check internet connection
   • Verify server status
   • Adjust timeout settings
   • Consider upgrading API tier

Interface Issues:
1. Display Problems
   • Update graphics drivers
   • Check resolution settings
   • Try different theme
   • Restart application

2. Performance Issues
   • Close unused applications
   • Check CPU/memory usage
   • Reduce number of active chatbots
   • Clear conversation history

Getting Help:
• Check application logs
• Visit our support forum
• Submit bug reports
• Contact technical support""")
        issues_text.configure(state="disabled")

    def create_help_about(self, parent):
        """Create the about help content"""
        # About Information
        about_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        about_frame.pack(fill="x", padx=20, pady=10)

        # Logo/Icon placeholder
        logo_label = ctk.CTkLabel(
            about_frame,
            text="🐉",
            font=ctk.CTkFont(size=48),
            text_color=self.colors["accent_primary"]
        )
        logo_label.pack(anchor="center", pady=20)

        # App title
        title_label = ctk.CTkLabel(
            about_frame,
            text="DragonVoice",
            font=ctk.CTkFont(size=24, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title_label.pack(anchor="center")

        # Version
        version_label = ctk.CTkLabel(
            about_frame,
            text="Version 2.0",
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        version_label.pack(anchor="center", pady=(0, 20))

        # Description
        description_text = ctk.CTkTextbox(
            about_frame,
            height=100,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        description_text.pack(fill="x", padx=15, pady=(0, 10))
        description_text.insert(
            "1.0",
            """DragonVoice is a powerful voice-controlled interface for medical professionals to interact with multiple AI chatbots simultaneously. It provides a seamless way to access and compare AI insights while maintaining focus on patient care.""")
        description_text.configure(state="disabled")

        # Credits
        credits_label = ctk.CTkLabel(
            about_frame,
            text="Credits",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        credits_label.pack(anchor="w", padx=15, pady=(10, 5))

        credits_text = ctk.CTkTextbox(
            about_frame,
            height=100,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        credits_text.pack(fill="x", padx=15, pady=(0, 10))
        credits_text.insert("1.0", """• OpenAI Whisper - Speech Recognition
• CustomTkinter - GUI Framework
• Various AI Models - Chatbot Integration
• Open Source Community - Libraries and Tools

Special thanks to all contributors and users who have helped improve DragonVoice.""")
        credits_text.configure(state="disabled")

        # Links
        links_frame = ctk.CTkFrame(
            about_frame,
            fg_color="transparent"
        )
        links_frame.pack(fill="x", padx=15, pady=10)

        website_button = ctk.CTkButton(
            links_frame,
            text="Website",
            width=100,
            command=lambda: webbrowser.open("https://dragonvoice.ai")
        )
        website_button.pack(side="left", padx=5)

        docs_button = ctk.CTkButton(
            links_frame,
            text="Documentation",
            width=100,
            command=lambda: webbrowser.open("https://docs.dragonvoice.ai")
        )
        docs_button.pack(side="left", padx=5)

        github_button = ctk.CTkButton(
            links_frame,
            text="GitHub",
            width=100,
            command=lambda: webbrowser.open("https://github.com/dragonvoice")
        )
        github_button.pack(side="left", padx=5)

    def toggle_theme(self):
        """Toggle between light and dark themes"""
        try:
            # Get current appearance mode
            current_mode = ctk.get_appearance_mode()

            # Toggle mode
            new_mode = "Light" if current_mode == "Dark" else "Dark"
            ctk.set_appearance_mode(new_mode)

            # Update status
            self.update_status(f"Theme changed to {new_mode} mode")

        except Exception as e:
            logging.error(f"Error toggling theme: {str(e)}")
            self.update_status(f"Failed to toggle theme: {str(e)}", "error")

    def start_system_monitoring(self):
        """Start monitoring system resources"""
        try:
            # Initialize status variables if they don't exist
            if not hasattr(self, 'cpu_usage'):
                self.cpu_usage = 0
            if not hasattr(self, 'memory_usage'):
                self.memory_usage = 0
            if not hasattr(self, 'disk_usage'):
                self.disk_usage = 0
            if not hasattr(self, 'voice_status'):
                self.voice_status = "Idle"

            def update_system_info():
                try:
                    # Update CPU usage
                    self.cpu_usage = psutil.cpu_percent(interval=None)

                    # Update memory usage
                    memory = psutil.virtual_memory()
                    self.memory_usage = memory.percent

                    # Update disk usage
                    disk = psutil.disk_usage('/')
                    self.disk_usage = disk.percent

                    # Update status indicators if they exist
                    for i, (value, color) in enumerate([
                        (self.cpu_usage, self.get_resource_color(self.cpu_usage)),
                        (self.memory_usage, self.get_resource_color(self.memory_usage)),
                        (self.disk_usage, self.get_resource_color(self.disk_usage))
                    ]):
                        status_indicator = getattr(self, f'status_indicator_{i}', None)
                        status_value = getattr(self, f'status_value_{i}', None)
                        if status_indicator and status_value:
                            status_indicator.configure(fg_color=color)
                            status_value.configure(
                                text=f"{value:.1f}%",
                                text_color=self.colors["text_bright"]
                            )

                    # Update voice status
                    if hasattr(self, 'recording_active'):
                        voice_status = "Recording" if self.recording_active else "Idle"
                        status_color = self.colors["status_green"] if self.recording_active else self.colors["status_gray"]
                        
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=status_color)
                        if hasattr(self, 'status_value_3'):
                            self.status_value_3.configure(
                                text=voice_status,
                                text_color=self.colors["text_bright"]
                            )

                    # Schedule next update
                    self.app.after(1000, update_system_info)

                except Exception as e:
                    logging.error(f"Error updating system info: {str(e)}")
                    # Try again later
                    self.app.after(5000, update_system_info)

            # Start the update loop
            update_system_info()

        except Exception as e:
            logging.error(f"Error starting system monitoring: {str(e)}")

    def get_resource_color(self, value):
        """Get color based on resource usage percentage"""
        if value < 60:
            return self.colors["status_green"]  # Green for normal
        elif value < 80:
            return self.colors["status_yellow"]  # Yellow for warning
        else:
            return self.colors["status_red"]  # Red for critical

    def filter_chatbot_list(self):
        """Filter the chatbot list based on search text"""
        search_text = self.search_var.get().lower()

        # Clear existing items
        for widget in self.chatbot_list_frame.winfo_children():
            widget.destroy()

        # Add filtered chatbots
        for name, config in self.config.get("chatbots", {}).items():
            if search_text in name.lower():
                self.add_chatbot_list_item(name, config)

    def show_chatbot_settings(self, name, config):
        """Show settings for the selected chatbot"""
        # Update header
        self.selected_chatbot_label.configure(text=f"Settings: {name}")

        # Clear existing settings
        for widget in self.settings_content.winfo_children():
            widget.destroy()

        # Create settings sections
        sections = [
            ("General Settings", self.create_general_settings),
            ("API Configuration", self.create_api_settings),
            ("Model Settings", self.create_model_settings),
            ("Response Settings", self.create_response_settings),
            ("Advanced Options", self.create_advanced_settings)
        ]

        for title, create_func in sections:
            section = create_func(self.settings_content, name, config)
            section.pack(fill="x", padx=10, pady=5)

    def create_general_settings(self, parent, name, config):
        """Create general settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="General Settings",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # Display name
        name_frame = ctk.CTkFrame(frame, fg_color="transparent")
        name_frame.pack(fill="x", padx=15, pady=5)

        name_label = ctk.CTkLabel(
            name_frame,
            text="Display Name:",
            width=120,
            anchor="w"
        )
        name_label.pack(side="left")

        name_entry = ctk.CTkEntry(
            name_frame,
            width=200,
            placeholder_text="Enter display name"
        )
        name_entry.insert(0, name)
        name_entry.pack(side="left", padx=10)

        # Icon selection
        icon_frame = ctk.CTkFrame(frame, fg_color="transparent")
        icon_frame.pack(fill="x", padx=15, pady=5)

        icon_label = ctk.CTkLabel(
            icon_frame,
            text="Icon:",
            width=120,
            anchor="w"
        )
        icon_label.pack(side="left")

        icons = ["🤖", "🧠", "💡", "🔍", "💬", "🌐", "📚", "⚡"]
        icon_var = ctk.StringVar(value=config.get("icon", "🤖"))

        for icon in icons:
            btn = ctk.CTkButton(
                icon_frame,
                text=icon,
                width=40,
                height=40,
                corner_radius=20,
                fg_color=self.colors["bg_medium"] if icon != icon_var.get() else self.colors["accent_primary"],
                hover_color=self.colors["accent_secondary"],
                command=lambda i=icon: [
                    icon_var.set(i),
                    self.update_chatbot_config(
                        name,
                        "icon",
                        i)])
            btn.pack(side="left", padx=2)

        return frame

    def create_api_settings(self, parent, name, config):
        """Create API settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="API Configuration",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # API Key
        key_frame = ctk.CTkFrame(frame, fg_color="transparent")
        key_frame.pack(fill="x", padx=15, pady=5)

        key_label = ctk.CTkLabel(
            key_frame,
            text="API Key:",
            width=120,
            anchor="w"
        )
        key_label.pack(side="left")

        key_entry = ctk.CTkEntry(
            key_frame,
            width=300,
            placeholder_text="Enter API key",
            show="*"
        )
        key_entry.insert(0, config.get("api_key", ""))
        key_entry.pack(side="left", padx=10)

        show_key = ctk.CTkButton(
            key_frame, text="👁️", width=40, command=lambda: key_entry.configure(
                show="" if key_entry.cget("show") == "*" else "*"))
        show_key.pack(side="left")

        # API Endpoint
        endpoint_frame = ctk.CTkFrame(frame, fg_color="transparent")
        endpoint_frame.pack(fill="x", padx=15, pady=5)

        endpoint_label = ctk.CTkLabel(
            endpoint_frame,
            text="API Endpoint:",
            width=120,
            anchor="w"
        )
        endpoint_label.pack(side="left")

        endpoint_entry = ctk.CTkEntry(
            endpoint_frame,
            width=300,
            placeholder_text="Enter API endpoint"
        )
        endpoint_entry.insert(0, config.get("endpoint", ""))
        endpoint_entry.pack(side="left", padx=10)

        # Test connection button
        test_button = ctk.CTkButton(
            frame,
            text="Test Connection",
            command=lambda: self.test_chatbot_connection(name),
            fg_color=self.colors["accent_secondary"]
        )
        test_button.pack(anchor="e", padx=15, pady=10)

        return frame

    def create_model_settings(self, parent, name, config):
        """Create model settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="Model Settings",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # Model selection
        model_frame = ctk.CTkFrame(frame, fg_color="transparent")
        model_frame.pack(fill="x", padx=15, pady=5)

        model_label = ctk.CTkLabel(
            model_frame,
            text="Model:",
            width=120,
            anchor="w"
        )
        model_label.pack(side="left")

        models = {
            "GPT": ["gpt-4", "gpt-3.5-turbo", "gpt-3.5-turbo-16k"],
            "Claude": ["claude-2", "claude-instant"],
            "Gemini": ["gemini-pro", "gemini-pro-vision"],
            "Custom": ["custom-model"]
        }

        model_type = config.get("type", "GPT")
        model_var = ctk.StringVar(
            value=config.get(
                "model", models[model_type][0]))

        model_combo = ctk.CTkComboBox(
            model_frame,
            width=200,
            values=models[model_type],
            variable=model_var,
            state="readonly"
        )
        model_combo.pack(side="left", padx=10)

        # Temperature
        temp_frame = ctk.CTkFrame(frame, fg_color="transparent")
        temp_frame.pack(fill="x", padx=15, pady=5)

        temp_label = ctk.CTkLabel(
            temp_frame,
            text="Temperature:",
            width=120,
            anchor="w"
        )
        temp_label.pack(side="left")

        temp_var = ctk.DoubleVar(value=config.get("temperature", 0.7))
        temp_slider = ctk.CTkSlider(
            temp_frame,
            from_=0.0,
            to=2.0,
            variable=temp_var,
            width=200
        )
        temp_slider.pack(side="left", padx=10)

        temp_value = ctk.CTkLabel(
            temp_frame,
            textvariable=temp_var,
            width=50
        )
        temp_value.pack(side="left")

        return frame

    def create_response_settings(self, parent, name, config):
        """Create response settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="Response Settings",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # Max tokens
        tokens_frame = ctk.CTkFrame(frame, fg_color="transparent")
        tokens_frame.pack(fill="x", padx=15, pady=5)

        tokens_label = ctk.CTkLabel(
            tokens_frame,
            text="Max Tokens:",
            width=120,
            anchor="w"
        )
        tokens_label.pack(side="left")

        tokens_var = ctk.IntVar(value=config.get("max_tokens", 2000))
        tokens_slider = ctk.CTkSlider(
            tokens_frame,
            from_=100,
            to=4000,
            variable=tokens_var,
            width=200
        )
        tokens_slider.pack(side="left", padx=10)

        tokens_value = ctk.CTkLabel(
            tokens_frame,
            textvariable=tokens_var,
            width=50
        )
        tokens_value.pack(side="left")

        # Response format
        format_frame = ctk.CTkFrame(frame, fg_color="transparent")
        format_frame.pack(fill="x", padx=15, pady=5)

        format_label = ctk.CTkLabel(
            format_frame,
            text="Format:",
            width=120,
            anchor="w"
        )
        format_label.pack(side="left")

        format_var = ctk.StringVar(value=config.get("format", "markdown"))
        formats = ["markdown", "html", "plain"]

        format_combo = ctk.CTkComboBox(
            format_frame,
            width=200,
            values=formats,
            variable=format_var,
            state="readonly"
        )
        format_combo.pack(side="left", padx=10)

        return frame

    def create_advanced_settings(self, parent, name, config):
        """Create advanced settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="Advanced Options",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # System prompt
        prompt_label = ctk.CTkLabel(
            frame,
            text="System Prompt:",
            anchor="w"
        )
        prompt_label.pack(anchor="w", padx=15, pady=(5, 0))

        prompt_text = ctk.CTkTextbox(
            frame,
            height=100,
            wrap="word"
        )
        prompt_text.pack(fill="x", padx=15, pady=5)
        prompt_text.insert("1.0", config.get("system_prompt", ""))

        # Checkboxes
        options_frame = ctk.CTkFrame(frame, fg_color="transparent")
        options_frame.pack(fill="x", padx=15, pady=5)

        stream_var = ctk.BooleanVar(value=config.get("stream", True))
        stream_cb = ctk.CTkCheckBox(
            options_frame,
            text="Stream responses",
            variable=stream_var
        )
        stream_cb.pack(anchor="w")

        history_var = ctk.BooleanVar(value=config.get("keep_history", True))
        history_cb = ctk.CTkCheckBox(
            options_frame,
            text="Keep conversation history",
            variable=history_var
        )
        history_cb.pack(anchor="w", pady=5)

        # Action buttons
        buttons_frame = ctk.CTkFrame(frame, fg_color="transparent")
        buttons_frame.pack(fill="x", padx=15, pady=10)

        save_button = ctk.CTkButton(
            buttons_frame,
            text="Save Changes",
            command=lambda: self.save_chatbot_settings(name),
            fg_color=self.colors["accent_primary"]
        )
        save_button.pack(side="left", padx=5)

        delete_button = ctk.CTkButton(
            buttons_frame,
            text="Delete Chatbot",
            command=lambda: self.delete_chatbot(name),
            fg_color=self.colors["error"]
        )
        delete_button.pack(side="right", padx=5)

        return frame

    def refresh_chatbots(self):
        """Refresh the chatbot cards and status in the dashboard"""
        # Update the chatbot list in the dedicated chatbots tab if it exists
        if hasattr(
                self,
                'chatbot_list_frame') and self.chatbot_list_frame.winfo_exists():
            self.refresh_chatbot_list()

        # Update status
        self.update_status("Chatbots refreshed", "info")

        # Refresh the monitor visualization
        if hasattr(self, 'monitor_canvas'):
            self.refresh_monitor_visualization()

        return True

    def load_config(self) -> dict:
        """Load the configuration from the JSON file"""
        try:
            with open(self.config_path, "r") as f:
                config = json.load(f)
                logging.info("Configuration loaded successfully")
                return config
        except FileNotFoundError:
            logging.error(f"Configuration file not found: {self.config_path}")
            return {}
        except json.JSONDecodeError:
            logging.error(
                f"Invalid JSON in configuration file: {self.config_path}")
            return {}

    def toggle_voice_assistant(self):
        """Toggle the voice assistant on/off"""
        # Check if we're in recording mode
        if hasattr(self, 'recording_active') and self.recording_active:
            # Update button text and color
            if hasattr(self, 'toggle_button'):
                self.toggle_button.configure(
                    text="Start Voice Assistant",
                    fg_color=self.colors["status_green"]  # Green when off
                )

            # Stop recording and transcribe
            if self.stop_manual_recording():
                # Transcribe the recording
                self.transcribe_last_recording()
                # Disable continuous recording
                self.continuous_recording = False

            # Update status indicator
            if hasattr(self, 'status_indicator'):
                self.status_indicator.configure(
                    fg_color=self.colors["status_gray"])
                
            # Enable record button, disable stop button
            if hasattr(self, 'record_button'):
                self.record_button.configure(state="normal")
            if hasattr(self, 'stop_record_button'):
                self.stop_record_button.configure(state="disabled")
        else:
            # Update button text and color
            if hasattr(self, 'toggle_button'):
                self.toggle_button.configure(
                    text="Stop Voice Assistant",
                    fg_color=self.colors["status_red"]  # Red when recording
                )

            # Start recording
            success = self.start_manual_recording()
            if success:
                # Enable continuous recording
                self.continuous_recording = True
                self.recording_active = True

                # Update status indicator
                if hasattr(self, 'status_indicator'):
                    self.status_indicator.configure(
                        fg_color=self.colors["status_green"])
                        
                # Disable record button, enable stop button
                if hasattr(self, 'record_button'):
                    self.record_button.configure(state="disabled")
                if hasattr(self, 'stop_record_button'):
                    self.stop_record_button.configure(state="normal")

                if hasattr(self, 'text_display'):
                    # Update the text display to show that voice assistant is active
                    self.text_display.configure(state="normal")
                    timestamp = datetime.now().strftime("%H:%M:%S")

                    # Add system message with formatting
                    system_pos = self.text_display.index("end-1c")
                    self.text_display.insert(
                        "end", f"[{timestamp}] Voice Assistant activated. Speak now...\n\n")
                    self.text_display._textbox.tag_add(
                        "system", system_pos, self.text_display.index("end-2c"))

                    self.text_display.see("end")
                    self.text_display.configure(state="disabled")
                    # Update status
                    self.update_status(
                        "Voice Assistant activated. Speak now...",
                        log_level="info")

    def start_manual_recording(self):
        """Start manual recording"""
        if not hasattr(self, 'whisper_recognizer') or self.whisper_recognizer is None:
            self.update_status("Whisper recognizer not initialized", log_level="error")
            return False

        try:
            # Get the selected microphone device if available
            device_id = None
            if hasattr(self, 'mic_device_var') and self.mic_device_var.get() != "Default":
                # Extract device ID from the selection string
                device_str = self.mic_device_var.get()
                if ":" in device_str:
                    device_id = int(device_str.split(":")[0].strip())
            
            # Log the device being used
            logging.info(f"Started recording audio with device_id: {device_id}")
            
            # Start recording with the selected device
            self.whisper_recognizer.start_recording(device=device_id)
            self.recording_active = True

            # Start level meter animation
            self.animate_level_meter()

            # Update UI
            if hasattr(self, 'toggle_button'):
                self.toggle_button.configure(text="Stop Voice Assistant")
                
            # Update status
            self.update_status("Voice Assistant activated. Speak now...", log_level="info")
            return True
        except Exception as e:
            self.update_status(f"Failed to start recording: {str(e)}", log_level="error")
            return False

    def stop_manual_recording(self):
        """Stop recording audio manually"""
        if not hasattr(self, 'whisper_recognizer'):
            self.update_status(
                "Whisper recognizer not initialized",
                log_level="error")
            return False

        try:
            # Stop recording
            success = self.whisper_recognizer.stop_recording()
            if success:
                self.update_status("Recording stopped", log_level="info")
                # Update UI to show stopped state
                self.toggle_button.configure(
                    text="Start Voice Assistant",
                    fg_color=self.colors["accent_primary"]
                )
                # Enable transcribe button after recording
                if hasattr(self, 'transcribe_button'):
                    self.transcribe_button.configure(state="normal")
                # Stop level meter animation
                self.recording_active = False

                # Update text display to show that voice assistant is stopped
                if hasattr(self, 'text_display'):
                    self.text_display.configure(state="normal")
                    timestamp = datetime.now().strftime("%H:%M:%S")

                    # Add system message with formatting
                    system_pos = self.text_display.index("end-1c")
                    self.text_display.insert(
                        "end", f"[{timestamp}] Voice Assistant stopped.\n\n")
                    self.text_display._textbox.tag_add(
                        "system", system_pos, self.text_display.index("end-2c"))

                    self.text_display.see("end")
                    self.text_display.configure(state="disabled")

                return True
            else:
                self.update_status("No recording to stop", log_level="warning")
                return False
        except Exception as e:
            self.update_status(
                f"Error stopping recording: {str(e)}",
                log_level="error")
            return False

    def transcribe_last_recording(self):
        """Transcribe the last recording using Whisper API"""
        try:
            # Check if whisper recognizer is initialized
            if not hasattr(self, 'whisper_recognizer') or self.whisper_recognizer is None:
                self.update_status("Whisper recognizer not initialized")
                logging.warning("Attempted to transcribe without initialized recognizer")
                return
                
            # Save audio to file and check if we have audio data
            if not hasattr(self, 'audio_data') or self.audio_data is None or len(self.audio_data) == 0:
                self.update_status("No audio data available for transcription")
                logging.warning("No audio data available for transcription")
                return
                
            # Update status
            self.update_status("Transcribing audio...")
            
            # Transcribe the audio
            transcription = self.whisper_recognizer.transcribe_audio(self.audio_data)
            
            if transcription:
                # Update status
                self.update_status(f"Transcription successful: {transcription[:30]}...")
                
                # Add to transcription display
                self.add_to_transcription(transcription)
                
                # Add to voice commands display
                self.add_to_text_display(transcription)
                
                # Auto-start recording if continuous mode is enabled
                if self.continuous_recording:
                    self.start_manual_recording()
            else:
                self.update_status("Transcription failed or returned empty result")
                logging.warning("Transcription failed or returned empty result")
                
        except Exception as e:
            self.update_status(f"Error during transcription: {str(e)}")
            logging.error(f"Error during transcription: {str(e)}", exc_info=True)
            
        # Disable the transcribe button after transcription
        if hasattr(self, 'transcribe_button'):
            self.transcribe_button.configure(state="disabled")

    def animate_level_meter(self):
        """Animate the microphone level meter during recording"""
        if not hasattr(self, 'recording_active') or not self.recording_active:
            # Even when not recording, update with zero level to show the meter
            if hasattr(self, 'synth_bar'):
                self.synth_bar.update(0)
            return

        try:
            # Get the latest audio data if available
            if hasattr(self, 'whisper_recognizer') and self.whisper_recognizer.audio_data:
                latest_chunk = self.whisper_recognizer.audio_data[-1]
                
                # Calculate volume (RMS)
                volume = np.sqrt(np.mean(latest_chunk**2))
                
                # Apply sensitivity/gain from the slider
                if hasattr(self, 'sensitivity_var'):
                    # Apply a logarithmic scaling for more natural sensitivity control
                    sensitivity = self.sensitivity_var.get()
                    volume = volume * (np.exp(sensitivity * 2) - 1)
                
                # Add noise floor threshold to filter out background noise
                noise_floor = 0.01  # Adjust this value based on testing
                if volume < noise_floor:
                    volume = 0
                
                # Scale for visualization (0-100) with more moderate scaling
                volume = min(100, volume * 150)  # Reduced from 300 to 150

                # Update the level meter
                if hasattr(self, 'synth_bar'):
                    self.synth_bar.update(volume)
                
                # Update voice status indicator
                if hasattr(self, 'status_value_3'):
                    if volume > 70:  # High volume
                        self.status_value_3.configure(text="Speaking")
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=self.colors["status_red"])
                    elif volume > 30:  # Medium volume
                        self.status_value_3.configure(text="Active")
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=self.colors["status_yellow"])
                    else:  # Low/no volume
                        self.status_value_3.configure(text="Listening")
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=self.colors["status_green"])
            else:
                # If no audio data, show no activity
                if hasattr(self, 'synth_bar'):
                    self.synth_bar.update(0)
            
            # Continue animation if recording is still active
            if self.recording_active:
                self.app.after(50, self.animate_level_meter)  # Faster updates for smoother animation
                
        except Exception as e:
            logging.error(f"Error in level meter animation: {str(e)}")
            # Try to continue animation despite error
            if hasattr(self, 'recording_active') and self.recording_active:
                self.app.after(100, self.animate_level_meter)

    def refresh_monitor_visualization(self):
        """Update the system monitor visualization"""
        try:
            # Check if monitor_canvas exists
            if not hasattr(self, 'monitor_canvas'):
                logging.warning("monitor_canvas not initialized yet")
                return

            # Clear previous visualization
            self.monitor_canvas.delete("all")

            # Get system metrics
            import psutil
            cpu_percent = psutil.cpu_percent()
            memory_percent = psutil.virtual_memory().percent
            disk_percent = psutil.disk_usage('/').percent

            # Canvas dimensions
            width = self.monitor_canvas.winfo_width()
            height = self.monitor_canvas.winfo_height()

            # Ensure we have valid dimensions
            if width <= 1 or height <= 1:
                # Canvas not properly sized yet, schedule another update
                self.app.after(1000, self.refresh_monitor_visualization)
                return

            # Bar width and spacing
            bar_width = width / 4
            spacing = width / 12

            # Draw CPU bar
            cpu_color = self.get_resource_color(cpu_percent)
            cpu_height = (cpu_percent / 100) * height
            self.monitor_canvas.create_rectangle(
                spacing, height - cpu_height,
                spacing + bar_width, height,
                fill=cpu_color, outline=""
            )
            self.monitor_canvas.create_text(
                spacing + bar_width / 2, height - cpu_height - 15,
                text=f"CPU\n{cpu_percent}%",
                fill=self.colors["text_bright"],
                font=("Helvetica", 10, "bold"),
                justify="center"
            )

            # Draw Memory bar
            mem_color = self.get_resource_color(memory_percent)
            mem_height = (memory_percent / 100) * height
            self.monitor_canvas.create_rectangle(
                spacing * 2 + bar_width, height - mem_height,
                spacing * 2 + bar_width * 2, height,
                fill=mem_color, outline=""
            )
            self.monitor_canvas.create_text(
                spacing * 2 + bar_width * 1.5, height - mem_height - 15,
                text=f"RAM\n{memory_percent}%",
                fill=self.colors["text_bright"],
                font=("Helvetica", 10, "bold"),
                justify="center"
            )

            # Draw Disk bar
            disk_color = self.get_resource_color(disk_percent)
            disk_height = (disk_percent / 100) * height
            self.monitor_canvas.create_rectangle(
                spacing * 3 + bar_width * 2, height - disk_height,
                spacing * 3 + bar_width * 3, height,
                fill=disk_color, outline=""
            )
            self.monitor_canvas.create_text(
                spacing * 3 + bar_width * 2.5, height - disk_height - 15,
                text=f"Disk\n{disk_percent}%",
                fill=self.colors["text_bright"],
                font=("Helvetica", 10, "bold"),
                justify="center"
            )

            # Schedule next update
            self.app.after(2000, self.refresh_monitor_visualization)

        except Exception as e:
            logging.error(f"Error updating monitor visualization: {str(e)}")
            # Try again later
            self.app.after(5000, self.refresh_monitor_visualization)

    def update_status(self, message, log_level="info"):
        """Update the status message in the footer"""
        try:
            # Log the message with appropriate level
            if log_level == "info":
                logging.info(message)
            elif log_level == "warning":
                logging.warning(message)
            elif log_level == "error":
                logging.error(message)

            # Check if status_label exists before updating
            if hasattr(self, 'status_label') and self.status_label is not None:
                self.status_label.configure(text=message)
            else:
                logging.warning(
                    "Status label not initialized yet, can't update status")

        except Exception as e:
            logging.error(f"Error updating status: {str(e)}")
            # Don't raise the exception to avoid crashing the app

    def _adjust_color_brightness(self, hex_color, factor):
        """Adjust the brightness of a hex color"""
        # Convert hex to RGB
        r, g, b = self.hex_to_rgb(hex_color)
        
        # Adjust brightness
        r = max(0, min(255, int(r * factor)))
        g = max(0, min(255, int(g * factor)))
        b = max(0, min(255, int(b * factor)))
        
        # Convert back to hex
        return f'#{r:02x}{g:02x}{b:02x}'
        
    def clear_transcription(self):
        """Clear the transcription display"""
        self.transcription_display.configure(state="normal")
        self.transcription_display.delete("1.0", "end")
        self.transcription_display.insert("end", "Transcribed text will appear here...")
        self.transcription_display.configure(state="disabled")
        self.enter_button.configure(state="disabled")
        
    def clear_text_display(self):
        """Clear the text display"""
        self.text_display.configure(state="normal")
        self.text_display.delete("1.0", "end")
        self.text_display.insert("end", "Voice commands will appear here after starting the voice assistant...")
        self.text_display.configure(state="disabled")

    def toggle_fullscreen(self):
        """Toggle fullscreen mode for the application window"""
        try:
            # Track fullscreen state
            if not hasattr(self, 'is_fullscreen'):
                self.is_fullscreen = False

            # Toggle state
            self.is_fullscreen = not self.is_fullscreen

            # Apply the change
            self.app.attributes("-fullscreen", self.is_fullscreen)

            # Update status
            status = "Fullscreen mode enabled" if self.is_fullscreen else "Fullscreen mode disabled"
            self.update_status(status)

        except Exception as e:
            logging.error(f"Error toggling fullscreen: {str(e)}")
            self.update_status(
                f"Failed to toggle fullscreen: {str(e)}", "error")

    def create_settings_general_tab(self, parent):
        """Create the general settings tab content"""
        # Main container
        container = ctk.CTkFrame(parent, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)

        # Interface settings section
        interface_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        interface_frame.pack(fill="x", pady=(0, 15))

        # Section title
        interface_title = ctk.CTkLabel(
            interface_frame,
            text="Interface Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        interface_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Language setting
        language_frame = ctk.CTkFrame(interface_frame, fg_color="transparent")
        language_frame.pack(fill="x", padx=15, pady=5)

        language_label = ctk.CTkLabel(
            language_frame,
            text="Interface Language",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        language_label.pack(side="left")

        self.language_var = ctk.StringVar(value="English")
        language_dropdown = ctk.CTkOptionMenu(
            language_frame,
            values=[
                "English",
                "Spanish",
                "French",
                "German",
                "Chinese",
                "Japanese"],
            variable=self.language_var,
            width=200)
        language_dropdown.pack(side="left", padx=10)

        # Startup settings section
        startup_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        startup_frame.pack(fill="x", pady=(0, 15))

        # Section title
        startup_title = ctk.CTkLabel(
            startup_frame,
            text="Startup Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        startup_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Auto-start setting
        autostart_frame = ctk.CTkFrame(startup_frame, fg_color="transparent")
        autostart_frame.pack(fill="x", padx=15, pady=5)

        autostart_label = ctk.CTkLabel(
            autostart_frame,
            text="Start with Windows",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        autostart_label.pack(side="left")

        self.autostart_var = ctk.BooleanVar(value=False)
        autostart_switch = ctk.CTkSwitch(
            autostart_frame,
            text="",
            variable=self.autostart_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        autostart_switch.pack(side="left", padx=10)

        # Start minimized setting
        minimized_frame = ctk.CTkFrame(startup_frame, fg_color="transparent")
        minimized_frame.pack(fill="x", padx=15, pady=5)

        minimized_label = ctk.CTkLabel(
            minimized_frame,
            text="Start Minimized",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        minimized_label.pack(side="left")

        self.minimized_var = ctk.BooleanVar(value=False)
        minimized_switch = ctk.CTkSwitch(
            minimized_frame,
            text="",
            variable=self.minimized_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        minimized_switch.pack(side="left", padx=10)

        # Auto-activate voice assistant
        autoactivate_frame = ctk.CTkFrame(
            startup_frame, fg_color="transparent")
        autoactivate_frame.pack(fill="x", padx=15, pady=5)

        autoactivate_label = ctk.CTkLabel(
            autoactivate_frame,
            text="Auto-activate Voice Assistant",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        autoactivate_label.pack(side="left")

        self.autoactivate_var = ctk.BooleanVar(value=False)
        autoactivate_switch = ctk.CTkSwitch(
            autoactivate_frame,
            text="",
            variable=self.autoactivate_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        autoactivate_switch.pack(side="left", padx=10)

        return container

    def create_settings_appearance_tab(self, parent):
        """Create the appearance settings tab content"""
        # Main container
        container = ctk.CTkFrame(parent, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)

        # Theme settings section
        theme_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        theme_frame.pack(fill="x", pady=(0, 15))

        # Section title
        theme_title = ctk.CTkLabel(
            theme_frame,
            text="Theme Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        theme_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Theme selection
        theme_selection_frame = ctk.CTkFrame(
            theme_frame, fg_color="transparent")
        theme_selection_frame.pack(fill="x", padx=15, pady=5)

        theme_label = ctk.CTkLabel(
            theme_selection_frame,
            text="Color Theme",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        theme_label.pack(side="left")

        self.theme_var = ctk.StringVar(value="medical")
        theme_dropdown = ctk.CTkOptionMenu(
            theme_selection_frame,
            values=["medical", "midnight", "cyberpunk"],
            variable=self.theme_var,
            width=200,
            command=self.apply_theme
        )
        theme_dropdown.pack(side="left", padx=10)

        # Appearance mode
        appearance_frame = ctk.CTkFrame(theme_frame, fg_color="transparent")
        appearance_frame.pack(fill="x", padx=15, pady=5)

        appearance_label = ctk.CTkLabel(
            appearance_frame,
            text="Appearance Mode",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        appearance_label.pack(side="left")

        self.appearance_var = ctk.StringVar(value="Dark")
        appearance_dropdown = ctk.CTkOptionMenu(
            appearance_frame,
            values=["Dark", "Light", "System"],
            variable=self.appearance_var,
            width=200,
            command=lambda value: ctk.set_appearance_mode(value)
        )
        appearance_dropdown.pack(side="left", padx=10)

        # Font settings section
        font_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        font_frame.pack(fill="x", pady=(0, 15))

        # Section title
        font_title = ctk.CTkLabel(
            font_frame,
            text="Font Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        font_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Font size
        font_size_frame = ctk.CTkFrame(font_frame, fg_color="transparent")
        font_size_frame.pack(fill="x", padx=15, pady=5)

        font_size_label = ctk.CTkLabel(
            font_size_frame,
            text="Font Size",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        font_size_label.pack(side="left")

        self.font_size_var = ctk.IntVar(value=12)
        font_size_slider = ctk.CTkSlider(
            font_size_frame,
            from_=8,
            to=16,
            number_of_steps=8,
            variable=self.font_size_var,
            width=200
        )
        font_size_slider.pack(side="left", padx=10)

        font_size_value = ctk.CTkLabel(
            font_size_frame,
            textvariable=self.font_size_var,
            width=30
        )
        font_size_value.pack(side="left", padx=5)

        # Preview section
        preview_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        preview_frame.pack(fill="x", pady=(0, 15))

        # Section title
        preview_title = ctk.CTkLabel(
            preview_frame,
            text="Theme Preview",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        preview_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Preview content
        preview_content = ctk.CTkFrame(
            preview_frame,
            fg_color=self.colors["bg_medium"],
            corner_radius=5,
            height=100
        )
        preview_content.pack(fill="x", padx=15, pady=(0, 15))
        preview_content.pack_propagate(False)

        preview_label = ctk.CTkLabel(
            preview_content,
            text="Sample Text",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"]
        )
        preview_label.pack(anchor="center", pady=10)

        preview_button = ctk.CTkButton(
            preview_content,
            text="Sample Button",
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            width=150
        )
        preview_button.pack(anchor="center")

        return container

    def create_settings_voice_tab(self, parent):
        """Create the voice settings tab content"""
        # Main container with gradient background
        container = ctk.CTkFrame(parent, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)

        # Microphone settings section
        mic_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        mic_frame.pack(fill="x", pady=(0, 15))

        # Section title
        mic_title = ctk.CTkLabel(
            mic_frame,
            text="Microphone Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        mic_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Microphone selection
        mic_selection_frame = ctk.CTkFrame(mic_frame, fg_color="transparent")
        mic_selection_frame.pack(fill="x", padx=15, pady=5)

        mic_label = ctk.CTkLabel(
            mic_selection_frame,
            text="Input Device",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        mic_label.pack(side="left")

        # Create a frame for the dropdown and refresh button
        mic_dropdown_frame = ctk.CTkFrame(
            mic_selection_frame, fg_color="transparent")
        mic_dropdown_frame.pack(side="left", fill="x", expand=True)

        # Microphone dropdown
        self.mic_var = ctk.StringVar(value="Default Microphone")
        self.mic_dropdown = ctk.CTkOptionMenu(
            mic_dropdown_frame,
            values=["Default Microphone"],
            variable=self.mic_var,
            width=200
        )
        self.mic_dropdown.pack(side="left", padx=(0, 10))

        # Refresh button
        refresh_button = ctk.CTkButton(
            mic_dropdown_frame,
            text="Refresh",
            command=self.refresh_mic_list,
            fg_color=self.colors["bg_medium"],
            hover_color=self.colors["bg_light"],
            width=80
        )
        refresh_button.pack(side="left")

        # Microphone level visualization
        level_frame = ctk.CTkFrame(mic_frame, fg_color="transparent")
        level_frame.pack(fill="x", padx=15, pady=5)

        level_label = ctk.CTkLabel(
            level_frame,
            text="Input Level",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        level_label.pack(side="left")

        # Level meter canvas
        self.level_canvas = ctk.CTkCanvas(
            level_frame,
            height=24,
            width=200,
            bg=self.colors["bg_dark"],
            highlightthickness=0
        )
        self.level_canvas.pack(side="left", padx=10)

        # Test microphone button
        test_button = ctk.CTkButton(
            level_frame,
            text="Test",
            command=self.test_microphone,
            fg_color=self.colors["accent_secondary"],
            hover_color=self.colors["accent_primary"],
            width=80
        )
        test_button.pack(side="left")

        # Advanced microphone settings
        advanced_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        advanced_frame.pack(fill="x", pady=(0, 15))

        # Section title
        advanced_title = ctk.CTkLabel(
            advanced_frame,
            text="Advanced Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        advanced_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Input gain
        gain_frame = ctk.CTkFrame(advanced_frame, fg_color="transparent")
        gain_frame.pack(fill="x", padx=15, pady=5)

        gain_label = ctk.CTkLabel(
            gain_frame,
            text="Input Gain",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        gain_label.pack(side="left")

        self.gain_var = ctk.DoubleVar(value=1.0)
        gain_slider = ctk.CTkSlider(
            gain_frame,
            from_=0.1,
            to=2.0,
            variable=self.gain_var,
            width=200
        )
        gain_slider.pack(side="left", padx=10)

        gain_value = ctk.CTkLabel(
            gain_frame,
            text=f"{self.gain_var.get():.1f}",
            width=30
        )
        gain_value.pack(side="left", padx=5)

        # Noise threshold
        threshold_frame = ctk.CTkFrame(advanced_frame, fg_color="transparent")
        threshold_frame.pack(fill="x", padx=15, pady=5)

        threshold_label = ctk.CTkLabel(
            threshold_frame,
            text="Noise Threshold",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        threshold_label.pack(side="left")

        self.threshold_var = ctk.DoubleVar(value=0.2)
        threshold_slider = ctk.CTkSlider(
            threshold_frame,
            from_=0.0,
            to=0.5,
            variable=self.threshold_var,
            width=200
        )
        threshold_slider.pack(side="left", padx=10)

        threshold_value = ctk.CTkLabel(
            threshold_frame,
            text=f"{self.threshold_var.get():.2f}",
            width=30
        )
        threshold_value.pack(side="left", padx=5)

        # Echo cancellation
        echo_frame = ctk.CTkFrame(advanced_frame, fg_color="transparent")
        echo_frame.pack(fill="x", padx=15, pady=5)

        echo_label = ctk.CTkLabel(
            echo_frame,
            text="Echo Cancellation",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        echo_label.pack(side="left")

        self.echo_var = ctk.BooleanVar(value=True)
        echo_switch = ctk.CTkSwitch(
            echo_frame,
            text="",
            variable=self.echo_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        echo_switch.pack(side="left", padx=10)

        # Noise reduction
        noise_frame = ctk.CTkFrame(advanced_frame, fg_color="transparent")
        noise_frame.pack(fill="x", padx=15, pady=5)

        noise_label = ctk.CTkLabel(
            noise_frame,
            text="Noise Reduction",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        noise_label.pack(side="left")

        self.noise_var = ctk.BooleanVar(value=True)
        noise_switch = ctk.CTkSwitch(
            noise_frame,
            text="",
            variable=self.noise_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        noise_switch.pack(side="left", padx=10)

        # Initialize microphone list
        self.refresh_mic_list()

        return container

    def refresh_mic_list(self):
        """Refresh the list of available microphones."""
        try:
            devices = sd.query_devices()
            input_devices = []

            # Add a default option
            input_devices.append("Default Microphone")

            # Add all input devices with their IDs for easier identification
            for i, device in enumerate(devices):
                if device['max_input_channels'] > 0:
                    input_devices.append(f"{device['name']} (ID: {i})")

            # Update dropdown
            self.mic_dropdown.configure(values=input_devices)

            # Set default selection
            if input_devices:
                self.mic_var.set(input_devices[0])

            # Update status
            self.update_status(f"Found {len(input_devices)-1} input devices")

        except Exception as e:
            logging.error(f"Error refreshing microphone list: {str(e)}")
            self.update_status("Failed to refresh microphone list", "error")
            # Ensure at least the default option is available
            self.mic_dropdown.configure(values=["Default Microphone"])
            self.mic_var.set("Default Microphone")

    def test_microphone(self):
        """Test the selected microphone by recording and playing back audio."""
        try:
            device_str = self.mic_var.get()
            device_id = None

            # Extract device ID if it's not the default microphone
            if device_str != "Default Microphone":
                try:
                    device_id = int(device_str.split("ID: ")[1].strip(")"))
                    logging.info(f"Testing microphone with ID: {device_id}")
                except Exception as e:
                    logging.error(f"Error parsing device ID: {str(e)}")
                    device_id = None
                    logging.info("Using default microphone instead")

            # Create a modern dialog to show recording status
            dialog = ctk.CTkToplevel(self.app)
            dialog.title("Microphone Test")
            dialog.geometry("400x300")
            dialog.resizable(False, False)
            dialog.transient(self.app)
            dialog.grab_set()

            # Set dialog theme
            dialog.configure(fg_color=self.colors["bg_medium"])

            # Center the dialog
            dialog.update_idletasks()
            width = dialog.winfo_width()
            height = dialog.winfo_height()
            x = (dialog.winfo_screenwidth() // 2) - (width // 2)
            y = (dialog.winfo_screenheight() // 2) - (height // 2)
            dialog.geometry(f"{width}x{height}+{x}+{y}")

            # Title with icon
            title_frame = ctk.CTkFrame(dialog, fg_color="transparent")
            title_frame.pack(fill="x", padx=20, pady=(20, 10))

            title_label = ctk.CTkLabel(
                title_frame,
                text="Microphone Test",
                font=ctk.CTkFont(size=20, weight="bold"),
                text_color=self.colors["text_bright"]
            )
            title_label.pack(side="left")

            # Status label with modern styling
            status_frame = ctk.CTkFrame(
                dialog, fg_color=self.colors["bg_light"], corner_radius=10)
            status_frame.pack(fill="x", padx=20, pady=10)

            status_label = ctk.CTkLabel(
                status_frame,
                text="Initializing microphone test...",
                font=ctk.CTkFont(size=14),
                text_color=self.colors["text_bright"],
                wraplength=350
            )
            status_label.pack(pady=15, padx=15)

            # Progress bar with custom styling
            progress_frame = ctk.CTkFrame(dialog, fg_color="transparent")
            progress_frame.pack(fill="x", padx=20, pady=5)

            progress_label = ctk.CTkLabel(
                progress_frame,
                text="Progress:",
                font=ctk.CTkFont(size=12),
                text_color=self.colors["text_normal"]
            )
            progress_label.pack(anchor="w")

            progress = ctk.CTkProgressBar(
                progress_frame,
                width=360,
                height=15,
                corner_radius=5,
                fg_color=self.colors["bg_dark"],
                progress_color=self.colors["accent_primary"]
            )
            progress.pack(pady=5)
            progress.set(0)

            # Level meter with improved visualization
            level_frame = ctk.CTkFrame(dialog, fg_color="transparent")
            level_frame.pack(fill="x", padx=20, pady=5)

            level_label = ctk.CTkLabel(
                level_frame,
                text="Audio Level:",
                font=ctk.CTkFont(size=12),
                text_color=self.colors["text_normal"]
            )
            level_label.pack(anchor="w")

            meter_bg = ctk.CTkFrame(
                level_frame,
                fg_color=self.colors["bg_dark"],
                height=30,
                width=360,
                corner_radius=5
            )
            meter_bg.pack(pady=5)

            level_indicator = ctk.CTkFrame(
                meter_bg,
                fg_color=self.colors["accent_primary"],
                height=30,
                width=1,
                corner_radius=5
            )
            level_indicator.place(x=0, y=0)

            level_text = ctk.CTkLabel(
                meter_bg,
                text="0%",
                font=ctk.CTkFont(size=12, weight="bold"),
                text_color=self.colors["text_bright"]
            )
            level_text.place(relx=0.5, rely=0.5, anchor="center")

            # Button frame
            button_frame = ctk.CTkFrame(dialog, fg_color="transparent")
            button_frame.pack(fill="x", padx=20, pady=(15, 20))

            # Cancel button
            cancel_button = ctk.CTkButton(
                button_frame,
                text="Cancel",
                command=dialog.destroy,
                fg_color=self.colors["bg_light"],
                hover_color=self.colors["bg_medium"],
                text_color=self.colors["text_normal"],
                width=100
            )
            cancel_button.pack(side="left", padx=(0, 10))

            # Close button (initially disabled)
            close_button = ctk.CTkButton(
                button_frame,
                text="Close",
                command=dialog.destroy,
                state="disabled",
                fg_color=self.colors["accent_primary"],
                hover_color=self.colors["accent_secondary"],
                width=100
            )
            close_button.pack(side="right")

            # Get device info
            try:
                device_info = sd.query_devices(device_id)
                samplerate = int(device_info['default_samplerate'])

                # Show device info in status
                status_label.configure(
                    text=f"Testing: {device_info['name']}\nPlease speak now to test your microphone.")
            except Exception as e:
                status_label.configure(
                    text=f"Error: {str(e)}\nCould not initialize the selected microphone.")
                close_button.configure(state="normal")
                return

            # Duration of recording
            duration = 5  # seconds

            # Function to update progress
            def update_progress(current, total):
                progress.set(current / total)
                progress_label.configure(
                    text=f"Progress: {int(current/total*100)}%")
                dialog.update()

            # Function to update level indicator
            def update_level(volume):
                # Scale volume (0-1) to width
                width = min(360, int(volume * 360))
                level_indicator.configure(width=width)

                # Update color based on level
                if volume < 0.3:
                    level_indicator.configure(
                        fg_color=self.colors["status_green"])
                elif volume < 0.7:
                    level_indicator.configure(
                        fg_color=self.colors["status_yellow"])
                else:
                    level_indicator.configure(
                        fg_color=self.colors["status_red"])

                # Update text
                level_text.configure(text=f"{int(volume * 100)}%")
                dialog.update()

            # Function to record audio
            def record_audio():
                status_label.configure(
                    text=f"Recording from: {device_info['name']}\nPlease speak now...")

                # Create array to store audio data
                audio_data = []

                # Start time
                start_time = time.time()

                # Callback function for audio stream
                def audio_callback(indata, frames, time_info, status):
                    if status:
                        logging.warning(f"Audio status: {status}")

                    # Copy audio data
                    audio_data.append(indata.copy())

                    # Calculate volume level (RMS)
                    volume = np.sqrt(np.mean(indata**2))

                    # Apply gain if available
                    if hasattr(self, 'gain_var'):
                        volume *= self.gain_var.get()

                    # Update level indicator
                    dialog.after(0, lambda: update_level(min(1.0, volume * 2)))

                    # Update progress
                    elapsed = time.time() - start_time
                    if elapsed < duration:
                        dialog.after(
                            0, lambda: update_progress(
                                elapsed, duration))

                # Start audio stream
                try:
                    with sd.InputStream(
                        device=device_id,
                        channels=1,
                        callback=audio_callback,
                        samplerate=samplerate,
                        blocksize=int(samplerate * 0.1)  # 100ms blocks
                    ):
                        # Wait for duration
                        sd.sleep(int(duration * 1000))
                except Exception as e:
                    error_msg = f"Error recording: {str(e)}"
                    logging.error(error_msg)
                    status_label.configure(text=error_msg)
                    close_button.configure(state="normal")
                    return None

                # Combine all audio chunks
                if audio_data:
                    return np.concatenate(audio_data)
                return None

            # Function to play audio
            def play_audio(audio_data):
                status_label.configure(text="Playing back recording...")
                progress.set(0)

                try:
                    # Start time
                    start_time = time.time()

                    # Play audio
                    sd.play(audio_data, samplerate)

                    # Update progress during playback
                    def update_playback_progress():
                        elapsed = time.time() - start_time
                        if elapsed < duration and not dialog.winfo_exists():
                            return

                        if elapsed < duration:
                            update_progress(elapsed, duration)
                            dialog.after(100, update_playback_progress)
                        else:
                            progress.set(1.0)
                            progress_label.configure(text="Progress: 100%")

                    # Start progress updates
                    update_playback_progress()

                    # Wait for playback to complete
                    sd.wait()

                    # Test completed
                    status_label.configure(
                        text="Test completed successfully!\n\nYour microphone is working properly.")
                    close_button.configure(state="normal")

                except Exception as e:
                    error_msg = f"Error playing back: {str(e)}"
                    logging.error(error_msg)
                    status_label.configure(text=error_msg)
                    close_button.configure(state="normal")

            # Run the recording in a separate thread
            def run_test():
                try:
                    # Record audio
                    audio_data = record_audio()

                    if audio_data is not None and len(audio_data) > 0:
                        # Play it back
                        play_audio(audio_data)
                    else:
                        status_label.configure(
                            text="No audio recorded or error occurred.\n\nPlease check if your microphone is properly connected and not muted.")
                        close_button.configure(state="normal")
                except Exception as e:
                    error_msg = f"Test failed: {str(e)}"
                    logging.error(error_msg)
                    status_label.configure(text=error_msg)
                    close_button.configure(state="normal")

            # Start the test in a separate thread
            threading.Thread(target=run_test, daemon=True).start()

        except Exception as e:
            error_msg = f"Failed to test microphone: {str(e)}"
            logging.error(error_msg)
            messagebox.showerror("Error", error_msg)
            self.update_status(f"Microphone test failed: {str(e)}", "error")

    def create_settings_chatbots_tab(self, parent):
        """Create the chatbots settings tab content"""
        # Main container
        container = ctk.CTkFrame(parent, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)

        # Title and add button row
        title_frame = ctk.CTkFrame(container, fg_color="transparent")
        title_frame.pack(fill="x", pady=(0, 15))

        # Title
        title_label = ctk.CTkLabel(
            title_frame,
            text="Manage Chatbots",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title_label.pack(side="left")

        # Add chatbot button
        add_button = ctk.CTkButton(
            title_frame,
            text="Add New Chatbot",
            command=self.show_add_chatbot_dialog,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            width=150
        )
        add_button.pack(side="right")

        return container

    def start_manual_recording(self):
        """Start manual recording"""
        if not hasattr(
                self,
                'whisper_recognizer') or self.whisper_recognizer is None:
            self.update_status(
                "Whisper recognizer not initialized",
                log_level="error")
            return False

        try:
            # Start recording
            self.whisper_recognizer.start_recording()
            self.recording_active = True

            # Start level meter animation
            self.animate_level_meter()

            # Update UI
            if hasattr(self, 'toggle_button'):
                self.toggle_button.configure(text="Stop Voice Assistant")

            # Update status
            self.update_status("Recording started", log_level="info")
            return True

        except Exception as e:
            self.update_status(
                f"Failed to start recording: {str(e)}",
                log_level="error")
            return False

    def stop_manual_recording(self):
        """Stop recording audio manually"""
        if not hasattr(self, 'whisper_recognizer'):
            self.update_status(
                "Whisper recognizer not initialized",
                log_level="error")
            return False

        try:
            # Stop recording
            success = self.whisper_recognizer.stop_recording()
            if success:
                self.update_status("Recording stopped", log_level="info")
                # Update UI to show stopped state
                self.toggle_button.configure(
                    text="Start Voice Assistant",
                    fg_color=self.colors["accent_primary"]
                )
                # Enable transcribe button after recording
                if hasattr(self, 'transcribe_button'):
                    self.transcribe_button.configure(state="normal")
                # Stop level meter animation
                self.recording_active = False

                # Update text display to show that voice assistant is stopped
                if hasattr(self, 'text_display'):
                    self.text_display.configure(state="normal")
                    timestamp = datetime.now().strftime("%H:%M:%S")

                    # Add system message with formatting
                    system_pos = self.text_display.index("end-1c")
                    self.text_display.insert(
                        "end", f"[{timestamp}] Voice Assistant stopped.\n\n")
                    self.text_display._textbox.tag_add(
                        "system", system_pos, self.text_display.index("end-2c"))

                    self.text_display.see("end")
                    self.text_display.configure(state="disabled")

                return True
            else:
                self.update_status("No recording to stop", log_level="warning")
                return False
        except Exception as e:
            self.update_status(
                f"Error stopping recording: {str(e)}",
                log_level="error")
            return False

    def transcribe_last_recording(self):
        """Transcribe the last recording"""
        if not hasattr(self, 'whisper_recognizer'):
            self.update_status(
                "Whisper recognizer not initialized",
                log_level="error")
            return None

        try:
            # Save audio to file
            audio_file = self.whisper_recognizer.save_audio_to_file()
            if not audio_file:
                self.update_status(
                    "No audio data to transcribe",
                    log_level="warning")
                return None

            # Transcribe audio
            self.update_status("Transcribing audio...", log_level="info")
            transcript = self.whisper_recognizer.transcribe_audio(
                audio_file,
                language="en",
                response_format="verbose_json"
            )

            if transcript:
                self.update_status(
                    f"Transcription successful: {transcript.text[:50]}...",
                    log_level="info")
                # Add to history
                timestamp = datetime.now().strftime("%H:%M:%S")
                self.add_history_item(transcript.text, timestamp, "Success")

                # Update the text display window with the voice command
                if hasattr(self, 'text_display'):
                    self.text_display.configure(state="normal")
                    # Add timestamp and text with formatting
                    timestamp_pos = self.text_display.index("end-1c")
                    self.text_display.insert("end", f"[{timestamp}] ")
                    self.text_display._textbox.tag_add(
                        "timestamp", timestamp_pos, self.text_display.index("end-1c"))

                    command_pos = self.text_display.index("end-1c")
                    self.text_display.insert("end", f"{transcript.text}\n\n")
                    self.text_display._textbox.tag_add(
                        "command", command_pos, self.text_display.index("end-2c"))

                    # Auto-scroll to the bottom
                    self.text_display.see("end")
                    self.text_display.configure(state="disabled")

                    # Automatically start recording again for continuous voice command recognition
                    # Use a flag to control continuous recording
                    if hasattr(
                            self,
                            'continuous_recording') and self.continuous_recording:
                        self.app.after(1000, self.start_manual_recording)

                # Disable transcribe button after successful transcription
                if hasattr(self, 'transcribe_button'):
                    self.transcribe_button.configure(state="disabled")
                return transcript.text
            else:
                self.update_status("Transcription failed", log_level="error")
                return None

        except Exception as e:
            self.update_status(
                f"Transcription error: {str(e)}",
                log_level="error")
            return None

    def animate_level_meter(self):
        """Animate the microphone level meter during recording"""
        if not hasattr(self, 'recording_active') or not self.recording_active:
            # Even when not recording, update with zero level to show the meter
            if hasattr(self, 'synth_bar'):
                self.synth_bar.update(0)
            return

        try:
            # Get the latest audio data if available
            if hasattr(self, 'whisper_recognizer') and self.whisper_recognizer.audio_data:
                latest_chunk = self.whisper_recognizer.audio_data[-1]
                
                # Calculate volume (RMS)
                volume = np.sqrt(np.mean(latest_chunk**2))
                
                # Apply sensitivity/gain from the slider
                if hasattr(self, 'sensitivity_var'):
                    # Apply a logarithmic scaling for more natural sensitivity control
                    sensitivity = self.sensitivity_var.get()
                    volume = volume * (np.exp(sensitivity * 2) - 1)
                
                # Add noise floor threshold to filter out background noise
                noise_floor = 0.01  # Adjust this value based on testing
                if volume < noise_floor:
                    volume = 0
                
                # Scale for visualization (0-100) with more moderate scaling
                volume = min(100, volume * 150)  # Reduced from 300 to 150

                # Update the level meter
                if hasattr(self, 'synth_bar'):
                    self.synth_bar.update(volume)
                
                # Update voice status indicator
                if hasattr(self, 'status_value_3'):
                    if volume > 70:  # High volume
                        self.status_value_3.configure(text="Speaking")
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=self.colors["status_red"])
                    elif volume > 30:  # Medium volume
                        self.status_value_3.configure(text="Active")
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=self.colors["status_yellow"])
                    else:  # Low/no volume
                        self.status_value_3.configure(text="Listening")
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=self.colors["status_green"])
            else:
                # If no audio data, show no activity
                if hasattr(self, 'synth_bar'):
                    self.synth_bar.update(0)
            
            # Continue animation if recording is still active
            if self.recording_active:
                self.app.after(50, self.animate_level_meter)  # Faster updates for smoother animation
                
        except Exception as e:
            logging.error(f"Error in level meter animation: {str(e)}")
            # Try to continue animation despite error
            if hasattr(self, 'recording_active') and self.recording_active:
                self.app.after(100, self.animate_level_meter)

    def refresh_monitor_visualization(self):
        """Update the system monitor visualization"""
        try:
            # Check if monitor_canvas exists
            if not hasattr(self, 'monitor_canvas'):
                logging.warning("monitor_canvas not initialized yet")
                return

            # Clear previous visualization
            self.monitor_canvas.delete("all")

            # Get system metrics
            import psutil
            cpu_percent = psutil.cpu_percent()
            memory_percent = psutil.virtual_memory().percent
            disk_percent = psutil.disk_usage('/').percent

            # Canvas dimensions
            width = self.monitor_canvas.winfo_width()
            height = self.monitor_canvas.winfo_height()

            # Ensure we have valid dimensions
            if width <= 1 or height <= 1:
                # Canvas not properly sized yet, schedule another update
                self.app.after(1000, self.refresh_monitor_visualization)
                return

            # Bar width and spacing
            bar_width = width / 4
            spacing = width / 12

            # Draw CPU bar
            cpu_color = self.get_resource_color(cpu_percent)
            cpu_height = (cpu_percent / 100) * height
            self.monitor_canvas.create_rectangle(
                spacing, height - cpu_height,
                spacing + bar_width, height,
                fill=cpu_color, outline=""
            )
            self.monitor_canvas.create_text(
                spacing + bar_width / 2, height - cpu_height - 15,
                text=f"CPU\n{cpu_percent}%",
                fill=self.colors["text_bright"],
                font=("Helvetica", 10, "bold"),
                justify="center"
            )

            # Draw Memory bar
            mem_color = self.get_resource_color(memory_percent)
            mem_height = (memory_percent / 100) * height
            self.monitor_canvas.create_rectangle(
                spacing * 2 + bar_width, height - mem_height,
                spacing * 2 + bar_width * 2, height,
                fill=mem_color, outline=""
            )
            self.monitor_canvas.create_text(
                spacing * 2 + bar_width * 1.5, height - mem_height - 15,
                text=f"RAM\n{memory_percent}%",
                fill=self.colors["text_bright"],
                font=("Helvetica", 10, "bold"),
                justify="center"
            )

            # Draw Disk bar
            disk_color = self.get_resource_color(disk_percent)
            disk_height = (disk_percent / 100) * height
            self.monitor_canvas.create_rectangle(
                spacing * 3 + bar_width * 2, height - disk_height,
                spacing * 3 + bar_width * 3, height,
                fill=disk_color, outline=""
            )
            self.monitor_canvas.create_text(
                spacing * 3 + bar_width * 2.5, height - disk_height - 15,
                text=f"Disk\n{disk_percent}%",
                fill=self.colors["text_bright"],
                font=("Helvetica", 10, "bold"),
                justify="center"
            )

            # Schedule next update
            self.app.after(2000, self.refresh_monitor_visualization)

        except Exception as e:
            logging.error(f"Error updating monitor visualization: {str(e)}")
            # Try again later
            self.app.after(5000, self.refresh_monitor_visualization)

    def _update_level_meter(self, volume):
        """Update the microphone level meter visualization"""
        # If we have the new synthesizer bar, use it
        if hasattr(self, 'synth_bar'):
            self.synth_bar.update(volume)
            return

        # Fallback to the old implementation if level_canvas exists
        if not hasattr(self, 'level_canvas'):
            return

        # Clear canvas
        self.level_canvas.delete("all")

        # Get canvas dimensions
        width = self.level_canvas.winfo_width()
        height = self.level_canvas.winfo_height()

        # Ensure we have valid dimensions
        if width <= 1:
            width = 200
        if height <= 1:
            height = 30

        # Draw background/border
        self.level_canvas.create_rectangle(
            0, 0, width, height,
            fill=self.colors["bg_dark"],
            outline=self.colors["bg_medium"],
            width=1
        )

        # Scale volume for better visualization (0-100 range)
        scaled_volume = min(100, volume) / 100

        # Calculate meter width based on volume (0.0 to 1.0)
        meter_width = max(1, min(width - 2, (width - 2) * scaled_volume))

        # Determine color based on level
        if scaled_volume < 0.3:
            color = self.colors["status_green"]  # Green
        elif scaled_volume < 0.7:
            color = self.colors["status_yellow"]  # Yellow
        else:
            color = self.colors["status_red"]  # Red

        # Draw meter with a small margin
        if meter_width > 0:
            self.level_canvas.create_rectangle(
                1, 1, meter_width + 1, height - 1,
                fill=color, outline=""
            )

        # Add level text
        if width > 50:
            self.level_canvas.create_text(
                width / 2, height / 2,
                text=f"{int(volume)}%",
                fill=self.colors["text_bright"],
                font=("Helvetica", 10, "bold")
            )

    def create_status_panel(self, parent):
        """Create a status panel with system information"""
        # Create panel frame
        status_panel = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_medium"],
            corner_radius=15,
            border_width=1,
            border_color=self.colors["bg_light"]
        )

        # Panel header
        status_header = ctk.CTkFrame(
            status_panel, fg_color="transparent", height=50)
        status_header.pack(fill="x", padx=20, pady=(15, 5))

        # Panel title
        status_title = ctk.CTkLabel(
            status_header,
            text="System Status",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        status_title.pack(side="left")

        # Status indicators grid
        status_grid = ctk.CTkFrame(status_panel, fg_color="transparent")
        status_grid.pack(fill="both", expand=True, padx=20, pady=(5, 20))

        # Configure grid
        status_grid.columnconfigure(0, weight=1)
        status_grid.columnconfigure(1, weight=1)
        status_grid.rowconfigure(0, weight=1)
        status_grid.rowconfigure(1, weight=1)

        # Create status indicators
        self.create_status_indicator(
            status_grid,
            "CPU Usage",
            "0%",
            self.colors["status_green"],
            0)
        self.create_status_indicator(
            status_grid,
            "Memory",
            "0%",
            self.colors["status_green"],
            1)
        self.create_status_indicator(
            status_grid,
            "Disk Space",
            "0%",
            self.colors["status_green"],
            2)
        self.create_status_indicator(
            status_grid,
            "Voice Status",
            "Idle",
            self.colors["status_gray"],
            3)

        return status_panel

    def create_status_indicator(self, parent, label, value, color, column):
        """Create a status indicator with label and value"""
        # Calculate row and column based on index
        row = column // 2
        col = column % 2

        # Create indicator frame
        indicator = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10,
            height=60
        )
        indicator.grid(row=row, column=col, sticky="nsew", padx=5, pady=5)
        indicator.pack_propagate(False)

        # Indicator label
        label_widget = ctk.CTkLabel(
            indicator,
            text=label,
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"]
        )
        label_widget.pack(anchor="w", padx=15, pady=(10, 0))

        # Value and status indicator in a row
        value_frame = ctk.CTkFrame(indicator, fg_color="transparent")
        value_frame.pack(fill="x", padx=15, pady=(0, 10))

        # Value label
        value_widget = ctk.CTkLabel(
            value_frame,
            text=value,
            font=self.fonts["subtitle"],
            text_color=self.colors["text_bright"]
        )
        value_widget.pack(side="left")

        # Status indicator
        status_indicator = ctk.CTkFrame(
            value_frame,
            fg_color=color,
            width=15,
            height=15,
            corner_radius=7
        )
        status_indicator.pack(side="right", padx=10)

        # Store references for updating
        setattr(self, f"status_indicator_{column}", status_indicator)
        setattr(self, f"status_value_{column}", value_widget)

        return indicator

    def create_history_tab(self):
        """Create the query history tab."""
        # Main container
        history_frame = ctk.CTkFrame(self.tab_view.tab("History"), fg_color="transparent")
        history_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Create a simple placeholder message
        placeholder = ctk.CTkLabel(
            history_frame,
            text="Voice Command History will be displayed here",
            font=ctk.CTkFont(size=16),
            text_color=self.colors["text_bright"]
        )
        placeholder.pack(pady=50)
        
        # Add a note about the feature
        note = ctk.CTkLabel(
            history_frame,
            text="This feature will be available in a future update",
            font=ctk.CTkFont(size=12),
            text_color=self.colors["text_dim"]
        )
        note.pack()

    def create_config_tab(self):
        """Create the configuration tab content"""
        config_container = ctk.CTkFrame(
            self.tab_view.tab("Configuration"),
            fg_color="transparent"
        )
        config_container.pack(fill="both", expand=True, padx=20, pady=20)

        # Whisper API Settings section
        api_settings = ctk.CTkFrame(
            config_container,
            fg_color=self.colors["bg_dark"],
            corner_radius=15
        )
        api_settings.pack(fill="x", pady=(0, 20))

        # Section header
        header = ctk.CTkLabel(
            api_settings,
            text="Whisper API Settings",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        header.pack(anchor="w", padx=20, pady=(20, 15))

        # Settings grid
        settings_frame = ctk.CTkFrame(api_settings, fg_color="transparent")
        settings_frame.pack(fill="x", padx=20, pady=(0, 20))
        settings_frame.grid_columnconfigure(1, weight=1)

        # API Key
        api_key_label = ctk.CTkLabel(
            settings_frame,
            text="API Key",
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"]
        )
        api_key_label.grid(row=0, column=0, sticky="w", pady=5)

        self.api_key_var = ctk.StringVar(value="j3ydNXEmQFyDKwl5mWxSzcvdZcTLJw1t")
        self.api_key_entry = ctk.CTkEntry(
            settings_frame,
            textvariable=self.api_key_var,
            font=self.fonts["normal"],
            show="•"
        )
        self.api_key_entry.grid(row=0, column=1, sticky="ew", padx=(20, 10), pady=5)

        show_key_button = ctk.CTkButton(
            settings_frame,
            text="👁",
            width=40,
            command=lambda: self.api_key_entry.configure(
                show="" if self.api_key_entry.cget("show") else "•"
            )
        )
        show_key_button.grid(row=0, column=2, pady=5)

        # API Base URL
        base_url_label = ctk.CTkLabel(
            settings_frame,
            text="API Base URL",
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"]
        )
        base_url_label.grid(row=1, column=0, sticky="w", pady=5)

        self.base_url_var = ctk.StringVar(value="https://api.deepinfra.com/v1/openai")
        self.base_url_entry = ctk.CTkEntry(
            settings_frame,
            textvariable=self.base_url_var,
            font=self.fonts["normal"]
        )
        self.base_url_entry.grid(row=1, column=1, columnspan=2, sticky="ew", padx=(20, 0), pady=5)

        # Model selection
        model_label = ctk.CTkLabel(
            settings_frame,
            text="Model",
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"]
        )
        model_label.grid(row=2, column=0, sticky="w", pady=5)

        self.model_var = ctk.StringVar(value="openai/whisper-large-v3")
        model_dropdown = ctk.CTkOptionMenu(
            settings_frame,
            values=["openai/whisper-large-v3"],
            variable=self.model_var,
            font=self.fonts["normal"],
            width=200
        )
        model_dropdown.grid(row=2, column=1, columnspan=2, sticky="ew", padx=(20, 0), pady=5)

        # Language selection
        language_label = ctk.CTkLabel(
            settings_frame,
            text="Language",
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"]
        )
        language_label.grid(row=3, column=0, sticky="w", pady=5)

        self.language_var = ctk.StringVar(value="en - English")
        language_dropdown = ctk.CTkOptionMenu(
            settings_frame,
            values=["en - English"],
            variable=self.language_var,
            font=self.fonts["normal"],
            width=200
        )
        language_dropdown.grid(row=3, column=1, columnspan=2, sticky="ew", padx=(20, 0), pady=5)

        # Response format
        format_label = ctk.CTkLabel(
            settings_frame,
            text="Response Format",
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"]
        )
        format_label.grid(row=4, column=0, sticky="w", pady=5)

        self.format_var = ctk.StringVar(value="verbose_json")
        format_dropdown = ctk.CTkOptionMenu(
            settings_frame,
            values=["verbose_json"],
            variable=self.format_var,
            font=self.fonts["normal"],
            width=200
        )
        format_dropdown.grid(row=4, column=1, columnspan=2, sticky="ew", padx=(20, 0), pady=5)

        # Temperature slider
        temp_label = ctk.CTkLabel(
            settings_frame,
            text="Temperature",
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"]
        )
        temp_label.grid(row=5, column=0, sticky="w", pady=5)

        self.temp_var = ctk.DoubleVar(value=0.0)
        temp_slider = ctk.CTkSlider(
            settings_frame,
            from_=0.0,
            to=1.0,
            variable=self.temp_var
        )
        temp_slider.grid(row=5, column=1, columnspan=2, sticky="ew", padx=(20, 0), pady=5)

        # Timestamp granularity
        timestamp_label = ctk.CTkLabel(
            settings_frame,
            text="Timestamp Granularity",
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"]
        )
        timestamp_label.grid(row=6, column=0, sticky="w", pady=5)

        self.timestamp_var = ctk.StringVar(value="segment")
        timestamp_dropdown = ctk.CTkOptionMenu(
            settings_frame,
            values=["segment"],
            variable=self.timestamp_var,
            font=self.fonts["normal"],
            width=200
        )
        timestamp_dropdown.grid(row=6, column=1, columnspan=2, sticky="ew", padx=(20, 0), pady=5)

        # Buttons frame
        buttons_frame = ctk.CTkFrame(api_settings, fg_color="transparent")
        buttons_frame.pack(fill="x", padx=20, pady=(0, 20))

        # Test Connection button
        test_button = ctk.CTkButton(
            buttons_frame,
            text="Test Connection",
            command=self.test_whisper_connection,
            fg_color=self.colors["accent_secondary"],
            hover_color=self._adjust_color_brightness(self.colors["accent_secondary"], 0.8)
        )
        test_button.pack(side="left")

        # Save Changes button
        save_button = ctk.CTkButton(
            buttons_frame,
            text="Save Changes",
            command=self.save_whisper_config,
            fg_color=self.colors["accent_primary"],
            hover_color=self._adjust_color_brightness(self.colors["accent_primary"], 0.8)
        )
        save_button.pack(side="right")

    def save_whisper_config(self):
        """Save the Whisper API configuration"""
        try:
            # Update config dictionary with new values
            self.config["openai_api_key"] = self.api_key_var.get()
            self.config["whisper_model"] = self.model_var.get()
            self.config["whisper_language"] = self.language_var.get()
            self.config["response_format"] = self.format_var.get()
            self.config["temperature"] = self.temp_var.get()
            self.config["timestamp_granularity"] = self.timestamp_var.get()

            # Save to config file
            with open(self.config_path, "w") as f:
                json.dump(self.config, f, indent=4)

            # Update environment variable for API key
            os.environ["OPENAI_API_KEY"] = self.api_key_var.get()

            # Show success message
            self.update_status("Whisper configuration saved successfully", "info")

        except Exception as e:
            logging.error(f"Error saving Whisper configuration: {str(e)}")
            self.update_status(f"Error saving configuration: {str(e)}", "error")

    def test_whisper_connection(self):
        """Test the Whisper API connection with current settings"""
        try:
            # Create a test dialog
            dialog = ctk.CTkToplevel(self)
            dialog.title("Testing Whisper API Connection")
            dialog.geometry("400x200")
            dialog.transient(self)
            dialog.grab_set()

            # Status label
            status_label = ctk.CTkLabel(
                dialog,
                text="Testing connection...",
                font=self.fonts["normal"],
                text_color=self.colors["text_bright"]
            )
            status_label.pack(pady=20)

            # Progress indicator
            progress = ctk.CTkProgressBar(
                dialog,
                width=300,
                mode="indeterminate"
            )
            progress.pack(pady=20)
            progress.start()
            
            # Store API key in a variable to avoid thread issues
            api_key = self.api_key_var.get()
            
            def update_ui_success():
                """Update UI on successful connection"""
                if not dialog.winfo_exists():
                    return
                status_label.configure(
                    text="Connection successful!\nWhisper API is working properly.",
                    text_color=self.colors["status_green"]
                )
                progress.stop()
                progress.pack_forget()
                
                close_button = ctk.CTkButton(
                    dialog,
                    text="Close",
                    command=dialog.destroy,
                    fg_color=self.colors["accent_primary"]
                )
                close_button.pack(pady=20)

            def update_ui_error(error_msg):
                """Update UI on connection error"""
                if not dialog.winfo_exists():
                    return
                status_label.configure(
                    text=f"Connection failed:\n{error_msg}",
                    text_color=self.colors["status_red"]
                )
                progress.stop()
                progress.pack_forget()
                
                close_button = ctk.CTkButton(
                    dialog,
                    text="Close",
                    command=dialog.destroy,
                    fg_color=self.colors["accent_primary"]
                )
                close_button.pack(pady=20)

            def run_test():
                try:
                    if not api_key:
                        dialog.after(0, lambda: update_ui_error("API key is required"))
                        return

                    # Initialize client with current settings
                    client = OpenAI(api_key=api_key)

                    # Create a small test audio file
                    sample_rate = 16000
                    audio_data = np.zeros(sample_rate)
                    
                    # Save to temporary file
                    with tempfile.NamedTemporaryFile(suffix=".wav", delete=False) as temp_file:
                        sf.write(temp_file.name, audio_data, sample_rate)
                        
                        # Test transcription
                        with open(temp_file.name, "rb") as audio_file:
                            response = client.audio.transcriptions.create(
                                model="whisper-1",  # Use base model for testing
                                file=audio_file,
                                response_format="json"
                            )

                    # Clean up temp file
                    os.unlink(temp_file.name)

                    # Update UI in main thread
                    dialog.after(0, update_ui_success)

                except Exception as e:
                    # Capture the error message
                    error_message = str(e)
                    # Update UI in main thread with the captured error message
                    dialog.after(0, lambda error=error_message: update_ui_error(error))

            # Run test in separate thread
            test_thread = threading.Thread(target=run_test, daemon=True)
            test_thread.start()

        except Exception as e:
            logging.error(f"Error testing Whisper connection: {str(e)}")
            self.update_status(f"Error testing connection: {str(e)}", "error")

    def process_transcription(self):
        """Process the current transcription"""
        try:
            # Get the current transcription text
            self.transcription_display.configure(state="normal")
            transcription = self.transcription_display.get("1.0", "end").strip()
            
            # Skip if it's just the placeholder text
            if transcription == "Transcribed text will appear here...":
                return
                
            # Process the transcription (send to chatbots, execute commands, etc.)
            self.send_to_chatbots(transcription)
            
            # Clear the transcription display after processing
            self.clear_transcription()
            
            # Update status
            self.update_status(f"Processed transcription: {transcription[:30]}...")
            
        except Exception as e:
            logging.error(f"Error processing transcription: {str(e)}")
            self.update_status(f"Error processing transcription: {str(e)}")
        finally:
            self.transcription_display.configure(state="disabled")
            
    def send_to_chatbots(self, text):
        """Send text to the active chatbots"""
        # This is a placeholder for the actual implementation
        logging.info(f"Sending to chatbots: {text}")
        
        # Add to text display as a system message
        self.add_to_text_display(f"Sent to chatbots: {text}", message_type="system")

    def add_to_transcription(self, text, with_timestamp=True):
        """Add text to the transcription display with optional timestamp"""
        try:
            # Enable editing
            self.transcription_display.configure(state="normal")
            
            # Clear placeholder text if present
            current_text = self.transcription_display.get("1.0", "end").strip()
            if current_text == "Transcribed text will appear here...":
                self.transcription_display.delete("1.0", "end")
            
            # Add timestamp if requested
            if with_timestamp:
                timestamp = datetime.now().strftime("%H:%M:%S")
                self.transcription_display.insert("end", f"[{timestamp}] ", "timestamp")
            
            # Add the transcription text
            self.transcription_display.insert("end", f"{text}\n", "transcription")
            
            # Auto-scroll to the end
            self.transcription_display.see("end")
            
            # Enable the Enter button
            self.enter_button.configure(state="normal")
            
        except Exception as e:
            logging.error(f"Error adding to transcription: {str(e)}")
        finally:
            # Disable editing
            self.transcription_display.configure(state="disabled")
            
    def add_to_text_display(self, text, message_type="command"):
        """Add text to the text display with formatting"""
        try:
            # Enable editing
            self.text_display.configure(state="normal")
            
            # Clear placeholder text if present
            current_text = self.text_display.get("1.0", "end").strip()
            if current_text == "Voice commands will appear here after starting the voice assistant...":
                self.text_display.delete("1.0", "end")
            
            # Add timestamp
            timestamp = datetime.now().strftime("%H:%M:%S")
            self.text_display.insert("end", f"[{timestamp}] ", "timestamp")
            
            # Add the text with appropriate tag
            self.text_display.insert("end", f"{text}\n", message_type)
            
            # Auto-scroll to the end
            self.text_display.see("end")
            
        except Exception as e:
            logging.error(f"Error adding to text display: {str(e)}")
        finally:
            # Disable editing
            self.text_display.configure(state="disabled")


def main():
    """Main function to run the application"""
    try:
        # Initialize logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            filename='dragon_gui.log',
            filemode='a'
        )

        # Add console handler
        console = logging.StreamHandler()
        console.setLevel(logging.INFO)
        formatter = logging.Formatter(
            '%(asctime)s - %(levelname)s - %(message)s')
        console.setFormatter(formatter)
        logging.getLogger('').addHandler(console)

        logging.info("Starting DragonVoice application")

        # Initialize Tkinter before creating the app
        root = ctk.CTk()
        root.withdraw()  # Hide the root window

        # Create and run the GUI
        logging.info("Initializing DragonVoiceGUI")
        app = DragonVoiceGUI()

        # Check for required methods
        required_methods = [
            'toggle_voice_assistant',
            'refresh_chatbots',
            'load_config']
        for method in required_methods:
            if not hasattr(app, method):
                logging.error(f"Missing required method: {method}")
                raise AttributeError(
                    f"DragonVoiceGUI is missing required method: {method}")

        logging.info("Starting application main loop")
        app.run()

    except Exception as e:
        logging.error(f"Error running application: {str(e)}", exc_info=True)
        print(f"Error: {str(e)}")

        # Show error in a messagebox if possible
        try:
            import tkinter.messagebox as messagebox
            messagebox.showerror(
                "Dragon Voice Error",
                f"An error occurred:\n{str(e)}")
        except BaseException:
            pass

        # Print traceback for debugging
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main()
