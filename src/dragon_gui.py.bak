#!/usr/bin/env python3
"""
Dragon Voice GUI - Main application interface for Dragon Voice Project
"""

from whisper_integration import WhisperRecognizer
import os
import sys
import json
import time
import logging
import webbrowser
import threading
from datetime import datetime
from pathlib import Path

# GUI libraries
import tkinter as tk
from tkinter import messagebox
import customtkinter as ctk
from PIL import Image, ImageTk

# System monitoring
import psutil
import platform

# Window management
import pygetwindow as gw
import pyautogui
import sounddevice as sd
import numpy as np
import tempfile
import os
import time
import threading

# Custom components
from synthesizer_bar import SynthesizerBar

# Try to import soundfile, but don't fail if it's not available
try:
    import soundfile as sf
    SOUNDFILE_AVAILABLE = True
except ImportError:
    SOUNDFILE_AVAILABLE = False
    print("Warning: soundfile module not found. Some audio features will be limited.")

# Configure logging
logging.basicConfig(
    level=logging.WARNING,  # Changed from INFO to WARNING
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("dragon_gui.log"),
        logging.StreamHandler()
    ]
)

# Constants
DEFAULT_CONFIG_PATH = "src/config.json"
ASSETS_DIR = os.path.join("src", "assets")

# Add Whisper integration


class DragonVoiceGUI:
    """
    Main GUI class for the Dragon Voice Project

    Provides a modern, feature-rich interface for controlling the voice assistant,
    managing chatbots, and configuring system settings.
    """

    def __init__(self, config_path=DEFAULT_CONFIG_PATH):
        """Initialize the DragonVoice GUI application"""
        logging.info("Initializing DragonVoiceGUI")

        try:
            # Initialize logging
            self.setup_logging()

            # Initialize state variables
            self.recording_active = False
            self.continuous_recording = False  # Flag for continuous recording
            self.is_fullscreen = False

            # Create main application window
            self.app = ctk.CTk()
            self.app.title("DragonVoice")
            self.app.geometry("1200x800")
            self.app.minsize(900, 600)

            # Load configuration
            self.config_path = config_path
            self.config = self.load_config()
            logging.info(f"Configuration loaded from {config_path}")

            # Set up theme and colors
            self.setup_theme()

            # Initialize Whisper recognizer
            self.init_whisper_recognizer()

            # Set up UI components
            self.setup_ui()

            # Start system monitoring
            self.start_system_monitoring()

        except Exception as e:
            logging.error(f"Error initializing DragonVoiceGUI: {str(e)}")
            raise

    def setup_logging(self):
        """Set up logging configuration"""
        # Check if logging is already configured
        if not logging.getLogger().handlers:
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - %(message)s'
            )
        logging.info("Logging setup complete")

    def setup_theme(self):
        """Set up the theme and colors for the application"""
        # Set appearance mode
        ctk.set_appearance_mode("dark")

        # Define color schemes with modern, sophisticated palettes
        self.color_schemes = {
            "aurora": {  # New default theme
                "bg_dark": "#1A1B26",      # Deep space blue
                "bg_medium": "#24283B",    # Midnight blue
                "bg_light": "#2F3549",     # Slate blue
                "accent_primary": "#7AA2F7",  # Electric blue
                "accent_secondary": "#BB9AF7",  # Soft purple
                "text_bright": "#C0CAF5",  # Ice blue
                "text_normal": "#9AA5CE",  # Muted blue
                "text_dim": "#565F89",     # Dark slate
                "status_green": "#9ECE6A",  # Sage green
                "status_yellow": "#E0AF68", # Warm amber
                "status_red": "#F7768E",    # Coral pink
                "status_blue": "#7DCFFF",   # Sky blue
                "status_gray": "#414868",   # Steel gray
                "separator": "#1F2335"      # Dark separator
            },
            "quantum": {  # High contrast theme
                "bg_dark": "#151515",      # Deep black
                "bg_medium": "#1E1E1E",    # Rich black
                "bg_light": "#252525",     # Soft black
                "accent_primary": "#00FF9C",  # Neon green
                "accent_secondary": "#00B8FF",  # Electric blue
                "text_bright": "#FFFFFF",   # Pure white
                "text_normal": "#CCCCCC",   # Light gray
                "text_dim": "#808080",      # Medium gray
                "status_green": "#00FF9C",  # Neon green
                "status_yellow": "#FFD700", # Gold
                "status_red": "#FF3366",    # Hot pink
                "status_blue": "#00B8FF",   # Electric blue
                "status_gray": "#404040",   # Dark gray
                "separator": "#333333"      # Dark separator
            },
            "glacier": {  # Light theme
                "bg_dark": "#E8EEF2",      # Ice white
                "bg_medium": "#D5E3EC",    # Glacier blue
                "bg_light": "#C2D8E9",     # Soft blue
                "accent_primary": "#2B7BB9",  # Deep blue
                "accent_secondary": "#5C6BC0",  # Royal blue
                "text_bright": "#1A1A1A",   # Near black
                "text_normal": "#2D2D2D",   # Dark gray
                "text_dim": "#5D5D5D",      # Medium gray
                "status_green": "#2E7D32",  # Forest green
                "status_yellow": "#F9A825", # Sunflower
                "status_red": "#C62828",    # Ruby red
                "status_blue": "#1565C0",   # Ocean blue
                "status_gray": "#90A4AE",   # Cool gray
                "separator": "#B0BEC5"      # Light separator
            }
        }

        # Set default color scheme
        self.colors = self.color_schemes["aurora"]

        # Define modern font system
        self.fonts = {
            "header": ctk.CTkFont(family="Segoe UI", size=32, weight="bold"),
            "title": ctk.CTkFont(family="Segoe UI", size=24, weight="bold"),
            "subtitle": ctk.CTkFont(family="Segoe UI", size=18, weight="bold"),
            "normal": ctk.CTkFont(family="Segoe UI", size=14),
            "small": ctk.CTkFont(family="Segoe UI", size=12),
            "tiny": ctk.CTkFont(family="Segoe UI", size=10),
            "mono": ctk.CTkFont(family="JetBrains Mono", size=12),
            "large": ctk.CTkFont(family="Segoe UI", size=20),
            "display": ctk.CTkFont(family="Segoe UI", size=40, weight="bold"),
            "button": ctk.CTkFont(family="Segoe UI", size=14, weight="bold"),
            "caption": ctk.CTkFont(family="Segoe UI", size=11),
            "code": ctk.CTkFont(family="JetBrains Mono", size=13)
        }

        # Define corner radius system
        self.corners = {
            "small": 4,
            "medium": 8,
            "large": 12,
            "xl": 16,
            "pill": 24
        }

        # Define spacing system
        self.spacing = {
            "xs": 4,
            "small": 8,
            "medium": 16,
            "large": 24,
            "xl": 32,
            "xxl": 48
        }

        # Define shadow system
        self.shadows = {
            "small": "0 2px 4px rgba(0,0,0,0.1)",
            "medium": "0 4px 8px rgba(0,0,0,0.15)",
            "large": "0 8px 16px rgba(0,0,0,0.2)"
        }

        # Animation durations
        self.animations = {
            "fast": 150,
            "normal": 250,
            "slow": 350
        }

    def init_whisper_recognizer(self):
        """Initialize the Whisper recognizer"""
        try:
            # Initialize API keys from environment or config
            self.openai_api_key = os.environ.get("OPENAI_API_KEY", "")
            if not self.openai_api_key and "openai_api_key" in self.config:
                self.openai_api_key = self.config["openai_api_key"]
                os.environ["OPENAI_API_KEY"] = self.openai_api_key

            # Initialize WhisperRecognizer with error handling
            if self.openai_api_key:
                self.whisper_recognizer = WhisperRecognizer(
                    api_key=self.openai_api_key)
                logging.info("WhisperRecognizer initialized successfully")
            else:
                logging.warning(
                    "No OpenAI API key found, WhisperRecognizer not initialized")
                self.whisper_recognizer = None
        except Exception as e:
            logging.error(f"Failed to initialize WhisperRecognizer: {str(e)}")
            self.whisper_recognizer = None

    def setup_ui(self):
        """Set up the main user interface"""
        try:
            # Create main container
            self.main_container = ctk.CTkFrame(self.app)
            self.main_container.pack(fill="both", expand=True)
            
            # Configure grid
            self.main_container.grid_columnconfigure(0, weight=1)
            self.main_container.grid_rowconfigure(1, weight=1)  # Content area expands
            
            # Create UI sections
            self.create_header()      # Row 0
            self.create_content()     # Row 1
            self.create_footer()      # Row 2
            
            # Start system monitoring
            self.start_system_monitoring()
            
            # Initial status update
            self.update_status("Ready")
            
        except Exception as e:
            logging.error(f"Error setting up UI: {str(e)}", exc_info=True)
            raise  # Re-raise the exception for proper error handling

    def create_content(self):
        """Create the main content area with tabs"""
        # Create content frame
        self.content_frame = ctk.CTkFrame(self.main_container, fg_color="transparent")
        self.content_frame.grid(row=1, column=0, sticky="nsew", padx=20, pady=10)
        
        # Configure content frame grid
        self.content_frame.grid_rowconfigure(0, weight=1)
        self.content_frame.grid_columnconfigure(0, weight=1)
        
        # Create tab view
        self.tab_view = ctk.CTkTabview(
            self.content_frame,
            fg_color=self.colors["bg_dark"],
            segmented_button_fg_color=self.colors["bg_medium"],
            segmented_button_selected_color=self.colors["accent_primary"],
            segmented_button_selected_hover_color=self.colors["accent_secondary"],
            segmented_button_unselected_color=self.colors["bg_medium"],
            segmented_button_unselected_hover_color=self.colors["bg_light"]
        )
        self.tab_view.grid(row=0, column=0, sticky="nsew")
        
        # Define tabs with icons
        tabs = [
            ("Dashboard", "üìä"),
            ("Chatbots", "ü§ñ"),
            ("History", "üìú"),
            ("Configuration", "‚öôÔ∏è"),
            ("About", "‚ÑπÔ∏è")
        ]
        
        # Add tabs
        for tab_name, icon in tabs:
            self.tab_view.add(tab_name)
            tab = self.tab_view.tab(tab_name)
            tab.configure(fg_color=self.colors["bg_dark"])
            
            # Configure tab grid
            tab.grid_rowconfigure(0, weight=1)
            tab.grid_columnconfigure(0, weight=1)
            
            # Add icon to tab button
            if hasattr(self.tab_view, "_segmented_button"):
                button = self.tab_view._segmented_button
                button._buttons_dict[tab_name].configure(
                    text=f"{icon} {tab_name}",
                    font=self.fonts["button"],
                    height=32,
                    corner_radius=self.corners["medium"]
                )
        
        # Set default tab
        self.tab_view.set("Dashboard")
        
        # Create tab contents
        self.create_dashboard_tab()
        self.create_chatbots_tab()
        self.create_history_tab()
        self.create_config_tab()
        self.create_about_tab()

    def create_header(self):
        """Create the application header"""
        # Create header frame
        self.header_frame = ctk.CTkFrame(
            self.main_container,
            fg_color=self.colors["bg_dark"],
            height=80
        )
        self.header_frame.grid(row=0, column=0, sticky="ew")
        self.header_frame.grid_propagate(False)
        
        # Configure header grid
        self.header_frame.grid_columnconfigure(1, weight=1)  # Center section expands
        
        # Left section - Logo and title
        left_section = ctk.CTkFrame(self.header_frame, fg_color="transparent")
        left_section.grid(row=0, column=0, padx=20, pady=10, sticky="w")
        
        # Try to load logo
        try:
            assets_dir = os.path.join("src", "assets")
            logo_path = os.path.join(assets_dir, "dragon_logo.png")
            
            # Create assets directory if it doesn't exist
            if not os.path.exists(assets_dir):
                os.makedirs(assets_dir)
                logging.warning(f"Created missing assets directory: {assets_dir}")
            
            if os.path.exists(logo_path):
                logo_image = ctk.CTkImage(
                    light_image=Image.open(logo_path),
                    dark_image=Image.open(logo_path),
                    size=(36, 36)
                )
                logo_label = ctk.CTkLabel(
                    left_section,
                    image=logo_image,
                    text=""
                )
                logo_label.pack(side="left", padx=(0, 10))
            else:
                # Create text-based logo as fallback
                logo_label = ctk.CTkLabel(
                    left_section,
                    text="üêâ",
                    font=("Segoe UI Emoji", 24),
                    text_color=self.colors["accent_primary"]
                )
                logo_label.pack(side="left", padx=(0, 10))
                logging.warning(f"Logo file not found: {logo_path}, using emoji fallback")
        except Exception as e:
            logging.error(f"Failed to load logo: {str(e)}")
            # Create text-based logo as fallback
            logo_label = ctk.CTkLabel(
                left_section,
                text="üêâ",
                font=("Segoe UI Emoji", 24),
                text_color=self.colors["accent_primary"]
            )
            logo_label.pack(side="left", padx=(0, 10))
        
        # App title
        title_label = ctk.CTkLabel(
            left_section,
            text="DragonVoice",
            font=self.fonts["header"],
            text_color=self.colors["text_bright"]
        )
        title_label.pack(side="left")
        
        # Version pill
        version_pill = ctk.CTkFrame(
            left_section,
            fg_color=self.colors["accent_primary"],
            corner_radius=self.corners["pill"]
        )
        version_pill.pack(side="left", padx=10)
        
        version_label = ctk.CTkLabel(
            version_pill,
            text="v2.0",
            font=self.fonts["caption"],
            text_color=self.colors["text_bright"]
        )
        version_label.pack(padx=10, pady=2)
        
        # Center section - Status
        center_section = ctk.CTkFrame(self.header_frame, fg_color="transparent")
        center_section.grid(row=0, column=1, sticky="ew")
        
        # Right section - Controls
        right_section = ctk.CTkFrame(self.header_frame, fg_color="transparent")
        right_section.grid(row=0, column=2, padx=20, pady=10, sticky="e")
        
        # Microphone selector
        mic_frame = ctk.CTkFrame(
            right_section,
            fg_color=self.colors["bg_light"],
            corner_radius=self.corners["medium"]
        )
        mic_frame.pack(side="left", padx=(0, 10))
        
        mic_label = ctk.CTkLabel(
            mic_frame,
            text="üé§",
            font=self.fonts["normal"]
        )
        mic_label.pack(side="left", padx=10, pady=5)
        
        self.mic_var = ctk.StringVar(value="Default Microphone")
        self.mic_dropdown = ctk.CTkOptionMenu(
            mic_frame,
            values=["Default Microphone"],
            variable=self.mic_var,
            width=140,
            dynamic_resizing=True
        )
        self.mic_dropdown.pack(side="left", padx=(0, 10), pady=5)
        
        # Control buttons
        for icon, command in [
            ("üé®", self.toggle_theme),
            ("‚öôÔ∏è", self.show_settings),
            ("‚ùî", self.show_help)
        ]:
            btn = ctk.CTkButton(
                right_section,
                text=icon,
                width=34,
                height=34,
                corner_radius=self.corners["medium"],
                fg_color=self.colors["bg_light"],
                hover_color=self.colors["accent_primary"],
                command=command
            )
            btn.pack(side="left", padx=5)

    def create_footer(self):
        """Create the application footer"""
        # Create footer frame
        self.footer = ctk.CTkFrame(
            self.main_container,
            fg_color=self.colors["bg_dark"],
            height=28
        )
        self.footer.grid(row=2, column=0, sticky="ew")
        self.footer.grid_propagate(False)
        
        # Configure footer grid
        self.footer.grid_columnconfigure(1, weight=1)  # Center section expands
        
        # Left section - Status
        status_frame = ctk.CTkFrame(self.footer, fg_color="transparent")
        status_frame.grid(row=0, column=0, padx=20, sticky="w")
        
        self.status_dot = ctk.CTkLabel(
            status_frame,
            text="‚óè",
            font=self.fonts["small"],
            text_color=self.colors["status_green"],
            width=20
        )
        self.status_dot.pack(side="left")
        
        self.status_label = ctk.CTkLabel(
            status_frame,
            text="Ready",
            font=self.fonts["caption"],
            text_color=self.colors["text_dim"]
        )
        self.status_label.pack(side="left", padx=5)
        
        # Center section - System metrics
        metrics_frame = ctk.CTkFrame(self.footer, fg_color="transparent")
        metrics_frame.grid(row=0, column=1, sticky="ew")
        
        metrics = [
            ("CPU", "0%", self.colors["status_green"]),
            ("RAM", "0%", self.colors["status_green"]),
            ("Disk", "0%", self.colors["status_green"])
        ]
        
        for i, (label, value, color) in enumerate(metrics):
            metric_frame = ctk.CTkFrame(metrics_frame, fg_color="transparent")
            metric_frame.pack(side="left", padx=20)
            
            ctk.CTkLabel(
                metric_frame,
                text=label,
                font=self.fonts["caption"],
                text_color=self.colors["text_dim"]
            ).pack(side="left")
            
            value_label = ctk.CTkLabel(
                metric_frame,
                text=value,
                font=self.fonts["caption"],
                text_color=color
            )
            value_label.pack(side="left", padx=5)
            setattr(self, f'metric_value_{i}', value_label)
        
        # Right section - Build info
        build_frame = ctk.CTkFrame(self.footer, fg_color="transparent")
        build_frame.grid(row=0, column=2, padx=20, sticky="e")
        
        build_label = ctk.CTkLabel(
            build_frame,
            text="Build 2024.03",
            font=self.fonts["caption"],
            text_color=self.colors["text_dim"]
        )
        build_label.pack()

    def create_dashboard_tab(self):
        """Create the dashboard tab content"""
        dashboard = self.tab_view.tab("Dashboard")
        
        # Configure grid
        dashboard.grid_columnconfigure(0, weight=2)  # Status panel
        dashboard.grid_columnconfigure(1, weight=1)  # Control panel
        dashboard.grid_rowconfigure(1, weight=1)     # Voice commands section
        dashboard.grid_rowconfigure(2, weight=1)     # Transcription section
        
        # Status panel (top left)
        status_panel = ctk.CTkFrame(
            dashboard,
            fg_color=self.colors["bg_medium"],
            corner_radius=15
        )
        status_panel.grid(row=0, column=0, sticky="nsew", padx=(20, 10), pady=(20, 10))
        
        # Status panel title
        status_title = ctk.CTkLabel(
            status_panel,
            text="System Status",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        status_title.pack(anchor="w", padx=20, pady=(15, 10))
        
        # Status indicators grid
        indicators_frame = ctk.CTkFrame(status_panel, fg_color="transparent")
        indicators_frame.pack(fill="both", expand=True, padx=20, pady=(0, 20))
        
        # Configure indicators grid
        indicators_frame.columnconfigure((0, 1), weight=1)
        indicators_frame.rowconfigure((0, 1), weight=1)
        
        # Create status indicators
        self.create_status_indicator(indicators_frame, "CPU Usage", "0%", self.colors["status_green"], 0, 0)
        self.create_status_indicator(indicators_frame, "Memory", "0%", self.colors["status_green"], 0, 1)
        self.create_status_indicator(indicators_frame, "Disk Space", "0%", self.colors["status_green"], 1, 0)
        self.create_status_indicator(indicators_frame, "Voice Status", "Idle", self.colors["status_gray"], 1, 1)
        
        # Voice assistant control panel (top right)
        control_panel = ctk.CTkFrame(
            dashboard,
            fg_color=self.colors["bg_medium"],
            corner_radius=15
        )
        control_panel.grid(row=0, column=1, sticky="nsew", padx=(10, 20), pady=(20, 10))
        
        # Control panel title
        control_title = ctk.CTkLabel(
            control_panel,
            text="Voice Assistant",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        control_title.pack(anchor="w", padx=20, pady=(15, 10))
        
        # Start/Stop button
        self.toggle_button = ctk.CTkButton(
            control_panel,
            text="Start Voice Assistant",
            command=self.toggle_voice_assistant,
            fg_color=self.colors["status_green"],
            hover_color=self._adjust_color_brightness(self.colors["status_green"], 0.8),
            height=50,
            corner_radius=10,
            font=self.fonts["subtitle"]
        )
        self.toggle_button.pack(fill="x", padx=20, pady=10)
        
        # Recording buttons frame
        recording_frame = ctk.CTkFrame(control_panel, fg_color="transparent")
        recording_frame.pack(fill="x", padx=20, pady=5)
        
        # Configure recording frame grid
        recording_frame.columnconfigure((0, 1), weight=1)
        
        # Record button
        self.record_button = ctk.CTkButton(
            recording_frame,
            text="Record",
            command=self.start_manual_recording,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            height=40
        )
        self.record_button.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        
        # Stop Recording button
        self.stop_record_button = ctk.CTkButton(
            recording_frame,
            text="Stop Recording",
            command=self.stop_manual_recording,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            height=40,
            state="disabled"
        )
        self.stop_record_button.grid(row=0, column=1, sticky="ew", padx=(5, 0))
        
        # Add synthesizer bar
        self.synth_bar = SynthesizerBar(control_panel, self.colors, self.fonts)
        
        # Voice commands section (middle)
        commands_frame = ctk.CTkFrame(
            dashboard,
            fg_color=self.colors["bg_medium"],
            corner_radius=15
        )
        commands_frame.grid(row=1, column=0, columnspan=2, sticky="nsew", padx=20, pady=10)
        
        # Commands title with clear button
        commands_header = ctk.CTkFrame(commands_frame, fg_color="transparent")
        commands_header.pack(fill="x", padx=20, pady=(15, 10))
        
        commands_title = ctk.CTkLabel(
            commands_header,
            text="Voice Commands",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        commands_title.pack(side="left")
        
        clear_commands = ctk.CTkButton(
            commands_header,
            text="Clear",
            command=lambda: self.clear_text_display("text_display"),
            width=80,
            fg_color=self.colors["accent_secondary"]
        )
        clear_commands.pack(side="right")
        
        # Commands text display
        self.text_display = ctk.CTkTextbox(
            commands_frame,
            fg_color=self.colors["bg_light"],
            text_color=self.colors["text_bright"],
            font=self.fonts["normal"],
            corner_radius=10,
            height=120
        )
        self.text_display.pack(fill="both", expand=True, padx=20, pady=(5, 15))
        
        # Configure text tags
        self.text_display._textbox.tag_configure("timestamp", foreground=self.colors["accent_secondary"])
        self.text_display._textbox.tag_configure("command", foreground=self.colors["text_bright"])
        self.text_display._textbox.tag_configure("system", foreground=self.colors["status_blue"])
        
        # Transcription section (bottom)
        transcription_frame = ctk.CTkFrame(
            dashboard,
            fg_color=self.colors["bg_medium"],
            corner_radius=15
        )
        transcription_frame.grid(row=2, column=0, columnspan=2, sticky="nsew", padx=20, pady=(10, 20))
        
        # Transcription header
        transcription_header = ctk.CTkFrame(transcription_frame, fg_color="transparent")
        transcription_header.pack(fill="x", padx=20, pady=(15, 10))
        
        transcription_title = ctk.CTkLabel(
            transcription_header,
            text="Transcribed Text",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        transcription_title.pack(side="left")
        
        clear_transcription = ctk.CTkButton(
            transcription_header,
            text="Clear",
            command=lambda: self.clear_text_display("transcription_display"),
            width=80,
            fg_color=self.colors["accent_secondary"]
        )
        clear_transcription.pack(side="right")
        
        # Transcription display
        self.transcription_display = ctk.CTkTextbox(
            transcription_frame,
            fg_color=self.colors["bg_light"],
            text_color=self.colors["text_bright"],
            font=self.fonts["normal"],
            corner_radius=10,
            height=100
        )
        self.transcription_display.pack(fill="both", expand=True, padx=20, pady=(5, 10))
        
        # Enter button frame
        enter_frame = ctk.CTkFrame(transcription_frame, fg_color="transparent")
        enter_frame.pack(fill="x", padx=20, pady=(0, 15))
        
        # Enter button
        self.enter_button = ctk.CTkButton(
            enter_frame,
            text="Enter",
            command=self.process_transcription,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            height=40,
            state="disabled"
        )
        self.enter_button.pack(side="right")

    def create_status_indicator(self, parent, label, value, color, row, column):
        """Create a status indicator with label and value"""
        # Create indicator frame
        indicator = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )
        indicator.grid(row=row, column=column, padx=5, pady=5, sticky="nsew")

        # Label
        label_widget = ctk.CTkLabel(
            indicator,
            text=label,
            font=self.fonts["small"],
            text_color=self.colors["text_dim"]
        )
        label_widget.pack(pady=(10, 0))

        # Value
        value_widget = ctk.CTkLabel(
            indicator,
            text=value,
            font=self.fonts["large"],
            text_color=color
        )
        value_widget.pack(pady=(5, 10))

        return indicator

    def create_chatbots_tab(self):
        """Create the chatbots tab content"""
        chatbots = self.tab_view.tab("Chatbots")
        
        # Configure grid
        chatbots.grid_columnconfigure(0, weight=1)
        chatbots.grid_rowconfigure(0, weight=1)
        
        # Create chatbots container
        chatbots_container = ctk.CTkScrollableFrame(
            chatbots,
            fg_color="transparent"
        )
        chatbots_container.grid(row=0, column=0, sticky="nsew", padx=20, pady=10)
        
        # Configure chatbots container grid
        chatbots_container.grid_columnconfigure(0, weight=1)
        
        # Add chatbots
        chatbots_data = [
            {"name": "Chatbot 1", "description": "Description 1", "status": "Online"},
            {"name": "Chatbot 2", "description": "Description 2", "status": "Offline"},
            {"name": "Chatbot 3", "description": "Description 3", "status": "Online"},
            {"name": "Chatbot 4", "description": "Description 4", "status": "Offline"},
            {"name": "Chatbot 5", "description": "Description 5", "status": "Online"},
            {"name": "Chatbot 6", "description": "Description 6", "status": "Offline"},
            {"name": "Chatbot 7", "description": "Description 7", "status": "Online"},
            {"name": "Chatbot 8", "description": "Description 8", "status": "Offline"},
            {"name": "Chatbot 9", "description": "Description 9", "status": "Online"},
            {"name": "Chatbot 10", "description": "Description 10", "status": "Offline"}
        ]
        
        for i, data in enumerate(chatbots_data):
            chatbot_frame = ctk.CTkFrame(
                chatbots_container,
                fg_color=self.colors["bg_medium"],
                corner_radius=10
            )
            chatbot_frame.grid(row=i, column=0, sticky="ew", padx=10, pady=10)
            
            # Chatbot name
            name_label = ctk.CTkLabel(
                chatbot_frame,
                text=data["name"],
                font=self.fonts["title"],
                text_color=self.colors["text_bright"]
            )
            name_label.pack(anchor="w", padx=20, pady=(15, 5))
            
            # Chatbot description
            desc_label = ctk.CTkLabel(
                chatbot_frame,
                text=data["description"],
                font=self.fonts["normal"],
                text_color=self.colors["text_normal"]
            )
            desc_label.pack(anchor="w", padx=20, pady=(0, 10))
            
            # Chatbot status
            status_label = ctk.CTkLabel(
                chatbot_frame,
                text=f"Status: {data['status']}",
                font=self.fonts["small"],
                text_color=self.colors["text_dim"]
            )
            status_label.pack(anchor="w", padx=20, pady=(0, 15))
            
            # Chatbot actions
            actions_frame = ctk.CTkFrame(chatbot_frame, fg_color="transparent")
            actions_frame.pack(fill="x", padx=20, pady=(0, 15))
            
            # Configure actions frame grid
            actions_frame.columnconfigure((0, 1), weight=1)
            
            # Action buttons
            for text, command in [
                ("Connect", self.connect_chatbot),
                ("Disconnect", self.disconnect_chatbot),
                ("Settings", self.show_chatbot_settings)
            ]:
                btn = ctk.CTkButton(
                    actions_frame,
                    text=text,
                    command=command,
                    fg_color=self.colors["accent_primary"],
                    hover_color=self.colors["accent_secondary"],
                    height=30
                )
                btn.grid(row=0, column=0, padx=5, pady=5)

    def create_history_tab(self):
        """Create the history tab content"""
        history = self.tab_view.tab("History")
        
        # Configure grid
        history.grid_columnconfigure(0, weight=1)
        history.grid_rowconfigure(0, weight=1)
        
        # Create history container
        history_container = ctk.CTkScrollableFrame(
            history,
            fg_color="transparent"
        )
        history_container.grid(row=0, column=0, sticky="nsew", padx=20, pady=10)
        
        # Configure history container grid
        history_container.grid_columnconfigure(0, weight=1)
        
        # Add history items
        history_data = [
            {"timestamp": "2023-03-12 10:30:00", "command": "Command 1", "response": "Response 1"},
            {"timestamp": "2023-03-12 10:35:00", "command": "Command 2", "response": "Response 2"},
            {"timestamp": "2023-03-12 10:40:00", "command": "Command 3", "response": "Response 3"},
            {"timestamp": "2023-03-12 10:45:00", "command": "Command 4", "response": "Response 4"},
            {"timestamp": "2023-03-12 10:50:00", "command": "Command 5", "response": "Response 5"},
            {"timestamp": "2023-03-12 10:55:00", "command": "Command 6", "response": "Response 6"},
            {"timestamp": "2023-03-12 11:00:00", "command": "Command 7", "response": "Response 7"},
            {"timestamp": "2023-03-12 11:05:00", "command": "Command 8", "response": "Response 8"},
            {"timestamp": "2023-03-12 11:10:00", "command": "Command 9", "response": "Response 9"},
            {"timestamp": "2023-03-12 11:15:00", "command": "Command 10", "response": "Response 10"}
        ]
        
        for i, data in enumerate(history_data):
            item_frame = ctk.CTkFrame(
                history_container,
                fg_color=self.colors["bg_medium"],
                corner_radius=10
            )
            item_frame.grid(row=i, column=0, sticky="ew", padx=10, pady=10)
            
            # Timestamp
            timestamp_label = ctk.CTkLabel(
                item_frame,
                text=data["timestamp"],
                font=self.fonts["small"],
                text_color=self.colors["text_dim"]
            )
            timestamp_label.pack(anchor="w", padx=20, pady=(10, 5))
            
            # Command
            command_label = ctk.CTkLabel(
                item_frame,
                text=data["command"],
                font=self.fonts["normal"],
                text_color=self.colors["text_normal"]
            )
            command_label.pack(anchor="w", padx=20, pady=(0, 5))
            
            # Response
            response_label = ctk.CTkLabel(
                item_frame,
                text=data["response"],
                font=self.fonts["normal"],
                text_color=self.colors["text_bright"]
            )
            response_label.pack(anchor="w", padx=20, pady=(0, 10))

    def create_config_tab(self):
        """Create the configuration tab content"""
        config = self.tab_view.tab("Configuration")
        
        # Configure grid
        config.grid_columnconfigure(0, weight=1)
        config.grid_rowconfigure(0, weight=1)
        
        # Create config container
        config_container = ctk.CTkScrollableFrame(
            config,
            fg_color="transparent"
        )
        config_container.grid(row=0, column=0, sticky="nsew", padx=20, pady=10)
        
        # Configure config container grid
        config_container.grid_columnconfigure(0, weight=1)
        
        # Add config sections
        sections = [
            {"title": "General", "options": [
                {"label": "Option 1", "type": "switch", "value": True},
                {"label": "Option 2", "type": "slider", "value": 50},
                {"label": "Option 3", "type": "entry", "value": "Value 3"},
                {"label": "Option 4", "type": "dropdown", "values": ["Option A", "Option B", "Option C"], "value": "Option A"}
            ]},
            {"title": "Audio", "options": [
                {"label": "Option 1", "type": "switch", "value": False},
                {"label": "Option 2", "type": "slider", "value": 75},
                {"label": "Option 3", "type": "entry", "value": "Value 3"},
                {"label": "Option 4", "type": "dropdown", "values": ["Option X", "Option Y", "Option Z"], "value": "Option X"}
            ]},
            {"title": "Interface", "options": [
                {"label": "Option 1", "type": "switch", "value": True},
                {"label": "Option 2", "type": "slider", "value": 25},
                {"label": "Option 3", "type": "entry", "value": "Value 3"},
                {"label": "Option 4", "type": "dropdown", "values": ["Option 1", "Option 2", "Option 3"], "value": "Option 1"}
            ]}
        ]
        
        for section in sections:
            section_frame = ctk.CTkFrame(
                config_container,
                fg_color=self.colors["bg_medium"],
                corner_radius=10
            )
            section_frame.pack(fill="x", padx=10, pady=10)
            
            # Section title
            title_label = ctk.CTkLabel(
                section_frame,
                text=section["title"],
                font=self.fonts["title"],
                text_color=self.colors["text_bright"]
            )
            title_label.pack(anchor="w", padx=20, pady=(15, 5))
            
            # Section options
            for option in section["options"]:
                option_frame = ctk.CTkFrame(
                    section_frame,
                    fg_color="transparent"
                )
                option_frame.pack(fill="x", padx=20, pady=5)
                
                # Option label
                label = ctk.CTkLabel(
                    option_frame,
                    text=option["label"],
                    font=self.fonts["normal"],
                    text_color=self.colors["text_normal"]
                )
                label.pack(side="left", padx=(0, 10))
                
                # Option widget
                if option["type"] == "switch":
                    var = ctk.BooleanVar(value=option["value"])
                    widget = ctk.CTkSwitch(
                        option_frame,
                        text="",
                        variable=var,
                        fg_color=self.colors["accent_primary"],
                        progress_color=self.colors["accent_secondary"]
                    )
                elif option["type"] == "slider":
                    var = ctk.DoubleVar(value=option["value"])
                    widget = ctk.CTkSlider(
                        option_frame,
                        from_=0,
                        to=100,
                        number_of_steps=100,
                        variable=var,
                        button_color=self.colors["accent_primary"],
                        button_hover_color=self.colors["accent_secondary"]
                    )
                elif option["type"] == "entry":
                    var = ctk.StringVar(value=option["value"])
                    widget = ctk.CTkEntry(
                        option_frame,
                        textvariable=var,
                        fg_color=self.colors["bg_light"],
                        text_color=self.colors["text_bright"],
                        font=self.fonts["normal"],
                        corner_radius=10
                    )
                elif option["type"] == "dropdown":
                    var = ctk.StringVar(value=option["value"])
                    widget = ctk.CTkOptionMenu(
                        option_frame,
                        values=option["values"],
                        variable=var,
                        fg_color=self.colors["bg_light"],
                        text_color=self.colors["text_bright"],
                        font=self.fonts["normal"],
                        corner_radius=10,
                        dropdown_fg_color=self.colors["bg_medium"],
                        dropdown_text_color=self.colors["text_normal"],
                        dropdown_hover_color=self.colors["accent_primary"]
                    )
                widget.pack(side="right", fill="x", expand=True)
                
                # Apply changes immediately
                widget.bind("<ButtonRelease>", lambda event, var=var: self.apply_config_changes(var))

    def create_about_tab(self):
        """Create the about tab content"""
        about = self.tab_view.tab("About")
        
        # Configure grid
        about.grid_columnconfigure(0, weight=1)
        about.grid_rowconfigure(0, weight=1)
        
        # Create about container
        about_container = ctk.CTkScrollableFrame(
            about,
            fg_color="transparent"
        )
        about_container.grid(row=0, column=0, sticky="nsew", padx=20, pady=10)
        
        # Configure about container grid
        about_container.grid_columnconfigure(0, weight=1)
        
        # Add about content
        about_text = """
        Dragon Voice Project
        ====================

        Version: 2.0
        Author: Your Name
        Date: March 12, 2023

        Description:
        Dragon Voice is a powerful voice assistant project that leverages advanced AI technologies to provide a seamless and intuitive user experience. It offers a range of features, including voice recognition, natural language processing, and integration with various chatbots.

        Features:
        - Voice recognition and transcription using Whisper API
        - Natural language processing for understanding and generating responses
        - Integration with multiple chatbots for a personalized experience
        - Real-time system monitoring and resource management
        - Modern and customizable user interface
        - Extensive configuration options for customization
        - Detailed logging and error handling

        Technologies Used:
        - Python
        - CustomTkinter
        - OpenAI Whisper API
        - PyAudio
        - SoundFile
        - NumPy
        - PyGetWindow
        - PyAutoGUI
        - Pillow
        - Requests
        - Webbrowser
        - Threading
        - Logging
        - JSON
        - OS
        - Platform
        - PSUtil
        - Datetime
        - Time
        - Pathlib
        - Tempfile

        Credits:
        - OpenAI for the Whisper API
        - The CustomTkinter community for the library
        - The Python community for the vast array of open-source libraries

        License:
        This project is licensed under the MIT License.

        Contact:
        For any inquiries or support, please contact us at support@dragonvoice.com.

        Website:
        https://www.dragonvoice.com
        """
        
        about_label = ctk.CTkLabel(
            about_container,
            text=about_text,
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"],
            justify="left"
        )
        about_label.pack(anchor="w", padx=20, pady=20)

    def start_system_monitoring(self):
        """Start system monitoring in a separate thread"""
        self.system_monitor_thread = threading.Thread(
            target=self.system_monitor_loop,
            daemon=True
        )
        self.system_monitor_thread.start()

    def system_monitor_loop(self):
        """Continuously update system metrics"""
        while True:
            # Get system metrics
            cpu_percent = psutil.cpu_percent(interval=1)
            ram_percent = psutil.virtual_memory().percent
            disk_percent = psutil.disk_usage("/").percent
            
            # Update UI
            self.update_system_metrics(cpu_percent, ram_percent, disk_percent)
            
            # Sleep for a short duration
            time.sleep(1)

    def update_system_metrics(self, cpu_percent, ram_percent, disk_percent):
        """Update system metrics in the UI"""
        # Update CPU metric
        self.metric_value_0.configure(text=f"{cpu_percent}%")
        self.metric_value_0.configure(text_color=self.get_metric_color(cpu_percent))
        
        # Update RAM metric
        self.metric_value_1.configure(text=f"{ram_percent}%")
        self.metric_value_1.configure(text_color=self.get_metric_color(ram_percent))
        
        # Update Disk metric
        self.metric_value_2.configure(text=f"{disk_percent}%")
        self.metric_value_2.configure(text_color=self.get_metric_color(disk_percent))

    def get_metric_color(self, value):
        """Get the color for a metric value based on its severity"""
        if value < 50:
            return self.colors["status_green"]
        elif value < 80:
            return self.colors["status_yellow"]
        else:
            return self.colors["status_red"]

    def update_status(self, status):
        """Update the status label and dot"""
        self.status_label.configure(text=status)
        self.status_dot.configure(text_color=self.get_status_color(status))

    def get_status_color(self, status):
        """Get the color for a status based on its type"""
        if status == "Ready":
            return self.colors["status_green"]
        elif status == "Recording":
            return self.colors["status_red"]
        elif status == "Processing":
            return self.colors["status_yellow"]
        elif status == "Error":
            return self.colors["status_red"]
        else:
            return self.colors["text_dim"]

    def toggle_theme(self):
        """Toggle the application theme between light and dark modes"""
        ctk.set_appearance_mode("dark" if ctk.get_appearance_mode() == "light" else "light")

    def show_settings(self):
        """Show the settings dialog"""
        messagebox.showinfo("Settings", "Settings dialog not implemented yet")

    def show_help(self):
        """Show the help dialog"""
        messagebox.showinfo("Help", "Help dialog not implemented yet")

    def toggle_voice_assistant(self):
        """Toggle the voice assistant on/off"""
        if self.recording_active:
            self.stop_voice_assistant()
        else:
            self.start_voice_assistant()

    def start_voice_assistant(self):
        """Start the voice assistant"""
        self.recording_active = True
        self.update_status("Recording")
        self.voice_assistant_button.configure(
            text="Stop Voice Assistant",
            fg_color=self.colors["status_red"]
        )
        
        # Start continuous recording
        self.continuous_recording = True
        self.start_continuous_recording()

    def stop_voice_assistant(self):
        """Stop the voice assistant"""
        self.recording_active = False
#!/usr/bin/env python3
"""
Dragon Voice GUI - Main application interface for Dragon Voice Project
"""

from whisper_integration import WhisperRecognizer
import os
import sys
import json
import time
import logging
import webbrowser
import threading
from datetime import datetime
from pathlib import Path

# GUI libraries
import tkinter as tk
from tkinter import messagebox
import customtkinter as ctk
from PIL import Image, ImageTk

# System monitoring
import psutil
import platform

# Window management
import pygetwindow as gw
import pyautogui
import sounddevice as sd
import numpy as np
import tempfile
import os
import time
import threading

# Custom components
from synthesizer_bar import SynthesizerBar

# Try to import soundfile, but don't fail if it's not available
try:
    import soundfile as sf
    SOUNDFILE_AVAILABLE = True
except ImportError:
    SOUNDFILE_AVAILABLE = False
    print("Warning: soundfile module not found. Some audio features will be limited.")

# Configure logging
logging.basicConfig(
    level=logging.WARNING,  # Changed from INFO to WARNING
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("dragon_gui.log"),
        logging.StreamHandler()
    ]
)

# Constants
DEFAULT_CONFIG_PATH = "src/config.json"
ASSETS_DIR = os.path.join("src", "assets")

# Add Whisper integration


class DragonVoiceGUI:
    """
    Main GUI class for the Dragon Voice Project

    Provides a modern, feature-rich interface for controlling the voice assistant,
    managing chatbots, and configuring system settings.
    """

    def __init__(self, config_path=DEFAULT_CONFIG_PATH):
        """Initialize the DragonVoice GUI application"""
        logging.info("Initializing DragonVoiceGUI")

        try:
            # Initialize logging
            self.setup_logging()

            # Initialize state variables
            self.recording_active = False
            self.continuous_recording = False  # Flag for continuous recording
            self.is_fullscreen = False

            # Create main application window
            self.app = ctk.CTk()
            self.app.title("DragonVoice")
            self.app.geometry("1200x800")
            self.app.minsize(900, 600)

            # Load configuration
            self.config_path = config_path
            self.config = self.load_config()
            logging.info(f"Configuration loaded from {config_path}")

            # Set up theme and colors
            self.setup_theme()

            # Initialize Whisper recognizer
            self.init_whisper_recognizer()

            # Set up UI components
            self.setup_ui()

            # Start system monitoring
            self.start_system_monitoring()

        except Exception as e:
            logging.error(f"Error initializing DragonVoiceGUI: {str(e)}")
            raise

    def setup_logging(self):
        """Set up logging configuration"""
        # Check if logging is already configured
        if not logging.getLogger().handlers:
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - %(message)s'
            )
        logging.info("Logging setup complete")

    def setup_theme(self):
        """Set up the theme and colors for the application"""
        # Set appearance mode
        ctk.set_appearance_mode("dark")

        # Define color schemes with modern, sophisticated palettes
        self.color_schemes = {
            "aurora": {  # New default theme
                "bg_dark": "#1A1B26",      # Deep space blue
                "bg_medium": "#24283B",    # Midnight blue
                "bg_light": "#2F3549",     # Slate blue
                "accent_primary": "#7AA2F7",  # Electric blue
                "accent_secondary": "#BB9AF7",  # Soft purple
                "text_bright": "#C0CAF5",  # Ice blue
                "text_normal": "#9AA5CE",  # Muted blue
                "text_dim": "#565F89",     # Dark slate
                "status_green": "#9ECE6A",  # Sage green
                "status_yellow": "#E0AF68", # Warm amber
                "status_red": "#F7768E",    # Coral pink
                "status_blue": "#7DCFFF",   # Sky blue
                "status_gray": "#414868",   # Steel gray
                "separator": "#1F2335"      # Dark separator
            },
            "quantum": {  # High contrast theme
                "bg_dark": "#151515",      # Deep black
                "bg_medium": "#1E1E1E",    # Rich black
                "bg_light": "#252525",     # Soft black
                "accent_primary": "#00FF9C",  # Neon green
                "accent_secondary": "#00B8FF",  # Electric blue
                "text_bright": "#FFFFFF",   # Pure white
                "text_normal": "#CCCCCC",   # Light gray
                "text_dim": "#808080",      # Medium gray
                "status_green": "#00FF9C",  # Neon green
                "status_yellow": "#FFD700", # Gold
                "status_red": "#FF3366",    # Hot pink
                "status_blue": "#00B8FF",   # Electric blue
                "status_gray": "#404040",   # Dark gray
                "separator": "#333333"      # Dark separator
            },
            "glacier": {  # Light theme
                "bg_dark": "#E8EEF2",      # Ice white
                "bg_medium": "#D5E3EC",    # Glacier blue
                "bg_light": "#C2D8E9",     # Soft blue
                "accent_primary": "#2B7BB9",  # Deep blue
                "accent_secondary": "#5C6BC0",  # Royal blue
                "text_bright": "#1A1A1A",   # Near black
                "text_normal": "#2D2D2D",   # Dark gray
                "text_dim": "#5D5D5D",      # Medium gray
                "status_green": "#2E7D32",  # Forest green
                "status_yellow": "#F9A825", # Sunflower
                "status_red": "#C62828",    # Ruby red
                "status_blue": "#1565C0",   # Ocean blue
                "status_gray": "#90A4AE",   # Cool gray
                "separator": "#B0BEC5"      # Light separator
            }
        }

        # Set default color scheme
        self.colors = self.color_schemes["aurora"]

        # Define modern font system
        self.fonts = {
            "header": ctk.CTkFont(family="Segoe UI", size=32, weight="bold"),
            "title": ctk.CTkFont(family="Segoe UI", size=24, weight="bold"),
            "subtitle": ctk.CTkFont(family="Segoe UI", size=18, weight="bold"),
            "normal": ctk.CTkFont(family="Segoe UI", size=14),
            "small": ctk.CTkFont(family="Segoe UI", size=12),
            "tiny": ctk.CTkFont(family="Segoe UI", size=10),
            "mono": ctk.CTkFont(family="JetBrains Mono", size=12),
            "large": ctk.CTkFont(family="Segoe UI", size=20),
            "display": ctk.CTkFont(family="Segoe UI", size=40, weight="bold"),
            "button": ctk.CTkFont(family="Segoe UI", size=14, weight="bold"),
            "caption": ctk.CTkFont(family="Segoe UI", size=11),
            "code": ctk.CTkFont(family="JetBrains Mono", size=13)
        }

        # Define corner radius system
        self.corners = {
            "small": 4,
            "medium": 8,
            "large": 12,
            "xl": 16,
            "pill": 24
        }

        # Define spacing system
        self.spacing = {
            "xs": 4,
            "small": 8,
            "medium": 16,
            "large": 24,
            "xl": 32,
            "xxl": 48
        }

        # Define shadow system
        self.shadows = {
            "small": "0 2px 4px rgba(0,0,0,0.1)",
            "medium": "0 4px 8px rgba(0,0,0,0.15)",
            "large": "0 8px 16px rgba(0,0,0,0.2)"
        }

        # Animation durations
        self.animations = {
            "fast": 150,
            "normal": 250,
            "slow": 350
        }

    def init_whisper_recognizer(self):
        """Initialize the Whisper recognizer"""
        try:
            # Initialize API keys from environment or config
            self.openai_api_key = os.environ.get("OPENAI_API_KEY", "")
            if not self.openai_api_key and "openai_api_key" in self.config:
                self.openai_api_key = self.config["openai_api_key"]
                os.environ["OPENAI_API_KEY"] = self.openai_api_key

            # Initialize WhisperRecognizer with error handling
            if self.openai_api_key:
                self.whisper_recognizer = WhisperRecognizer(
                    api_key=self.openai_api_key)
                logging.info("WhisperRecognizer initialized successfully")
            else:
                logging.warning(
                    "No OpenAI API key found, WhisperRecognizer not initialized")
                self.whisper_recognizer = None
        except Exception as e:
            logging.error(f"Failed to initialize WhisperRecognizer: {str(e)}")
            self.whisper_recognizer = None

    def setup_ui(self):
        """Set up the main user interface"""
        try:
            # Create main container
            self.main_container = ctk.CTkFrame(self.app)
            self.main_container.pack(fill="both", expand=True)
            
            # Configure grid
            self.main_container.grid_columnconfigure(0, weight=1)
            self.main_container.grid_rowconfigure(1, weight=1)  # Content area expands
            
            # Create UI sections
            self.create_header()      # Row 0
            self.create_content()     # Row 1
            self.create_footer()      # Row 2
            
            # Start system monitoring
            self.start_system_monitoring()
            
            # Initial status update
            self.update_status("Ready")
            
        except Exception as e:
            logging.error(f"Error setting up UI: {str(e)}", exc_info=True)
            raise  # Re-raise the exception for proper error handling

    def create_content(self):
        """Create the main content area with tabs"""
        # Create content frame
        self.content_frame = ctk.CTkFrame(self.main_container, fg_color="transparent")
        self.content_frame.grid(row=1, column=0, sticky="nsew", padx=20, pady=10)
        
        # Configure content frame grid
        self.content_frame.grid_rowconfigure(0, weight=1)
        self.content_frame.grid_columnconfigure(0, weight=1)
        
        # Create tab view
        self.tab_view = ctk.CTkTabview(
            self.content_frame,
            fg_color=self.colors["bg_dark"],
            segmented_button_fg_color=self.colors["bg_medium"],
            segmented_button_selected_color=self.colors["accent_primary"],
            segmented_button_selected_hover_color=self.colors["accent_secondary"],
            segmented_button_unselected_color=self.colors["bg_medium"],
            segmented_button_unselected_hover_color=self.colors["bg_light"]
        )
        self.tab_view.grid(row=0, column=0, sticky="nsew")
        
        # Define tabs with icons
        tabs = [
            ("Dashboard", "üìä"),
            ("Chatbots", "ü§ñ"),
            ("History", "üìú"),
            ("Configuration", "‚öôÔ∏è"),
            ("About", "‚ÑπÔ∏è")
        ]
        
        # Add tabs
        for tab_name, icon in tabs:
            self.tab_view.add(tab_name)
            tab = self.tab_view.tab(tab_name)
            tab.configure(fg_color=self.colors["bg_dark"])
            
            # Configure tab grid
            tab.grid_rowconfigure(0, weight=1)
            tab.grid_columnconfigure(0, weight=1)
            
            # Add icon to tab button
            if hasattr(self.tab_view, "_segmented_button"):
                button = self.tab_view._segmented_button
                button._buttons_dict[tab_name].configure(
                    text=f"{icon} {tab_name}",
                    font=self.fonts["button"],
                    height=32,
                    corner_radius=self.corners["medium"]
                )
        
        # Set default tab
        self.tab_view.set("Dashboard")
        
        # Create tab contents
        self.create_dashboard_tab()
        self.create_chatbots_tab()
        self.create_history_tab()
        self.create_config_tab()
        self.create_about_tab()

    def create_header(self):
        """Create the application header"""
        # Create header frame
        self.header_frame = ctk.CTkFrame(
            self.main_container,
            fg_color=self.colors["bg_dark"],
            height=80
        )
        self.header_frame.grid(row=0, column=0, sticky="ew")
        self.header_frame.grid_propagate(False)
        
        # Configure header grid
        self.header_frame.grid_columnconfigure(1, weight=1)  # Center section expands
        
        # Left section - Logo and title
        left_section = ctk.CTkFrame(self.header_frame, fg_color="transparent")
        left_section.grid(row=0, column=0, padx=20, pady=10, sticky="w")
        
        # Try to load logo
        try:
            assets_dir = os.path.join("src", "assets")
            logo_path = os.path.join(assets_dir, "dragon_logo.png")
            
            # Create assets directory if it doesn't exist
            if not os.path.exists(assets_dir):
                os.makedirs(assets_dir)
                logging.warning(f"Created missing assets directory: {assets_dir}")
            
            if os.path.exists(logo_path):
                logo_image = ctk.CTkImage(
                    light_image=Image.open(logo_path),
                    dark_image=Image.open(logo_path),
                    size=(36, 36)
                )
                logo_label = ctk.CTkLabel(
                    left_section,
                    image=logo_image,
                    text=""
                )
                logo_label.pack(side="left", padx=(0, 10))
            else:
                # Create text-based logo as fallback
                logo_label = ctk.CTkLabel(
                    left_section,
                    text="üêâ",
                    font=("Segoe UI Emoji", 24),
                    text_color=self.colors["accent_primary"]
                )
                logo_label.pack(side="left", padx=(0, 10))
                logging.warning(f"Logo file not found: {logo_path}, using emoji fallback")
        except Exception as e:
            logging.error(f"Failed to load logo: {str(e)}")
            # Create text-based logo as fallback
            logo_label = ctk.CTkLabel(
                left_section,
                text="üêâ",
                font=("Segoe UI Emoji", 24),
                text_color=self.colors["accent_primary"]
            )
            logo_label.pack(side="left", padx=(0, 10))
        
        # App title
        title_label = ctk.CTkLabel(
            left_section,
            text="DragonVoice",
            font=self.fonts["header"],
            text_color=self.colors["text_bright"]
        )
        title_label.pack(side="left")
        
        # Version pill
        version_pill = ctk.CTkFrame(
            left_section,
            fg_color=self.colors["accent_primary"],
            corner_radius=self.corners["pill"]
        )
        version_pill.pack(side="left", padx=10)
        
        version_label = ctk.CTkLabel(
            version_pill,
            text="v2.0",
            font=self.fonts["caption"],
            text_color=self.colors["text_bright"]
        )
        version_label.pack(padx=10, pady=2)
        
        # Center section - Status
        center_section = ctk.CTkFrame(self.header_frame, fg_color="transparent")
        center_section.grid(row=0, column=1, sticky="ew")
        
        # Right section - Controls
        right_section = ctk.CTkFrame(self.header_frame, fg_color="transparent")
        right_section.grid(row=0, column=2, padx=20, pady=10, sticky="e")
        
        # Microphone selector
        mic_frame = ctk.CTkFrame(
            right_section,
            fg_color=self.colors["bg_light"],
            corner_radius=self.corners["medium"]
        )
        mic_frame.pack(side="left", padx=(0, 10))
        
        mic_label = ctk.CTkLabel(
            mic_frame,
            text="üé§",
            font=self.fonts["normal"]
        )
        mic_label.pack(side="left", padx=10, pady=5)
        
        self.mic_var = ctk.StringVar(value="Default Microphone")
        self.mic_dropdown = ctk.CTkOptionMenu(
            mic_frame,
            values=["Default Microphone"],
            variable=self.mic_var,
            width=140,
            dynamic_resizing=True
        )
        self.mic_dropdown.pack(side="left", padx=(0, 10), pady=5)
        
        # Control buttons
        for icon, command in [
            ("üé®", self.toggle_theme),
            ("‚öôÔ∏è", self.show_settings),
            ("‚ùî", self.show_help)
        ]:
            btn = ctk.CTkButton(
                right_section,
                text=icon,
                width=34,
                height=34,
                corner_radius=self.corners["medium"],
                fg_color=self.colors["bg_light"],
                hover_color=self.colors["accent_primary"],
                command=command
            )
            btn.pack(side="left", padx=5)

    def create_footer(self):
        """Create the application footer"""
        # Create footer frame
        self.footer = ctk.CTkFrame(
            self.main_container,
            fg_color=self.colors["bg_dark"],
            height=28
        )
        self.footer.grid(row=2, column=0, sticky="ew")
        self.footer.grid_propagate(False)
        
        # Configure footer grid
        self.footer.grid_columnconfigure(1, weight=1)  # Center section expands
        
        # Left section - Status
        status_frame = ctk.CTkFrame(self.footer, fg_color="transparent")
        status_frame.grid(row=0, column=0, padx=20, sticky="w")
        
        self.status_dot = ctk.CTkLabel(
            status_frame,
            text="‚óè",
            font=self.fonts["small"],
            text_color=self.colors["status_green"],
            width=20
        )
        self.status_dot.pack(side="left")
        
        self.status_label = ctk.CTkLabel(
            status_frame,
            text="Ready",
            font=self.fonts["caption"],
            text_color=self.colors["text_dim"]
        )
        self.status_label.pack(side="left", padx=5)
        
        # Center section - System metrics
        metrics_frame = ctk.CTkFrame(self.footer, fg_color="transparent")
        metrics_frame.grid(row=0, column=1, sticky="ew")
        
        metrics = [
            ("CPU", "0%", self.colors["status_green"]),
            ("RAM", "0%", self.colors["status_green"]),
            ("Disk", "0%", self.colors["status_green"])
        ]
        
        for i, (label, value, color) in enumerate(metrics):
            metric_frame = ctk.CTkFrame(metrics_frame, fg_color="transparent")
            metric_frame.pack(side="left", padx=20)
            
            ctk.CTkLabel(
                metric_frame,
                text=label,
                font=self.fonts["caption"],
                text_color=self.colors["text_dim"]
            ).pack(side="left")
            
            value_label = ctk.CTkLabel(
                metric_frame,
                text=value,
                font=self.fonts["caption"],
                text_color=color
            )
            value_label.pack(side="left", padx=5)
            setattr(self, f'metric_value_{i}', value_label)
        
        # Right section - Build info
        build_frame = ctk.CTkFrame(self.footer, fg_color="transparent")
        build_frame.grid(row=0, column=2, padx=20, sticky="e")
        
        build_label = ctk.CTkLabel(
            build_frame,
            text="Build 2024.03",
            font=self.fonts["caption"],
            text_color=self.colors["text_dim"]
        )
        build_label.pack()

    def create_dashboard_tab(self):
        """Create the dashboard tab content"""
        dashboard = self.tab_view.tab("Dashboard")
        
        # Configure grid
        dashboard.grid_columnconfigure(0, weight=2)  # Status panel
        dashboard.grid_columnconfigure(1, weight=1)  # Control panel
        dashboard.grid_rowconfigure(1, weight=1)     # Voice commands section
        dashboard.grid_rowconfigure(2, weight=1)     # Transcription section
        
        # Status panel (top left)
        status_panel = ctk.CTkFrame(
            dashboard,
            fg_color=self.colors["bg_medium"],
            corner_radius=15
        )
        status_panel.grid(row=0, column=0, sticky="nsew", padx=(20, 10), pady=(20, 10))
        
        # Status panel title
        status_title = ctk.CTkLabel(
            status_panel,
            text="System Status",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        status_title.pack(anchor="w", padx=20, pady=(15, 10))
        
        # Status indicators grid
        indicators_frame = ctk.CTkFrame(status_panel, fg_color="transparent")
        indicators_frame.pack(fill="both", expand=True, padx=20, pady=(0, 20))
        
        # Configure indicators grid
        indicators_frame.columnconfigure((0, 1), weight=1)
        indicators_frame.rowconfigure((0, 1), weight=1)
        
        # Create status indicators
        self.create_status_indicator(indicators_frame, "CPU Usage", "0%", self.colors["status_green"], 0, 0)
        self.create_status_indicator(indicators_frame, "Memory", "0%", self.colors["status_green"], 0, 1)
        self.create_status_indicator(indicators_frame, "Disk Space", "0%", self.colors["status_green"], 1, 0)
        self.create_status_indicator(indicators_frame, "Voice Status", "Idle", self.colors["status_gray"], 1, 1)
        
        # Voice assistant control panel (top right)
        control_panel = ctk.CTkFrame(
            dashboard,
            fg_color=self.colors["bg_medium"],
            corner_radius=15
        )
        control_panel.grid(row=0, column=1, sticky="nsew", padx=(10, 20), pady=(20, 10))
        
        # Control panel title
        control_title = ctk.CTkLabel(
            control_panel,
            text="Voice Assistant",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        control_title.pack(anchor="w", padx=20, pady=(15, 10))
        
        # Start/Stop button
        self.toggle_button = ctk.CTkButton(
            control_panel,
            text="Start Voice Assistant",
            command=self.toggle_voice_assistant,
            fg_color=self.colors["status_green"],
            hover_color=self._adjust_color_brightness(self.colors["status_green"], 0.8),
            height=50,
            corner_radius=10,
            font=self.fonts["subtitle"]
        )
        self.toggle_button.pack(fill="x", padx=20, pady=10)
        
        # Recording buttons frame
        recording_frame = ctk.CTkFrame(control_panel, fg_color="transparent")
        recording_frame.pack(fill="x", padx=20, pady=5)
        
        # Configure recording frame grid
        recording_frame.columnconfigure((0, 1), weight=1)
        
        # Record button
        self.record_button = ctk.CTkButton(
            recording_frame,
            text="Record",
            command=self.start_manual_recording,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            height=40
        )
        self.record_button.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        
        # Stop Recording button
        self.stop_record_button = ctk.CTkButton(
            recording_frame,
            text="Stop Recording",
            command=self.stop_manual_recording,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            height=40,
            state="disabled"
        )
        self.stop_record_button.grid(row=0, column=1, sticky="ew", padx=(5, 0))
        
        # Add synthesizer bar
        self.synth_bar = SynthesizerBar(control_panel, self.colors, self.fonts)
        
        # Voice commands section (middle)
        commands_frame = ctk.CTkFrame(
            dashboard,
            fg_color=self.colors["bg_medium"],
            corner_radius=15
        )
        commands_frame.grid(row=1, column=0, columnspan=2, sticky="nsew", padx=20, pady=10)
        
        # Commands title with clear button
        commands_header = ctk.CTkFrame(commands_frame, fg_color="transparent")
        commands_header.pack(fill="x", padx=20, pady=(15, 10))
        
        commands_title = ctk.CTkLabel(
            commands_header,
            text="Voice Commands",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        commands_title.pack(side="left")
        
        clear_commands = ctk.CTkButton(
            commands_header,
            text="Clear",
            command=lambda: self.clear_text_display("text_display"),
            width=80,
            fg_color=self.colors["accent_secondary"]
        )
        clear_commands.pack(side="right")
        
        # Commands text display
        self.text_display = ctk.CTkTextbox(
            commands_frame,
            fg_color=self.colors["bg_light"],
            text_color=self.colors["text_bright"],
            font=self.fonts["normal"],
            corner_radius=10,
            height=150
        )
        self.text_display.pack(fill="both", expand=True, padx=20, pady=(5, 15))
        
        # Configure text tags
        self.text_display._textbox.tag_configure("timestamp", foreground=self.colors["accent_secondary"])
        self.text_display._textbox.tag_configure("command", foreground=self.colors["text_bright"])
        self.text_display._textbox.tag_configure("system", foreground=self.colors["status_blue"])
        
        # Transcription section (bottom)
        transcription_frame = ctk.CTkFrame(
            dashboard,
            fg_color=self.colors["bg_medium"],
            corner_radius=15
        )
        transcription_frame.grid(row=2, column=0, columnspan=2, sticky="nsew", padx=20, pady=(10, 20))
        
        # Transcription header
        transcription_header = ctk.CTkFrame(transcription_frame, fg_color="transparent")
        transcription_header.pack(fill="x", padx=20, pady=(15, 10))
        
        transcription_title = ctk.CTkLabel(
            transcription_header,
            text="Transcribed Text",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        transcription_title.pack(side="left")
        
        clear_transcription = ctk.CTkButton(
            transcription_header,
            text="Clear",
            command=lambda: self.clear_text_display("transcription_display"),
            width=80,
            fg_color=self.colors["accent_secondary"]
        )
        clear_transcription.pack(side="right")
        
        # Transcription display
        self.transcription_display = ctk.CTkTextbox(
            transcription_frame,
            fg_color=self.colors["bg_light"],
            text_color=self.colors["text_bright"],
            font=self.fonts["normal"],
            corner_radius=10,
            height=100
        )
        self.transcription_display.pack(fill="both", expand=True, padx=20, pady=(5, 10))
        
        # Enter button frame
        enter_frame = ctk.CTkFrame(transcription_frame, fg_color="transparent")
        enter_frame.pack(fill="x", padx=20, pady=(0, 15))
        
        # Enter button
        self.enter_button = ctk.CTkButton(
            enter_frame,
            text="Enter",
            command=self.process_transcription,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            height=40,
            state="disabled"
        )
        self.enter_button.pack(side="right")

    def create_status_indicator(self, parent, label, value, color, row, column):
        """Create a status indicator with label and value"""
        # Create indicator frame
        indicator = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )
        indicator.grid(row=row, column=column, padx=5, pady=5, sticky="nsew")

        # Label
        label_widget = ctk.CTkLabel(
            indicator,
            text=label,
            font=self.fonts["small"],
            text_color=self.colors["text_dim"]
        )
        label_widget.pack(pady=(10, 0))

        # Value
        value_widget = ctk.CTkLabel(
            indicator,
            text=value,
            font=self.fonts["large"],
            text_color=color
        )
        value_widget.pack(pady=(5, 10))

        return indicator

    def create_chatbots_tab(self):
        """Create the chatbots tab content"""
        chatbots = self.tab_view.tab("Chatbots")
        
        # Configure grid
        chatbots.grid_columnconfigure(0, weight=1)
        chatbots.grid_rowconfigure(0, weight=1)
        
        # Create chatbots container
        chatbots_container = ctk.CTkScrollableFrame(
            chatbots,
            fg_color="transparent"
        )
        chatbots_container.grid(row=0, column=0, sticky="nsew", padx=20, pady=10)
        
        # Configure chatbots container grid
        chatbots_container.grid_columnconfigure(0, weight=1)
        
        # Add chatbots
        chatbots_data = [
            {"name": "Chatbot 1", "description": "Description 1", "status": "Online"},
            {"name": "Chatbot 2", "description": "Description 2", "status": "Offline"},
            {"name": "Chatbot 3", "description": "Description 3", "status": "Online"},
            {"name": "Chatbot 4", "description": "Description 4", "status": "Offline"},
            {"name": "Chatbot 5", "description": "Description 5", "status": "Online"},
            {"name": "Chatbot 6", "description": "Description 6", "status": "Offline"},
            {"name": "Chatbot 7", "description": "Description 7", "status": "Online"},
            {"name": "Chatbot 8", "description": "Description 8", "status": "Offline"},
            {"name": "Chatbot 9", "description": "Description 9", "status": "Online"},
            {"name": "Chatbot 10", "description": "Description 10", "status": "Offline"}
        ]
        
        for i, data in enumerate(chatbots_data):
            chatbot_frame = ctk.CTkFrame(
                chatbots_container,
                fg_color=self.colors["bg_medium"],
                corner_radius=10
            )
            chatbot_frame.grid(row=i, column=0, sticky="ew", padx=10, pady=10)
            
            # Chatbot name
            name_label = ctk.CTkLabel(
                chatbot_frame,
                text=data["name"],
                font=self.fonts["title"],
                text_color=self.colors["text_bright"]
            )
            name_label.pack(anchor="w", padx=20, pady=(15, 5))
            
            # Chatbot description
            desc_label = ctk.CTkLabel(
                chatbot_frame,
                text=data["description"],
                font=self.fonts["normal"],
                text_color=self.colors["text_normal"]
            )
            desc_label.pack(anchor="w", padx=20, pady=(0, 10))
            
            # Chatbot status
            status_label = ctk.CTkLabel(
                chatbot_frame,
                text=f"Status: {data['status']}",
                font=self.fonts["small"],
                text_color=self.colors["text_dim"]
            )
            status_label.pack(anchor="w", padx=20, pady=(0, 15))
            
            # Chatbot actions
            actions_frame = ctk.CTkFrame(chatbot_frame, fg_color="transparent")
            actions_frame.pack(fill="x", padx=20, pady=(0, 15))
            
            # Configure actions frame grid
            actions_frame.columnconfigure((0, 1), weight=1)
            
            # Action buttons
            for text, command in [
                ("Connect", self.connect_chatbot),
                ("Disconnect", self.disconnect_chatbot),
                ("Settings", self.show_chatbot_settings)
            ]:
                btn = ctk.CTkButton(
                    actions_frame,
                    text=text,
                    command=command,
                    fg_color=self.colors["accent_primary"],
                    hover_color=self.colors["accent_secondary"],
                    height=30
                )
                btn.grid(row=0, column=0, padx=5, pady=5)

    def create_history_tab(self):
        """Create the history tab content"""
        history = self.tab_view.tab("History")
        
        # Configure grid
        history.grid_columnconfigure(0, weight=1)
        history.grid_rowconfigure(0, weight=1)
        
        # Create history container
        history_container = ctk.CTkScrollableFrame(
            history,
            fg_color="transparent"
        )
        history_container.grid(row=0, column=0, sticky="nsew", padx=20, pady=10)
        
        # Configure history container grid
        history_container.grid_columnconfigure(0, weight=1)
        
        # Add history items
        history_data = [
            {"timestamp": "2023-03-12 10:30:00", "command": "Command 1", "response": "Response 1"},
            {"timestamp": "2023-03-12 10:35:00", "command": "Command 2", "response": "Response 2"},
            {"timestamp": "2023-03-12 10:40:00", "command": "Command 3", "response": "Response 3"},
            {"timestamp": "2023-03-12 10:45:00", "command": "Command 4", "response": "Response 4"},
            {"timestamp": "2023-03-12 10:50:00", "command": "Command 5", "response": "Response 5"},
            {"timestamp": "2023-03-12 10:55:00", "command": "Command 6", "response": "Response 6"},
            {"timestamp": "2023-03-12 11:00:00", "command": "Command 7", "response": "Response 7"},
            {"timestamp": "2023-03-12 11:05:00", "command": "Command 8", "response": "Response 8"},
            {"timestamp": "2023-03-12 11:10:00", "command": "Command 9", "response": "Response 9"},
            {"timestamp": "2023-03-12 11:15:00", "command": "Command 10", "response": "Response 10"}
        ]
        
        for i, data in enumerate(history_data):
            item_frame = ctk.CTkFrame(
                history_container,
                fg_color=self.colors["bg_medium"],
                corner_radius=10
            )
            item_frame.grid(row=i, column=0, sticky="ew", padx=10, pady=10)
            
            # Timestamp
            timestamp_label = ctk.CTkLabel(
                item_frame,
                text=data["timestamp"],
                font=self.fonts["small"],
                text_color=self.colors["text_dim"]
            )
            timestamp_label.pack(anchor="w", padx=20, pady=(10, 5))
            
            # Command
            command_label = ctk.CTkLabel(
                item_frame,
                text=data["command"],
                font=self.fonts["normal"],
                text_color=self.colors["text_normal"]
            )
            command_label.pack(anchor="w", padx=20, pady=(0, 5))
            
            # Response
            response_label = ctk.CTkLabel(
                item_frame,
                text=data["response"],
                font=self.fonts["normal"],
                text_color=self.colors["text_bright"]
            )
            response_label.pack(anchor="w", padx=20, pady=(0, 10))

    def create_config_tab(self):
        """Create the configuration tab content"""
        config = self.tab_view.tab("Configuration")
        
        # Configure grid
        config.grid_columnconfigure(0, weight=1)
        config.grid_rowconfigure(0, weight=1)
        
        # Create config container
        config_container = ctk.CTkScrollableFrame(
            config,
            fg_color="transparent"
        )
        config_container.grid(row=0, column=0, sticky="nsew", padx=20, pady=10)
        
        # Configure config container grid
        config_container.grid_columnconfigure(0, weight=1)
        
        # Add config sections
        sections = [
            {"title": "General", "options": [
                {"label": "Option 1", "type": "switch", "value": True},
                {"label": "Option 2", "type": "slider", "value": 50},
                {"label": "Option 3", "type": "entry", "value": "Value 3"},
                {"label": "Option 4", "type": "dropdown", "values": ["Option A", "Option B", "Option C"], "value": "Option A"}
            ]},
            {"title": "Audio", "options": [
                {"label": "Option 1", "type": "switch", "value": False},
#!/usr/bin/env python3
"""
Dragon Voice GUI - Main application interface for Dragon Voice Project
"""

from whisper_integration import WhisperRecognizer
import os
import sys
import json
import time
import logging
import webbrowser
import threading
from datetime import datetime
from pathlib import Path

# GUI libraries
import tkinter as tk
from tkinter import messagebox
import customtkinter as ctk
from PIL import Image, ImageTk

# System monitoring
import psutil
import platform

# Window management
import pygetwindow as gw
import pyautogui
import sounddevice as sd
import numpy as np
import tempfile
import os
import time
import threading

# Custom components
from synthesizer_bar import SynthesizerBar

# Try to import soundfile, but don't fail if it's not available
try:
    import soundfile as sf
    SOUNDFILE_AVAILABLE = True
except ImportError:
    SOUNDFILE_AVAILABLE = False
    print("Warning: soundfile module not found. Some audio features will be limited.")

# Configure logging
logging.basicConfig(
    level=logging.WARNING,  # Changed from INFO to WARNING
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("dragon_gui.log"),
        logging.StreamHandler()
    ]
)

# Constants
DEFAULT_CONFIG_PATH = "src/config.json"
ASSETS_DIR = os.path.join("src", "assets")

# Add Whisper integration


class DragonVoiceGUI:
    """
    Main GUI class for the Dragon Voice Project

    Provides a modern, feature-rich interface for controlling the voice assistant,
    managing chatbots, and configuring system settings.
    """

    def __init__(self, config_path=DEFAULT_CONFIG_PATH):
        """Initialize the DragonVoice GUI application"""
        logging.info("Initializing DragonVoiceGUI")

        try:
            # Initialize logging
            self.setup_logging()

            # Initialize state variables
            self.recording_active = False
            self.continuous_recording = False  # Flag for continuous recording
            self.is_fullscreen = False

            # Create main application window
            self.app = ctk.CTk()
            self.app.title("DragonVoice")
            self.app.geometry("1200x800")
            self.app.minsize(900, 600)

            # Load configuration
            self.config_path = config_path
            self.config = self.load_config()
            logging.info(f"Configuration loaded from {config_path}")

            # Set up theme and colors
            self.setup_theme()

            # Initialize Whisper recognizer
            self.init_whisper_recognizer()

            # Set up UI components
            self.setup_ui()

            # Start system monitoring
            self.start_system_monitoring()

        except Exception as e:
            logging.error(f"Error initializing DragonVoiceGUI: {str(e)}")
            raise

    def setup_logging(self):
        """Set up logging configuration"""
        # Check if logging is already configured
        if not logging.getLogger().handlers:
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - %(message)s'
            )
        logging.info("Logging setup complete")

    def setup_theme(self):
        """Set up the theme and colors for the application"""
        # Set appearance mode
        ctk.set_appearance_mode("dark")

        # Define color schemes with modern, sophisticated palettes
        self.color_schemes = {
            "aurora": {  # New default theme
                "bg_dark": "#1A1B26",      # Deep space blue
                "bg_medium": "#24283B",    # Midnight blue
                "bg_light": "#2F3549",     # Slate blue
                "accent_primary": "#7AA2F7",  # Electric blue
                "accent_secondary": "#BB9AF7",  # Soft purple
                "text_bright": "#C0CAF5",  # Ice blue
                "text_normal": "#9AA5CE",  # Muted blue
                "text_dim": "#565F89",     # Dark slate
                "status_green": "#9ECE6A",  # Sage green
                "status_yellow": "#E0AF68", # Warm amber
                "status_red": "#F7768E",    # Coral pink
                "status_blue": "#7DCFFF",   # Sky blue
                "status_gray": "#414868",   # Steel gray
                "separator": "#1F2335"      # Dark separator
            },
            "quantum": {  # High contrast theme
                "bg_dark": "#151515",      # Deep black
                "bg_medium": "#1E1E1E",    # Rich black
                "bg_light": "#252525",     # Soft black
                "accent_primary": "#00FF9C",  # Neon green
                "accent_secondary": "#00B8FF",  # Electric blue
                "text_bright": "#FFFFFF",   # Pure white
                "text_normal": "#CCCCCC",   # Light gray
                "text_dim": "#808080",      # Medium gray
                "status_green": "#00FF9C",  # Neon green
                "status_yellow": "#FFD700", # Gold
                "status_red": "#FF3366",    # Hot pink
                "status_blue": "#00B8FF",   # Electric blue
                "status_gray": "#404040",   # Dark gray
                "separator": "#333333"      # Dark separator
            },
            "glacier": {  # Light theme
                "bg_dark": "#E8EEF2",      # Ice white
                "bg_medium": "#D5E3EC",    # Glacier blue
                "bg_light": "#C2D8E9",     # Soft blue
                "accent_primary": "#2B7BB9",  # Deep blue
                "accent_secondary": "#5C6BC0",  # Royal blue
                "text_bright": "#1A1A1A",   # Near black
                "text_normal": "#2D2D2D",   # Dark gray
                "text_dim": "#5D5D5D",      # Medium gray
                "status_green": "#2E7D32",  # Forest green
                "status_yellow": "#F9A825", # Sunflower
                "status_red": "#C62828",    # Ruby red
                "status_blue": "#1565C0",   # Ocean blue
                "status_gray": "#90A4AE",   # Cool gray
                "separator": "#B0BEC5"      # Light separator
            }
        }

        # Set default color scheme
        self.colors = self.color_schemes["aurora"]

        # Define modern font system
        self.fonts = {
            "header": ctk.CTkFont(family="Segoe UI", size=32, weight="bold"),
            "title": ctk.CTkFont(family="Segoe UI", size=24, weight="bold"),
            "subtitle": ctk.CTkFont(family="Segoe UI", size=18, weight="bold"),
            "normal": ctk.CTkFont(family="Segoe UI", size=14),
            "small": ctk.CTkFont(family="Segoe UI", size=12),
            "tiny": ctk.CTkFont(family="Segoe UI", size=10),
            "mono": ctk.CTkFont(family="JetBrains Mono", size=12),
            "large": ctk.CTkFont(family="Segoe UI", size=20),
            "display": ctk.CTkFont(family="Segoe UI", size=40, weight="bold"),
            "button": ctk.CTkFont(family="Segoe UI", size=14, weight="bold"),
            "caption": ctk.CTkFont(family="Segoe UI", size=11),
            "code": ctk.CTkFont(family="JetBrains Mono", size=13)
        }

        # Define corner radius system
        self.corners = {
            "small": 4,
            "medium": 8,
            "large": 12,
            "xl": 16,
            "pill": 24
        }

        # Define spacing system
        self.spacing = {
            "xs": 4,
            "small": 8,
            "medium": 16,
            "large": 24,
            "xl": 32,
            "xxl": 48
        }

        # Define shadow system
        self.shadows = {
            "small": "0 2px 4px rgba(0,0,0,0.1)",
            "medium": "0 4px 8px rgba(0,0,0,0.15)",
            "large": "0 8px 16px rgba(0,0,0,0.2)"
        }

        # Animation durations
        self.animations = {
            "fast": 150,
            "normal": 250,
            "slow": 350
        }

    def init_whisper_recognizer(self):
        """Initialize the Whisper recognizer"""
        try:
            # Initialize API keys from environment or config
            self.openai_api_key = os.environ.get("OPENAI_API_KEY", "")
            if not self.openai_api_key and "openai_api_key" in self.config:
                self.openai_api_key = self.config["openai_api_key"]
                os.environ["OPENAI_API_KEY"] = self.openai_api_key

            # Initialize WhisperRecognizer with error handling
            if self.openai_api_key:
                self.whisper_recognizer = WhisperRecognizer(
                    api_key=self.openai_api_key)
                logging.info("WhisperRecognizer initialized successfully")
            else:
                logging.warning(
                    "No OpenAI API key found, WhisperRecognizer not initialized")
                self.whisper_recognizer = None
        except Exception as e:
            logging.error(f"Failed to initialize WhisperRecognizer: {str(e)}")
            self.whisper_recognizer = None

    def setup_ui(self):
        """Set up the main user interface"""
        try:
            # Create main container
            self.main_container = ctk.CTkFrame(self.app)
            self.main_container.pack(fill="both", expand=True)
            
            # Configure grid
            self.main_container.grid_columnconfigure(0, weight=1)
            self.main_container.grid_rowconfigure(1, weight=1)  # Content area expands
            
            # Create UI sections
            self.create_header()      # Row 0
            self.create_content()     # Row 1
            self.create_footer()      # Row 2
            
            # Start system monitoring
            self.start_system_monitoring()
            
            # Initial status update
            self.update_status("Ready")
            
        except Exception as e:
            logging.error(f"Error setting up UI: {str(e)}", exc_info=True)
            raise  # Re-raise the exception for proper error handling

    def create_content(self):
        """Create the main content area with tabs"""
        # Create content frame
        self.content_frame = ctk.CTkFrame(self.main_container, fg_color="transparent")
        self.content_frame.grid(row=1, column=0, sticky="nsew", padx=20, pady=10)
        
        # Configure content frame grid
        self.content_frame.grid_rowconfigure(0, weight=1)
        self.content_frame.grid_columnconfigure(0, weight=1)
        
        # Create tab view
        self.tab_view = ctk.CTkTabview(
            self.content_frame,
            fg_color=self.colors["bg_dark"],
            segmented_button_fg_color=self.colors["bg_medium"],
            segmented_button_selected_color=self.colors["accent_primary"],
            segmented_button_selected_hover_color=self.colors["accent_secondary"],
            segmented_button_unselected_color=self.colors["bg_medium"],
            segmented_button_unselected_hover_color=self.colors["bg_light"]
        )
        self.tab_view.grid(row=0, column=0, sticky="nsew")
        
        # Define tabs with icons
        tabs = [
            ("Dashboard", "üìä"),
            ("Chatbots", "ü§ñ"),
            ("History", "üìú"),
            ("Configuration", "‚öôÔ∏è"),
            ("About", "‚ÑπÔ∏è")
        ]
        
        # Add tabs
        for tab_name, icon in tabs:
            self.tab_view.add(tab_name)
            tab = self.tab_view.tab(tab_name)
            tab.configure(fg_color=self.colors["bg_dark"])
            
            # Configure tab grid
            tab.grid_rowconfigure(0, weight=1)
            tab.grid_columnconfigure(0, weight=1)
            
            # Add icon to tab button
            if hasattr(self.tab_view, "_segmented_button"):
                button = self.tab_view._segmented_button
                button._buttons_dict[tab_name].configure(
                    text=f"{icon} {tab_name}",
                    font=self.fonts["button"],
                    height=32,
                    corner_radius=self.corners["medium"]
                )
        
        # Set default tab
        self.tab_view.set("Dashboard")
        
        # Create tab contents
        self.create_dashboard_tab()
        self.create_chatbots_tab()
        self.create_history_tab()
        self.create_config_tab()
        self.create_about_tab()

    def create_header(self):
        """Create the application header"""
        # Create header frame
        self.header_frame = ctk.CTkFrame(
            self.main_container,
            fg_color=self.colors["bg_dark"],
            height=80
        )
        self.header_frame.grid(row=0, column=0, sticky="ew")
        self.header_frame.grid_propagate(False)
        
        # Configure header grid
        self.header_frame.grid_columnconfigure(1, weight=1)  # Center section expands
        
        # Left section - Logo and title
        left_section = ctk.CTkFrame(self.header_frame, fg_color="transparent")
        left_section.grid(row=0, column=0, padx=20, pady=10, sticky="w")
        
        # Try to load logo
        try:
            assets_dir = os.path.join("src", "assets")
            logo_path = os.path.join(assets_dir, "dragon_logo.png")
            
            # Create assets directory if it doesn't exist
            if not os.path.exists(assets_dir):
                os.makedirs(assets_dir)
                logging.warning(f"Created missing assets directory: {assets_dir}")
            
            if os.path.exists(logo_path):
                logo_image = ctk.CTkImage(
                    light_image=Image.open(logo_path),
                    dark_image=Image.open(logo_path),
                    size=(36, 36)
                )
                logo_label = ctk.CTkLabel(
                    left_section,
                    image=logo_image,
                    text=""
                )
                logo_label.pack(side="left", padx=(0, 10))
            else:
                # Create text-based logo as fallback
                logo_label = ctk.CTkLabel(
                    left_section,
                    text="üêâ",
                    font=("Segoe UI Emoji", 24),
                    text_color=self.colors["accent_primary"]
                )
                logo_label.pack(side="left", padx=(0, 10))
                logging.warning(f"Logo file not found: {logo_path}, using emoji fallback")
        except Exception as e:
            logging.error(f"Failed to load logo: {str(e)}")
            # Create text-based logo as fallback
            logo_label = ctk.CTkLabel(
                left_section,
                text="üêâ",
                font=("Segoe UI Emoji", 24),
                text_color=self.colors["accent_primary"]
            )
            logo_label.pack(side="left", padx=(0, 10))
        
        # App title
        title_label = ctk.CTkLabel(
            left_section,
            text="DragonVoice",
            font=self.fonts["header"],
            text_color=self.colors["text_bright"]
        )
        title_label.pack(side="left")
        
        # Version pill
        version_pill = ctk.CTkFrame(
            left_section,
            fg_color=self.colors["accent_primary"],
            corner_radius=self.corners["pill"]
        )
        version_pill.pack(side="left", padx=10)
        
        version_label = ctk.CTkLabel(
            version_pill,
            text="v2.0",
            font=self.fonts["caption"],
            text_color=self.colors["text_bright"]
        )
        version_label.pack(padx=10, pady=2)
        
        # Center section - Status
        center_section = ctk.CTkFrame(self.header_frame, fg_color="transparent")
        center_section.grid(row=0, column=1, sticky="ew")
        
        # Right section - Controls
        right_section = ctk.CTkFrame(self.header_frame, fg_color="transparent")
        right_section.grid(row=0, column=2, padx=20, pady=10, sticky="e")
        
        # Microphone selector
        mic_frame = ctk.CTkFrame(
            right_section,
            fg_color=self.colors["bg_light"],
            corner_radius=self.corners["medium"]
        )
        mic_frame.pack(side="left", padx=(0, 10))
        
        mic_label = ctk.CTkLabel(
            mic_frame,
            text="üé§",
            font=self.fonts["normal"]
        )
        mic_label.pack(side="left", padx=10, pady=5)
        
        self.mic_var = ctk.StringVar(value="Default Microphone")
        self.mic_dropdown = ctk.CTkOptionMenu(
            mic_frame,
            values=["Default Microphone"],
            variable=self.mic_var,
            width=140,
            dynamic_resizing=True
        )
        self.mic_dropdown.pack(side="left", padx=(0, 10), pady=5)
        
        # Control buttons
        for icon, command in [
            ("üé®", self.toggle_theme),
            ("‚öôÔ∏è", self.show_settings),
            ("‚ùî", self.show_help)
        ]:
            btn = ctk.CTkButton(
                right_section,
                text=icon,
                width=34,
                height=34,
                corner_radius=self.corners["medium"],
                fg_color=self.colors["bg_light"],
                hover_color=self.colors["accent_primary"],
                command=command
            )
            btn.pack(side="left", padx=5)

    def create_footer(self):
        """Create the application footer"""
        # Create footer frame
        self.footer = ctk.CTkFrame(
            self.main_container,
            fg_color=self.colors["bg_dark"],
            height=28
        )
        self.footer.grid(row=2, column=0, sticky="ew")
        self.footer.grid_propagate(False)
        
        # Configure footer grid
        self.footer.grid_columnconfigure(1, weight=1)  # Center section expands
        
        # Left section - Status
        status_frame = ctk.CTkFrame(self.footer, fg_color="transparent")
        status_frame.grid(row=0, column=0, padx=20, sticky="w")
        
        self.status_dot = ctk.CTkLabel(
            status_frame,
            text="‚óè",
            font=self.fonts["small"],
            text_color=self.colors["status_green"],
            width=20
        )
        self.status_dot.pack(side="left")
        
        self.status_label = ctk.CTkLabel(
            status_frame,
            text="Ready",
            font=self.fonts["caption"],
            text_color=self.colors["text_dim"]
        )
        self.status_label.pack(side="left", padx=5)
        
        # Center section - System metrics
        metrics_frame = ctk.CTkFrame(self.footer, fg_color="transparent")
        metrics_frame.grid(row=0, column=1, sticky="ew")
        
        metrics = [
            ("CPU", "0%", self.colors["status_green"]),
            ("RAM", "0%", self.colors["status_green"]),
            ("Disk", "0%", self.colors["status_green"])
        ]
        
        for i, (label, value, color) in enumerate(metrics):
            metric_frame = ctk.CTkFrame(metrics_frame, fg_color="transparent")
            metric_frame.pack(side="left", padx=20)
            
            ctk.CTkLabel(
                metric_frame,
                text=label,
                font=self.fonts["caption"],
                text_color=self.colors["text_dim"]
            ).pack(side="left")
            
            value_label = ctk.CTkLabel(
                metric_frame,
                text=value,
                font=self.fonts["caption"],
                text_color=color
            )
            value_label.pack(side="left", padx=5)
            setattr(self, f'metric_value_{i}', value_label)
        
        # Right section - Build info
        build_frame = ctk.CTkFrame(self.footer, fg_color="transparent")
        build_frame.grid(row=0, column=2, padx=20, sticky="e")
        
        build_label = ctk.CTkLabel(
            build_frame,
            text="Build 2024.03",
            font=self.fonts["caption"],
            text_color=self.colors["text_dim"]
        )
        build_label.pack()

    def create_dashboard_tab(self):
        """Create the dashboard tab content"""
        dashboard = self.tab_view.tab("Dashboard")
        
        # Configure grid
        dashboard.grid_columnconfigure(0, weight=2)  # Status panel
        dashboard.grid_columnconfigure(1, weight=1)  # Control panel
        dashboard.grid_rowconfigure(1, weight=1)     # Voice commands section
        dashboard.grid_rowconfigure(2, weight=1)     # Transcription section
        
        # Status panel (top left)
        status_panel = ctk.CTkFrame(
            dashboard,
            fg_color=self.colors["bg_medium"],
            corner_radius=15
        )
        status_panel.grid(row=0, column=0, sticky="nsew", padx=(20, 10), pady=(20, 10))
        
        # Status panel title
        status_title = ctk.CTkLabel(
            status_panel,
            text="System Status",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        status_title.pack(anchor="w", padx=20, pady=(15, 10))
        
        # Status indicators grid
        indicators_frame = ctk.CTkFrame(status_panel, fg_color="transparent")
        indicators_frame.pack(fill="both", expand=True, padx=20, pady=(0, 20))
        
        # Configure indicators grid
        indicators_frame.columnconfigure((0, 1), weight=1)
        indicators_frame.rowconfigure((0, 1), weight=1)
        
        # Create status indicators
        self.create_status_indicator(indicators_frame, "CPU Usage", "0%", self.colors["status_green"], 0, 0)
        self.create_status_indicator(indicators_frame, "Memory", "0%", self.colors["status_green"], 0, 1)
        self.create_status_indicator(indicators_frame, "Disk Space", "0%", self.colors["status_green"], 1, 0)
        self.create_status_indicator(indicators_frame, "Voice Status", "Idle", self.colors["status_gray"], 1, 1)
        
        # Voice assistant control panel (top right)
        control_panel = ctk.CTkFrame(
            dashboard,
            fg_color=self.colors["bg_medium"],
            corner_radius=15
        )
        control_panel.grid(row=0, column=1, sticky="nsew", padx=(10, 20), pady=(20, 10))
        
        # Control panel title
        control_title = ctk.CTkLabel(
            control_panel,
            text="Voice Assistant",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        control_title.pack(anchor="w", padx=20, pady=(15, 10))
        
        # Start/Stop button
        self.toggle_button = ctk.CTkButton(
            control_panel,
            text="Start Voice Assistant",
            command=self.toggle_voice_assistant,
            fg_color=self.colors["status_green"],
            hover_color=self._adjust_color_brightness(self.colors["status_green"], 0.8),
            height=50,
            corner_radius=10,
            font=self.fonts["subtitle"]
        )
        self.toggle_button.pack(fill="x", padx=20, pady=10)
        
        # Recording buttons frame
        recording_frame = ctk.CTkFrame(control_panel, fg_color="transparent")
        recording_frame.pack(fill="x", padx=20, pady=5)
        
        # Configure recording frame grid
        recording_frame.columnconfigure((0, 1), weight=1)
        
        # Record button
        self.record_button = ctk.CTkButton(
            recording_frame,
            text="Record",
            command=self.start_manual_recording,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            height=40
        )
        self.record_button.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        
        # Stop Recording button
        self.stop_record_button = ctk.CTkButton(
            recording_frame,
            text="Stop Recording",
            command=self.stop_manual_recording,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            height=40,
            state="disabled"
        )
        self.stop_record_button.grid(row=0, column=1, sticky="ew", padx=(5, 0))
        
        # Add synthesizer bar
        self.synth_bar = SynthesizerBar(control_panel, self.colors, self.fonts)
        
        # Voice commands section (middle)
        commands_frame = ctk.CTkFrame(
            dashboard,
            fg_color=self.colors["bg_medium"],
            corner_radius=15
        )
        commands_frame.grid(row=1, column=0, columnspan=2, sticky="nsew", padx=20, pady=10)
        
        # Commands title with clear button
        commands_header = ctk.CTkFrame(commands_frame, fg_color="transparent")
        commands_header.pack(fill="x", padx=20, pady=(15, 10))
        
        commands_title = ctk.CTkLabel(
            commands_header,
            text="Voice Commands",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        commands_title.pack(side="left")
        
        clear_commands = ctk.CTkButton(
            commands_header,
            text="Clear",
            command=lambda: self.clear_text_display("text_display"),
            width=80,
            fg_color=self.colors["accent_secondary"]
        )
        clear_commands.pack(side="right")
        
        # Commands text display
        self.text_display = ctk.CTkTextbox(
            commands_frame,
            fg_color=self.colors["bg_light"],
            text_color=self.colors["text_bright"],
            font=self.fonts["normal"],
            corner_radius=10,
            height=150
        )
        self.text_display.pack(fill="both", expand=True, padx=20, pady=(5, 15))
        
        # Configure text tags
        self.text_display._textbox.tag_configure("timestamp", foreground=self.colors["accent_secondary"])
        self.text_display._textbox.tag_configure("command", foreground=self.colors["text_bright"])
        self.text_display._textbox.tag_configure("system", foreground=self.colors["status_blue"])
        
        # Transcription section (bottom)
        transcription_frame = ctk.CTkFrame(
            dashboard,
            fg_color=self.colors["bg_medium"],
            corner_radius=15
        )
        transcription_frame.grid(row=2, column=0, columnspan=2, sticky="nsew", padx=20, pady=(10, 20))
        
        # Transcription header
        transcription_header = ctk.CTkFrame(transcription_frame, fg_color="transparent")
        transcription_header.pack(fill="x", padx=20, pady=(15, 10))
        
        transcription_title = ctk.CTkLabel(
            transcription_header,
            text="Transcribed Text",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        transcription_title.pack(side="left")
        
        clear_transcription = ctk.CTkButton(
            transcription_header,
            text="Clear",
            command=lambda: self.clear_text_display("transcription_display"),
            width=80,
            fg_color=self.colors["accent_secondary"]
        )
        clear_transcription.pack(side="right")
        
        # Transcription display
        self.transcription_display = ctk.CTkTextbox(
            transcription_frame,
            fg_color=self.colors["bg_light"],
            text_color=self.colors["text_bright"],
            font=self.fonts["normal"],
            corner_radius=10,
            height=100
        )
        self.transcription_display.pack(fill="both", expand=True, padx=20, pady=(5, 10))
        
        # Enter button frame
        enter_frame = ctk.CTkFrame(transcription_frame, fg_color="transparent")
        enter_frame.pack(fill="x", padx=20, pady=(0, 15))
        
        # Enter button
        self.enter_button = ctk.CTkButton(
            enter_frame,
            text="Enter",
            command=self.process_transcription,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            height=40,
            state="disabled"
        )
        self.enter_button.pack(side="right")

    def clear_text_display(self, display_name):
        """Clear the specified text display"""
        if hasattr(self, display_name):
            display = getattr(self, display_name)
            display.configure(state="normal")
            display.delete(1.0, "end")
            display.configure(state="disabled")

#!/usr/bin/env python3
"""
Dragon Voice GUI - Main application interface for Dragon Voice Project
"""

from whisper_integration import WhisperRecognizer
import os
import sys
import json
import time
import logging
import webbrowser
import threading
from datetime import datetime
from pathlib import Path

# GUI libraries
import tkinter as tk
from tkinter import messagebox
import customtkinter as ctk
from PIL import Image, ImageTk

# System monitoring
import psutil
import platform

# Window management
import pygetwindow as gw
import pyautogui
import sounddevice as sd
import numpy as np
import tempfile
import os
import time
import threading

# Custom components
from synthesizer_bar import SynthesizerBar

# Try to import soundfile, but don't fail if it's not available
try:
    import soundfile as sf
    SOUNDFILE_AVAILABLE = True
except ImportError:
    SOUNDFILE_AVAILABLE = False
    print("Warning: soundfile module not found. Some audio features will be limited.")

# Configure logging
logging.basicConfig(
    level=logging.WARNING,  # Changed from INFO to WARNING
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("dragon_gui.log"),
        logging.StreamHandler()
    ]
)

# Constants
DEFAULT_CONFIG_PATH = "src/config.json"
ASSETS_DIR = os.path.join("src", "assets")

# Add Whisper integration


class DragonVoiceGUI:
    """
    Main GUI class for the Dragon Voice Project

    Provides a modern, feature-rich interface for controlling the voice assistant,
    managing chatbots, and configuring system settings.
    """

    def __init__(self, config_path=DEFAULT_CONFIG_PATH):
        """Initialize the DragonVoice GUI application"""
        logging.info("Initializing DragonVoiceGUI")

        try:
            # Initialize logging
            self.setup_logging()

            # Initialize state variables
            self.recording_active = False
            self.continuous_recording = False  # Flag for continuous recording
            self.is_fullscreen = False

            # Create main application window
            self.app = ctk.CTk()
            self.app.title("DragonVoice")
            self.app.geometry("1200x800")
            self.app.minsize(900, 600)

            # Load configuration
            self.config_path = config_path
            self.config = self.load_config()
            logging.info(f"Configuration loaded from {config_path}")

            # Set up theme and colors
            self.setup_theme()

            # Initialize Whisper recognizer
            self.init_whisper_recognizer()

            # Set up UI components
            self.setup_ui()

            # Start system monitoring
            self.start_system_monitoring()

        except Exception as e:
            logging.error(f"Error initializing DragonVoiceGUI: {str(e)}")
            raise

    def setup_logging(self):
        """Set up logging configuration"""
        # Check if logging is already configured
        if not logging.getLogger().handlers:
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - %(message)s'
            )
        logging.info("Logging setup complete")

    def setup_theme(self):
        """Set up the theme and colors for the application"""
        # Set appearance mode
        ctk.set_appearance_mode("dark")

        # Define color schemes with modern, sophisticated palettes
        self.color_schemes = {
            "aurora": {  # New default theme
                "bg_dark": "#1A1B26",      # Deep space blue
                "bg_medium": "#24283B",    # Midnight blue
                "bg_light": "#2F3549",     # Slate blue
                "accent_primary": "#7AA2F7",  # Electric blue
                "accent_secondary": "#BB9AF7",  # Soft purple
                "text_bright": "#C0CAF5",  # Ice blue
                "text_normal": "#9AA5CE",  # Muted blue
                "text_dim": "#565F89",     # Dark slate
                "status_green": "#9ECE6A",  # Sage green
                "status_yellow": "#E0AF68", # Warm amber
                "status_red": "#F7768E",    # Coral pink
                "status_blue": "#7DCFFF",   # Sky blue
                "status_gray": "#414868",   # Steel gray
                "separator": "#1F2335"      # Dark separator
            },
            "quantum": {  # High contrast theme
                "bg_dark": "#151515",      # Deep black
                "bg_medium": "#1E1E1E",    # Rich black
                "bg_light": "#252525",     # Soft black
                "accent_primary": "#00FF9C",  # Neon green
                "accent_secondary": "#00B8FF",  # Electric blue
                "text_bright": "#FFFFFF",   # Pure white
                "text_normal": "#CCCCCC",   # Light gray
                "text_dim": "#808080",      # Medium gray
                "status_green": "#00FF9C",  # Neon green
                "status_yellow": "#FFD700", # Gold
                "status_red": "#FF3366",    # Hot pink
                "status_blue": "#00B8FF",   # Electric blue
                "status_gray": "#404040",   # Dark gray
                "separator": "#333333"      # Dark separator
            },
            "glacier": {  # Light theme
                "bg_dark": "#E8EEF2",      # Ice white
                "bg_medium": "#D5E3EC",    # Glacier blue
                "bg_light": "#C2D8E9",     # Soft blue
                "accent_primary": "#2B7BB9",  # Deep blue
                "accent_secondary": "#5C6BC0",  # Royal blue
                "text_bright": "#1A1A1A",   # Near black
                "text_normal": "#2D2D2D",   # Dark gray
                "text_dim": "#5D5D5D",      # Medium gray
                "status_green": "#2E7D32",  # Forest green
                "status_yellow": "#F9A825", # Sunflower
                "status_red": "#C62828",    # Ruby red
                "status_blue": "#1565C0",   # Ocean blue
                "status_gray": "#90A4AE",   # Cool gray
                "separator": "#B0BEC5"      # Light separator
            }
        }

        # Set default color scheme
        self.colors = self.color_schemes["aurora"]

        # Define modern font system
        self.fonts = {
            "header": ctk.CTkFont(family="Segoe UI", size=32, weight="bold"),
            "title": ctk.CTkFont(family="Segoe UI", size=24, weight="bold"),
            "subtitle": ctk.CTkFont(family="Segoe UI", size=18, weight="bold"),
            "normal": ctk.CTkFont(family="Segoe UI", size=14),
            "small": ctk.CTkFont(family="Segoe UI", size=12),
            "tiny": ctk.CTkFont(family="Segoe UI", size=10),
            "mono": ctk.CTkFont(family="JetBrains Mono", size=12),
            "large": ctk.CTkFont(family="Segoe UI", size=20),
            "display": ctk.CTkFont(family="Segoe UI", size=40, weight="bold"),
            "button": ctk.CTkFont(family="Segoe UI", size=14, weight="bold"),
            "caption": ctk.CTkFont(family="Segoe UI", size=11),
            "code": ctk.CTkFont(family="JetBrains Mono", size=13)
        }

        # Define corner radius system
        self.corners = {
            "small": 4,
            "medium": 8,
            "large": 12,
            "xl": 16,
            "pill": 24
        }

        # Define spacing system
        self.spacing = {
            "xs": 4,
            "small": 8,
            "medium": 16,
            "large": 24,
            "xl": 32,
            "xxl": 48
        }

        # Define shadow system
        self.shadows = {
            "small": "0 2px 4px rgba(0,0,0,0.1)",
            "medium": "0 4px 8px rgba(0,0,0,0.15)",
            "large": "0 8px 16px rgba(0,0,0,0.2)"
        }

        # Animation durations
        self.animations = {
            "fast": 150,
            "normal": 250,
            "slow": 350
        }

    def init_whisper_recognizer(self):
        """Initialize the Whisper recognizer"""
        try:
            # Initialize API keys from environment or config
            self.openai_api_key = os.environ.get("OPENAI_API_KEY", "")
            if not self.openai_api_key and "openai_api_key" in self.config:
                self.openai_api_key = self.config["openai_api_key"]
                os.environ["OPENAI_API_KEY"] = self.openai_api_key

            # Initialize WhisperRecognizer with error handling
            if self.openai_api_key:
                self.whisper_recognizer = WhisperRecognizer(
                    api_key=self.openai_api_key)
                logging.info("WhisperRecognizer initialized successfully")
            else:
                logging.warning(
                    "No OpenAI API key found, WhisperRecognizer not initialized")
                self.whisper_recognizer = None
        except Exception as e:
            logging.error(f"Failed to initialize WhisperRecognizer: {str(e)}")
            self.whisper_recognizer = None

    def setup_ui(self):
        """Set up the main user interface"""
        try:
            # Create main container
            self.main_container = ctk.CTkFrame(self.app)
            self.main_container.pack(fill="both", expand=True)
            
            # Configure grid
            self.main_container.grid_columnconfigure(0, weight=1)
            self.main_container.grid_rowconfigure(1, weight=1)  # Content area expands
            
            # Create UI sections
            self.create_header()      # Row 0
            self.create_content()     # Row 1
            self.create_footer()      # Row 2
            
            # Start system monitoring
            self.start_system_monitoring()
            
            # Initial status update
            self.update_status("Ready")
            
        except Exception as e:
            logging.error(f"Error setting up UI: {str(e)}", exc_info=True)
            raise  # Re-raise the exception for proper error handling

    def create_content(self):
        """Create the main content area with tabs"""
        # Create content frame
        self.content_frame = ctk.CTkFrame(self.main_container, fg_color="transparent")
        self.content_frame.grid(row=1, column=0, sticky="nsew", padx=20, pady=10)
        
        # Configure content frame grid
        self.content_frame.grid_rowconfigure(0, weight=1)
        self.content_frame.grid_columnconfigure(0, weight=1)
        
        # Create tab view
        self.tab_view = ctk.CTkTabview(
            self.content_frame,
            fg_color=self.colors["bg_dark"],
            segmented_button_fg_color=self.colors["bg_medium"],
            segmented_button_selected_color=self.colors["accent_primary"],
            segmented_button_selected_hover_color=self.colors["accent_secondary"],
            segmented_button_unselected_color=self.colors["bg_medium"],
            segmented_button_unselected_hover_color=self.colors["bg_light"]
        )
        self.tab_view.grid(row=0, column=0, sticky="nsew")
        
        # Define tabs with icons
        tabs = [
            ("Dashboard", "üìä"),
            ("Chatbots", "ü§ñ"),
            ("History", "üìú"),
            ("Configuration", "‚öôÔ∏è"),
            ("About", "‚ÑπÔ∏è")
        ]
        
        # Add tabs
        for tab_name, icon in tabs:
            self.tab_view.add(tab_name)
            tab = self.tab_view.tab(tab_name)
            tab.configure(fg_color=self.colors["bg_dark"])
            
            # Configure tab grid
            tab.grid_rowconfigure(0, weight=1)
            tab.grid_columnconfigure(0, weight=1)
            
            # Add icon to tab button
            if hasattr(self.tab_view, "_segmented_button"):
                button = self.tab_view._segmented_button
                button._buttons_dict[tab_name].configure(
                    text=f"{icon} {tab_name}",
                    font=self.fonts["button"],
                    height=32,
                    corner_radius=self.corners["medium"]
                )
        
        # Set default tab
        self.tab_view.set("Dashboard")
        
        # Create tab contents
        self.create_dashboard_tab()
        self.create_chatbots_tab()
        self.create_history_tab()
        self.create_config_tab()
        self.create_about_tab()

    def create_header(self):
        """Create the application header"""
        # Create header frame
        self.header_frame = ctk.CTkFrame(
            self.main_container,
            fg_color=self.colors["bg_dark"],
            height=80
        )
        self.header_frame.grid(row=0, column=0, sticky="ew")
        self.header_frame.grid_propagate(False)
        
        # Configure header grid
        self.header_frame.grid_columnconfigure(1, weight=1)  # Center section expands
        
        # Left section - Logo and title
        left_section = ctk.CTkFrame(self.header_frame, fg_color="transparent")
        left_section.grid(row=0, column=0, padx=20, pady=10, sticky="w")
        
        # Try to load logo
        try:
            assets_dir = os.path.join("src", "assets")
            logo_path = os.path.join(assets_dir, "dragon_logo.png")
            
            # Create assets directory if it doesn't exist
            if not os.path.exists(assets_dir):
                os.makedirs(assets_dir)
                logging.warning(f"Created missing assets directory: {assets_dir}")
            
            if os.path.exists(logo_path):
                logo_image = ctk.CTkImage(
                    light_image=Image.open(logo_path),
                    dark_image=Image.open(logo_path),
                    size=(36, 36)
                )
                logo_label = ctk.CTkLabel(
                    left_section,
                    image=logo_image,
                    text=""
                )
                logo_label.pack(side="left", padx=(0, 10))
            else:
                # Create text-based logo as fallback
                logo_label = ctk.CTkLabel(
                    left_section,
                    text="üêâ",
                    font=("Segoe UI Emoji", 24),
                    text_color=self.colors["accent_primary"]
                )
                logo_label.pack(side="left", padx=(0, 10))
                logging.warning(f"Logo file not found: {logo_path}, using emoji fallback")
        except Exception as e:
            logging.error(f"Failed to load logo: {str(e)}")
            # Create text-based logo as fallback
            logo_label = ctk.CTkLabel(
                left_section,
                text="üêâ",
                font=("Segoe UI Emoji", 24),
                text_color=self.colors["accent_primary"]
            )
            logo_label.pack(side="left", padx=(0, 10))
        
        # App title
        title_label = ctk.CTkLabel(
            left_section,
            text="DragonVoice",
            font=self.fonts["header"],
            text_color=self.colors["text_bright"]
        )
        title_label.pack(side="left")
        
        # Version pill
        version_pill = ctk.CTkFrame(
            left_section,
            fg_color=self.colors["accent_primary"],
            corner_radius=self.corners["pill"]
        )
        version_pill.pack(side="left", padx=10)
        
        version_label = ctk.CTkLabel(
            version_pill,
            text="v2.0",
            font=self.fonts["caption"],
            text_color=self.colors["text_bright"]
        )
        version_label.pack(padx=10, pady=2)
        
        # Center section - Status
        center_section = ctk.CTkFrame(self.header_frame, fg_color="transparent")
        center_section.grid(row=0, column=1, sticky="ew")
        
        # Right section - Controls
        right_section = ctk.CTkFrame(self.header_frame, fg_color="transparent")
        right_section.grid(row=0, column=2, padx=20, pady=10, sticky="e")
        
        # Microphone selector
        mic_frame = ctk.CTkFrame(
            right_section,
            fg_color=self.colors["bg_light"],
            corner_radius=self.corners["medium"]
        )
        mic_frame.pack(side="left", padx=(0, 10))
        
        mic_label = ctk.CTkLabel(
            mic_frame,
            text="üé§",
            font=self.fonts["normal"]
        )
        mic_label.pack(side="left", padx=10, pady=5)
        
        self.mic_var = ctk.StringVar(value="Default Microphone")
        self.mic_dropdown = ctk.CTkOptionMenu(
            mic_frame,
            values=["Default Microphone"],
            variable=self.mic_var,
            width=140,
            dynamic_resizing=True
        )
        self.mic_dropdown.pack(side="left", padx=(0, 10), pady=5)
        
        # Control buttons
        for icon, command in [
            ("üé®", self.toggle_theme),
            ("‚öôÔ∏è", self.show_settings),
            ("‚ùî", self.show_help)
        ]:
            btn = ctk.CTkButton(
                right_section,
                text=icon,
                width=34,
                height=34,
                corner_radius=self.corners["medium"],
                fg_color=self.colors["bg_light"],
                hover_color=self.colors["accent_primary"],
                command=command
            )
            btn.pack(side="left", padx=5)

    def create_footer(self):
        """Create the application footer"""
        # Create footer frame
        self.footer = ctk.CTkFrame(
            self.main_container,
            fg_color=self.colors["bg_dark"],
            height=28
        )
        self.footer.grid(row=2, column=0, sticky="ew")
        self.footer.grid_propagate(False)
        
        # Configure footer grid
        self.footer.grid_columnconfigure(1, weight=1)  # Center section expands
        
        # Left section - Status
        status_frame = ctk.CTkFrame(self.footer, fg_color="transparent")
        status_frame.grid(row=0, column=0, padx=20, sticky="w")
        
        self.status_dot = ctk.CTkLabel(
            status_frame,
            text="‚óè",
            font=self.fonts["small"],
            text_color=self.colors["status_green"],
            width=20
        )
        self.status_dot.pack(side="left")
        
        self.status_label = ctk.CTkLabel(
            status_frame,
            text="Ready",
            font=self.fonts["caption"],
            text_color=self.colors["text_dim"]
        )
        self.status_label.pack(side="left", padx=5)
        
        # Center section - System metrics
        metrics_frame = ctk.CTkFrame(self.footer, fg_color="transparent")
        metrics_frame.grid(row=0, column=1, sticky="ew")
        
        metrics = [
            ("CPU", "0%", self.colors["status_green"]),
            ("RAM", "0%", self.colors["status_green"]),
            ("Disk", "0%", self.colors["status_green"])
        ]
        
        for i, (label, value, color) in enumerate(metrics):
            metric_frame = ctk.CTkFrame(metrics_frame, fg_color="transparent")
            metric_frame.pack(side="left", padx=20)
            
            ctk.CTkLabel(
                metric_frame,
                text=label,
                font=self.fonts["caption"],
                text_color=self.colors["text_dim"]
            ).pack(side="left")
            
            value_label = ctk.CTkLabel(
                metric_frame,
                text=value,
                font=self.fonts["caption"],
                text_color=color
            )
            value_label.pack(side="left", padx=5)
            setattr(self, f'metric_value_{i}', value_label)
        
        # Right section - Build info
        build_frame = ctk.CTkFrame(self.footer, fg_color="transparent")
        build_frame.grid(row=0, column=2, padx=20, sticky="e")
        
        build_label = ctk.CTkLabel(
            build_frame,
            text="Build 2024.03",
            font=self.fonts["caption"],
            text_color=self.colors["text_dim"]
        )
        build_label.pack()

    def create_dashboard_tab(self):
        """Create the dashboard tab content"""
        dashboard = self.tab_view.tab("Dashboard")
        
        # Configure grid
        dashboard.grid_columnconfigure(0, weight=2)  # Status panel
        dashboard.grid_columnconfigure(1, weight=1)  # Control panel
        dashboard.grid_rowconfigure(1, weight=1)     # Voice commands section
        dashboard.grid_rowconfigure(2, weight=1)     # Transcription section
        
        # Status panel (top left)
        status_panel = ctk.CTkFrame(
            dashboard,
            fg_color=self.colors["bg_medium"],
            corner_radius=15
        )
        status_panel.grid(row=0, column=0, sticky="nsew", padx=(20, 10), pady=(20, 10))
        
        # Status panel title
        status_title = ctk.CTkLabel(
            status_panel,
            text="System Status",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        status_title.pack(anchor="w", padx=20, pady=(15, 10))
        
        # Status indicators grid
        indicators_frame = ctk.CTkFrame(status_panel, fg_color="transparent")
        indicators_frame.pack(fill="both", expand=True, padx=20, pady=(0, 20))
        
        # Configure indicators grid
        indicators_frame.columnconfigure((0, 1), weight=1)
        indicators_frame.rowconfigure((0, 1), weight=1)
        
        # Create status indicators
        self.create_status_indicator(indicators_frame, "CPU Usage", "0%", self.colors["status_green"], 0, 0)
        self.create_status_indicator(indicators_frame, "Memory", "0%", self.colors["status_green"], 0, 1)
        self.create_status_indicator(indicators_frame, "Disk Space", "0%", self.colors["status_green"], 1, 0)
        self.create_status_indicator(indicators_frame, "Voice Status", "Idle", self.colors["status_gray"], 1, 1)
        
        # Voice assistant control panel (top right)
        control_panel = ctk.CTkFrame(
            dashboard,
            fg_color=self.colors["bg_medium"],
            corner_radius=15
        )
        control_panel.grid(row=0, column=1, sticky="nsew", padx=(10, 20), pady=(20, 10))
        
        # Control panel title
        control_title = ctk.CTkLabel(
            control_panel,
            text="Voice Assistant",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        control_title.pack(anchor="w", padx=20, pady=(15, 10))
        
        # Start/Stop button
        self.toggle_button = ctk.CTkButton(
            control_panel,
            text="Start Voice Assistant",
            command=self.toggle_voice_assistant,
            fg_color=self.colors["status_green"],
            hover_color=self._adjust_color_brightness(self.colors["status_green"], 0.8),
            height=50,
            corner_radius=10,
            font=self.fonts["subtitle"]
        )
        self.toggle_button.pack(fill="x", padx=20, pady=10)
        
        # Recording buttons frame
        recording_frame = ctk.CTkFrame(control_panel, fg_color="transparent")
        recording_frame.pack(fill="x", padx=20, pady=5)
        
        # Configure recording frame grid
        recording_frame.columnconfigure((0, 1), weight=1)
        
        # Record button
        self.record_button = ctk.CTkButton(
            recording_frame,
            text="Record",
            command=self.start_manual_recording,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            height=40
        )
        self.record_button.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        
        # Stop Recording button
        self.stop_record_button = ctk.CTkButton(
            recording_frame,
            text="Stop Recording",
            command=self.stop_manual_recording,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            height=40,
            state="disabled"
        )
        self.stop_record_button.grid(row=0, column=1, sticky="ew", padx=(5, 0))
        
        # Add synthesizer bar
        self.synth_bar = SynthesizerBar(control_panel, self.colors, self.fonts)
        
        # Voice commands section (middle)
        commands_frame = ctk.CTkFrame(
            dashboard,
            fg_color=self.colors["bg_medium"],
            corner_radius=15
        )
        commands_frame.grid(row=1, column=0, columnspan=2, sticky="nsew", padx=20, pady=10)
        
        # Commands title with clear button
        commands_header = ctk.CTkFrame(commands_frame, fg_color="transparent")
        commands_header.pack(fill="x", padx=20, pady=(15, 10))
        
        commands_title = ctk.CTkLabel(
            commands_header,
            text="Voice Commands",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        commands_title.pack(side="left")
        
        clear_commands = ctk.CTkButton(
            commands_header,
            text="Clear",
            command=lambda: self.clear_text_display("text_display"),
            width=80,
            fg_color=self.colors["accent_secondary"]
        )
        clear_commands.pack(side="right")
        
        # Commands text display
        self.text_display = ctk.CTkTextbox(
            commands_frame,
            fg_color=self.colors["bg_light"],
            text_color=self.colors["text_bright"],
            font=self.fonts["normal"],
            corner_radius=10,
            height=150
        )
        self.text_display.pack(fill="both", expand=True, padx=20, pady=(5, 15))
        
        # Configure text tags
        self.text_display._textbox.tag_configure("timestamp", foreground=self.colors["accent_secondary"])
        self.text_display._textbox.tag_configure("command", foreground=self.colors["text_bright"])
        self.text_display._textbox.tag_configure("system", foreground=self.colors["status_blue"])
        
        # Transcription section (bottom)
        transcription_frame = ctk.CTkFrame(
            dashboard,
            fg_color=self.colors["bg_medium"],
            corner_radius=15
        )
        transcription_frame.grid(row=2, column=0, columnspan=2, sticky="nsew", padx=20, pady=(10, 20))
        
        # Transcription header
        transcription_header = ctk.CTkFrame(transcription_frame, fg_color="transparent")
        transcription_header.pack(fill="x", padx=20, pady=(15, 10))
        
        transcription_title = ctk.CTkLabel(
            transcription_header,
            text="Transcribed Text",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        transcription_title.pack(side="left")
        
        clear_transcription = ctk.CTkButton(
            transcription_header,
            text="Clear",
            command=lambda: self.clear_text_display("transcription_display"),
            width=80,
            fg_color=self.colors["accent_secondary"]
        )
        clear_transcription.pack(side="right")
        
        # Transcription display
        self.transcription_display = ctk.CTkTextbox(
            transcription_frame,
            fg_color=self.colors["bg_light"],
            text_color=self.colors["text_bright"],
            font=self.fonts["normal"],
            corner_radius=10,
            height=100
        )
        self.transcription_display.pack(fill="both", expand=True, padx=20, pady=(5, 10))
        
        # Enter button frame
        enter_frame = ctk.CTkFrame(transcription_frame, fg_color="transparent")
        enter_frame.pack(fill="x", padx=20, pady=(0, 15))
        
        # Enter button
        self.enter_button = ctk.CTkButton(
            enter_frame,
            text="Enter",
            command=self.process_transcription,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            height=40,
            state="disabled"
        )
        self.enter_button.pack(side="right")

    def clear_text_display(self, display_name):
        """Clear the specified text display"""
        if hasattr(self, display_name):
            display = getattr(self, display_name)
            display.configure(state="normal")
            display.delete(1.0, "end")
            display.configure(state="disabled")

    def create_chatbots_tab(self):
        """Create the chatbots tab content"""
        chatbots = self.tab_view.tab("Chatbots")
        
        # Configure grid
        chatbots.grid_columnconfigure(0, weight=1)
        chatbots.grid_rowconfigure(2, weight=1)  # Chatbot list expands
        
        # Title and add button row
        title_frame = ctk.CTkFrame(chatbots, fg_color="transparent")
        title_frame.grid(row=0, column=0, sticky="ew", padx=20, pady=(20, 10))
        
        # Configure title frame grid
        title_frame.grid_columnconfigure(1, weight=1)
        
        # Title
        title_label = ctk.CTkLabel(
            title_frame,
            text="Chatbot Management",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        title_label.grid(row=0, column=0, sticky="w")
        
        # Add chatbot button
        add_button = ctk.CTkButton(
            title_frame,
            text="Add New Chatbot",
            command=self.show_add_chatbot_dialog,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            width=150
        )
        add_button.grid(row=0, column=2, sticky="e")
        
        # Search bar
        search_frame = ctk.CTkFrame(
            chatbots,
            fg_color=self.colors["bg_medium"],
            corner_radius=10,
            height=50
        )
        search_frame.grid(row=1, column=0, sticky="ew", padx=20, pady=10)
        search_frame.grid_propagate(False)
        
        # Configure search frame grid
        search_frame.grid_columnconfigure(1, weight=1)
        
        # Search icon
        search_icon = ctk.CTkLabel(
            search_frame,
            text="üîç",
            font=self.fonts["normal"],
            width=30
        )
        search_icon.grid(row=0, column=0, padx=(15, 0), pady=10)
        
        # Search entry
        self.search_var = ctk.StringVar()
        self.search_var.trace_add("write", lambda *args: self.filter_chatbot_list())
        search_entry = ctk.CTkEntry(
            search_frame,
            placeholder_text="Search chatbots...",
            textvariable=self.search_var,
            border_width=0,
            fg_color="transparent",
            height=40
        )
        search_entry.grid(row=0, column=1, sticky="ew", padx=10)
        
        # Chatbot list
        self.chatbot_list_frame = ctk.CTkScrollableFrame(
            chatbots,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        self.chatbot_list_frame.grid(row=2, column=0, sticky="nsew", padx=20, pady=(0, 20))
        
        # Configure list frame grid
        self.chatbot_list_frame.grid_columnconfigure(0, weight=1)
        
        # Add header
        header = ctk.CTkFrame(
            self.chatbot_list_frame,
            fg_color=self.colors["bg_dark"],
            corner_radius=10,
            height=40
        )
        header.grid(row=0, column=0, sticky="ew", pady=(0, 10))
        header.grid_propagate(False)
        
        # Configure header grid
        header.grid_columnconfigure((0, 1, 2), weight=1)
        
        # Header labels
        for i, text in enumerate(["Name", "Type", "Status"]):
            label = ctk.CTkLabel(
                header,
                text=text,
                font=self.fonts["subtitle"],
                text_color=self.colors["text_bright"]
            )
            label.grid(row=0, column=i, padx=20, pady=10)
        
        # Refresh chatbot list
        self.refresh_chatbots()

    def add_chatbot_list_item(self, name, config):
        """Add a single chatbot item to the list"""
        # Get next row index
        row = len(self.chatbot_list_frame._scrollable_frame_children)
        
        # Create item frame
        item = ctk.CTkFrame(
            self.chatbot_list_frame,
            fg_color=self.colors["bg_dark"],
            corner_radius=10,
            height=70
        )
        item.grid(row=row, column=0, sticky="ew", padx=5, pady=5)
        item.grid_propagate(False)
        
        # Configure item grid
        item.grid_columnconfigure(1, weight=1)  # Name/type section expands
        
        # Icon frame
        icon_frame = ctk.CTkFrame(
            item,
            fg_color=config.get("color", self.colors["accent_primary"]),
            width=40,
            height=40,
            corner_radius=20
        )
        icon_frame.grid(row=0, column=0, padx=15, pady=15)
        icon_frame.grid_propagate(False)
        
        # Icon label
        icon_label = ctk.CTkLabel(
            icon_frame,
            text=config.get("icon", "ü§ñ"),
            font=self.fonts["large"]
        )
        icon_label.place(relx=0.5, rely=0.5, anchor="center")
        
        # Name and type section
        info_frame = ctk.CTkFrame(item, fg_color="transparent")
        info_frame.grid(row=0, column=1, sticky="nsw", pady=10)
        
        # Name
        name_label = ctk.CTkLabel(
            info_frame,
            text=name,
            font=self.fonts["subtitle"],
            text_color=self.colors["text_bright"]
        )
        name_label.grid(row=0, column=0, sticky="w")
        
        # Type
        type_label = ctk.CTkLabel(
            info_frame,
            text=config.get("type", "Unknown"),
            font=self.fonts["small"],
            text_color=self.colors["text_dim"]
        )
        type_label.grid(row=1, column=0, sticky="w")
        
        # Status section
        status_frame = ctk.CTkFrame(item, fg_color="transparent")
        status_frame.grid(row=0, column=2, padx=15)
        
        # Status indicator
        status_color = self.colors["status_green"] if config.get("status") == "Ready" else self.colors["status_red"]
        status_dot = ctk.CTkLabel(
            status_frame,
            text="‚óè",
            font=self.fonts["large"],
            text_color=status_color
        )
        status_dot.grid(row=0, column=0, padx=5)
        
        # Status text
        status_label = ctk.CTkLabel(
            status_frame,
            text=config.get("status", "Unknown"),
            font=self.fonts["small"],
            text_color=status_color
        )
        status_label.grid(row=0, column=1)
        
        # Add hover effect
        def on_enter(e):
            item.configure(fg_color=self.colors["bg_light"])
            
        def on_leave(e):
            item.configure(fg_color=self.colors["bg_dark"])
            
        item.bind("<Enter>", on_enter)
        item.bind("<Leave>", on_leave)
        
        # Make item clickable
        item.bind("<Button-1>", lambda e: self.show_chatbot_settings(name, config))

    def delete_chatbot(self, name):
        """Delete a chatbot from the configuration"""
        if name in self.config.get("chatbots", {}):
            del self.config["chatbots"][name]
            self.save_configuration()
            self.refresh_chatbot_list()
            # Also refresh the dashboard
            self.add_sample_chatbot_cards()

    def run(self):
        """Run the application main loop"""
        try:
            # Log startup
            logging.info("Starting DragonVoice application")

            # Update status
            self.update_status("Application started successfully")

            # Start the main event loop
            self.app.mainloop()

        except Exception as e:
            logging.error(f"Error in main loop: {str(e)}")
            raise

    def create_help_getting_started(self, parent):
        """Create the getting started help content"""
        # Welcome section
        welcome_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        welcome_frame.pack(fill="x", padx=20, pady=10)

        welcome_label = ctk.CTkLabel(
            welcome_frame,
            text="Welcome to DragonVoice",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        welcome_label.pack(anchor="w", padx=15, pady=(10, 5))

        welcome_text = ctk.CTkTextbox(
            welcome_frame,
            height=100,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        welcome_text.pack(fill="x", padx=15, pady=(0, 10))
        welcome_text.insert(
            "1.0",
            """DragonVoice is a powerful voice-controlled interface for interacting with multiple AI chatbots. This guide will help you get started with the basic features and setup.""")
        welcome_text.configure(state="disabled")

        # Quick Start Guide
        quickstart_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        quickstart_frame.pack(fill="x", padx=20, pady=10)

        quickstart_label = ctk.CTkLabel(
            quickstart_frame,
            text="Quick Start Guide",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        quickstart_label.pack(anchor="w", padx=15, pady=(10, 5))

        steps_text = ctk.CTkTextbox(
            quickstart_frame,
            height=200,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        steps_text.pack(fill="x", padx=15, pady=(0, 10))
        steps_text.insert("1.0", """1. Configure Your Chatbots
‚Ä¢ Click the Settings button (‚öôÔ∏è) in the top right
‚Ä¢ Go to the Chatbots tab
‚Ä¢ Click "Add New Chatbot" and enter your API keys

2. Start Voice Assistant
‚Ä¢ Click the "Start Voice Assistant" button in the header
‚Ä¢ Wait for the status to show "Ready"
‚Ä¢ Say your wake word (default: "Hey Dragon")

3. Issue Commands
‚Ä¢ After the wake word, speak your command
‚Ä¢ Example: "Ask what are the latest treatments for hypertension"
‚Ä¢ The command will be sent to the appropriate chatbot

4. View Responses
‚Ä¢ Responses appear in the chatbot windows
‚Ä¢ You can interact with multiple chatbots simultaneously
‚Ä¢ Use voice commands to switch between chatbots""")
        steps_text.configure(state="disabled")

    def create_help_voice_commands(self, parent):
        """Create the voice commands help content"""
        # Available Commands
        commands_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        commands_frame.pack(fill="x", padx=20, pady=10)

        commands_label = ctk.CTkLabel(
            commands_frame,
            text="Available Voice Commands",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        commands_label.pack(anchor="w", padx=15, pady=(10, 5))

        commands_text = ctk.CTkTextbox(
            commands_frame,
            height=400,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        commands_text.pack(fill="x", padx=15, pady=(0, 10))
        commands_text.insert("1.0", """Basic Commands:
‚Ä¢ "Hey Dragon" - Wake word to start listening
‚Ä¢ "Ask [question]" - Send a question to the active chatbot
‚Ä¢ "Switch to [chatbot name]" - Change the active chatbot
‚Ä¢ "Stop listening" - Deactivate voice recognition
‚Ä¢ "Clear chat" - Clear the current conversation

Chatbot Control:
‚Ä¢ "New conversation" - Start a fresh chat session
‚Ä¢ "Save conversation" - Save the current chat history
‚Ä¢ "Load conversation" - Restore a previous chat session
‚Ä¢ "Export as PDF" - Export the conversation to PDF

Window Management:
‚Ä¢ "Maximize window" - Expand the current chatbot window
‚Ä¢ "Minimize window" - Minimize the current chatbot window
‚Ä¢ "Arrange windows" - Organize all chatbot windows
‚Ä¢ "Close window" - Close the current chatbot window

System Commands:
‚Ä¢ "Open settings" - Show the settings dialog
‚Ä¢ "Show help" - Display this help window
‚Ä¢ "Check status" - Report system status
‚Ä¢ "Exit program" - Close DragonVoice

Tips:
‚Ä¢ Speak clearly and at a normal pace
‚Ä¢ Wait for the "Listening..." indicator
‚Ä¢ You can customize the wake word in settings
‚Ä¢ Commands are case-insensitive""")
        commands_text.configure(state="disabled")

    def create_help_chatbots(self, parent):
        """Create the chatbots help content"""
        # Chatbot Overview
        overview_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        overview_frame.pack(fill="x", padx=20, pady=10)

        overview_label = ctk.CTkLabel(
            overview_frame,
            text="Working with Chatbots",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        overview_label.pack(anchor="w", padx=15, pady=(10, 5))

        overview_text = ctk.CTkTextbox(
            overview_frame,
            height=300,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        overview_text.pack(fill="x", padx=15, pady=(0, 10))
        overview_text.insert(
            "1.0", """DragonVoice supports multiple AI chatbots, allowing you to:
‚Ä¢ Interact with different AI models simultaneously
‚Ä¢ Compare responses across different chatbots
‚Ä¢ Use specialized models for specific tasks
‚Ä¢ Maintain separate conversation contexts

Supported Chatbots:
1. GPT (OpenAI)
   ‚Ä¢ Requires OpenAI API key
   ‚Ä¢ Supports GPT-3.5 and GPT-4
   ‚Ä¢ Best for general knowledge and coding

2. Claude (Anthropic)
   ‚Ä¢ Requires Anthropic API key
   ‚Ä¢ Excellent for analysis and writing
   ‚Ä¢ Strong ethical considerations

3. Gemini (Google)
   ‚Ä¢ Requires Google API key
   ‚Ä¢ Good at mathematical reasoning
   ‚Ä¢ Supports image understanding

4. Custom Chatbots
   ‚Ä¢ Add your own API integrations
   ‚Ä¢ Configure custom endpoints
   ‚Ä¢ Define specialized behaviors

Setting Up Chatbots:
1. Obtain API keys from providers
2. Add chatbots in Settings > Chatbots
3. Configure any special parameters
4. Test the connection

Best Practices:
‚Ä¢ Keep API keys secure
‚Ä¢ Monitor usage and costs
‚Ä¢ Regular backup conversations
‚Ä¢ Update chatbot configs as needed""")
        overview_text.configure(state="disabled")

    def create_help_troubleshooting(self, parent):
        """Create the troubleshooting help content"""
        # Common Issues
        issues_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        issues_frame.pack(fill="x", padx=20, pady=10)

        issues_label = ctk.CTkLabel(
            issues_frame,
            text="Common Issues",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        issues_label.pack(anchor="w", padx=15, pady=(10, 5))

        issues_text = ctk.CTkTextbox(
            issues_frame,
            height=400,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        issues_text.pack(fill="x", padx=15, pady=(0, 10))
        issues_text.insert("1.0", """Voice Recognition Issues:
1. Microphone Not Detected
   ‚Ä¢ Check microphone connections
   ‚Ä¢ Verify Windows permissions
   ‚Ä¢ Select correct input device in settings
   ‚Ä¢ Try restarting the application

2. Poor Recognition Accuracy
   ‚Ä¢ Adjust microphone sensitivity
   ‚Ä¢ Reduce background noise
   ‚Ä¢ Speak clearly and at normal pace
   ‚Ä¢ Check for latest updates

Chatbot Connection Problems:
1. API Key Errors
   ‚Ä¢ Verify API key is valid
   ‚Ä¢ Check for sufficient credits
   ‚Ä¢ Ensure correct API endpoint
   ‚Ä¢ Look for error messages in logs

2. Slow Responses
   ‚Ä¢ Check internet connection
   ‚Ä¢ Verify server status
   ‚Ä¢ Adjust timeout settings
   ‚Ä¢ Consider upgrading API tier

Interface Issues:
1. Display Problems
   ‚Ä¢ Update graphics drivers
   ‚Ä¢ Check resolution settings
   ‚Ä¢ Try different theme
   ‚Ä¢ Restart application

2. Performance Issues
   ‚Ä¢ Close unused applications
   ‚Ä¢ Check CPU/memory usage
   ‚Ä¢ Reduce number of active chatbots
   ‚Ä¢ Clear conversation history

Getting Help:
‚Ä¢ Check application logs
‚Ä¢ Visit our support forum
‚Ä¢ Submit bug reports
‚Ä¢ Contact technical support""")
        issues_text.configure(state="disabled")

    def create_about_tab(self):
        """Create the about tab content"""
        about = self.tab_view.tab("About")
        
        # Configure grid
        about.grid_columnconfigure(0, weight=1)
        about.grid_rowconfigure(1, weight=1)  # Content area expands
        
        # Title section
        title_frame = ctk.CTkFrame(about, fg_color="transparent")
        title_frame.grid(row=0, column=0, sticky="ew", padx=20, pady=(20, 10))
        
        # App logo
        logo_label = ctk.CTkLabel(
            title_frame,
            text="üêâ",
            font=self.fonts["display"],
            text_color=self.colors["accent_primary"]
        )
        logo_label.pack(anchor="center", pady=10)
        
        # App title
        title_label = ctk.CTkLabel(
            title_frame,
            text="DragonVoice",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        title_label.pack(anchor="center")
        
        # Version
        version_label = ctk.CTkLabel(
            title_frame,
            text="Version 2.0",
            font=self.fonts["small"],
            text_color=self.colors["text_dim"]
        )
        version_label.pack(anchor="center", pady=(0, 10))
        
        # Create scrollable content area
        content_frame = ctk.CTkScrollableFrame(
            about,
            fg_color="transparent"
        )
        content_frame.grid(row=1, column=0, sticky="nsew", padx=20, pady=(0, 20))
        
        # Configure content grid
        content_frame.grid_columnconfigure(0, weight=1)
        
        # Description section
        description_frame = ctk.CTkFrame(
            content_frame,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        description_frame.grid(row=0, column=0, sticky="ew", pady=(0, 10))
        
        description_label = ctk.CTkLabel(
            description_frame,
            text="DragonVoice is an advanced voice assistant that integrates with multiple AI chatbots.\n"
                 "It provides a seamless voice interface for interacting with AI models and controlling your computer.",
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"],
            wraplength=800,
            justify="left"
        )
        description_label.pack(padx=20, pady=20)
        
        # Features section
        features_frame = ctk.CTkFrame(
            content_frame,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        features_frame.grid(row=1, column=0, sticky="ew", pady=(0, 10))
        
        features_title = ctk.CTkLabel(
            features_frame,
            text="Key Features",
            font=self.fonts["subtitle"],
            text_color=self.colors["text_bright"]
        )
        features_title.pack(anchor="w", padx=20, pady=(15, 10))
        
        features = [
            "üé§ Voice recognition with OpenAI Whisper",
            "ü§ñ Multiple AI chatbot integrations",
            "‚å®Ô∏è System control through voice commands",
            "üìä Real-time system monitoring",
            "üé® Customizable themes and appearance",
            "üîß Advanced configuration options"
        ]
        
        for feature in features:
            feature_label = ctk.CTkLabel(
                features_frame,
                text=feature,
                font=self.fonts["normal"],
                text_color=self.colors["text_normal"],
                anchor="w"
            )
            feature_label.pack(anchor="w", padx=20, pady=5)
        
        # Credits section
        credits_frame = ctk.CTkFrame(
            content_frame,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        credits_frame.grid(row=2, column=0, sticky="ew", pady=(0, 10))
        
        credits_title = ctk.CTkLabel(
            credits_frame,
            text="Credits",
            font=self.fonts["subtitle"],
            text_color=self.colors["text_bright"]
        )
        credits_title.pack(anchor="w", padx=20, pady=(15, 10))
        
        credits_text = ctk.CTkLabel(
            credits_frame,
            text="Developed by: DragonVoice Team\n"
                 "UI Framework: CustomTkinter\n"
                 "Voice Recognition: OpenAI Whisper\n"
                 "Special thanks to all contributors and testers",
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"],
            justify="left"
        )
        credits_text.pack(anchor="w", padx=20, pady=(0, 15))
        
        # Links section
        links_frame = ctk.CTkFrame(
            content_frame,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        links_frame.grid(row=3, column=0, sticky="ew")
        
        # Configure links grid
        links_frame.grid_columnconfigure((0, 1, 2), weight=1)
        
        # Website button
        website_btn = ctk.CTkButton(
            links_frame,
            text="Visit Website",
            command=lambda: webbrowser.open("https://dragonvoice.ai"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        website_btn.grid(row=0, column=0, padx=10, pady=15)
        
        # Documentation button
        docs_btn = ctk.CTkButton(
            links_frame,
            text="Documentation",
            command=lambda: webbrowser.open("https://docs.dragonvoice.ai"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        docs_btn.grid(row=0, column=1, padx=10, pady=15)
        
        # GitHub button
        github_btn = ctk.CTkButton(
            links_frame,
            text="GitHub Repository",
            command=lambda: webbrowser.open("https://github.com/dragonvoice/dragonvoice"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        github_btn.grid(row=0, column=2, padx=10, pady=15)

    def toggle_theme(self):
        """Toggle between light and dark themes"""
        try:
            # Get current appearance mode
            current_mode = ctk.get_appearance_mode()

            # Toggle mode
            new_mode = "Light" if current_mode == "Dark" else "Dark"
            ctk.set_appearance_mode(new_mode)

            # Update status
            self.update_status(f"Theme changed to {new_mode} mode")

        except Exception as e:
            logging.error(f"Error toggling theme: {str(e)}")
            self.update_status(f"Failed to toggle theme: {str(e)}", "error")

    def start_system_monitoring(self):
        """Start monitoring system resources"""
        try:
            # Initialize status variables if they don't exist
            if not hasattr(self, 'cpu_usage'):
                self.cpu_usage = 0
            if not hasattr(self, 'memory_usage'):
                self.memory_usage = 0
            if not hasattr(self, 'disk_usage'):
                self.disk_usage = 0
            if not hasattr(self, 'voice_status'):
                self.voice_status = "Idle"

            def update_system_info():
                try:
                    # Update CPU usage
                    self.cpu_usage = psutil.cpu_percent(interval=None)

                    # Update memory usage
                    memory = psutil.virtual_memory()
                    self.memory_usage = memory.percent

                    # Update disk usage
                    disk = psutil.disk_usage('/')
                    self.disk_usage = disk.percent

                    # Update status indicators if they exist
                    for i, (value, color) in enumerate([
                        (self.cpu_usage, self.get_resource_color(self.cpu_usage)),
                        (self.memory_usage, self.get_resource_color(self.memory_usage)),
                        (self.disk_usage, self.get_resource_color(self.disk_usage))
                    ]):
                        status_indicator = getattr(self, f'status_indicator_{i}', None)
                        status_value = getattr(self, f'status_value_{i}', None)
                        if status_indicator and status_value:
                            status_indicator.configure(fg_color=color)
                            status_value.configure(
                                text=f"{value:.1f}%",
                                text_color=self.colors["text_bright"]
                            )

                    # Update voice status
                    if hasattr(self, 'recording_active'):
                        voice_status = "Recording" if self.recording_active else "Idle"
                        status_color = self.colors["status_green"] if self.recording_active else self.colors["status_gray"]
                        
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=status_color)
                        if hasattr(self, 'status_value_3'):
                            self.status_value_3.configure(
                                text=voice_status,
                                text_color=self.colors["text_bright"]
                            )

                    # Schedule next update
                    self.app.after(1000, update_system_info)

                except Exception as e:
                    logging.error(f"Error updating system info: {str(e)}")
                    # Try again later
                    self.app.after(5000, update_system_info)

            # Start the update loop
            update_system_info()

        except Exception as e:
            logging.error(f"Error starting system monitoring: {str(e)}")

    def get_resource_color(self, value):
        """Get color based on resource usage percentage"""
        if value < 60:
            return self.colors["status_green"]  # Green for normal
        elif value < 80:
            return self.colors["status_yellow"]  # Yellow for warning
        else:
            return self.colors["status_red"]  # Red for critical

    def filter_chatbot_list(self):
        """Filter the chatbot list based on search text"""
        search_text = self.search_var.get().lower()

        # Clear existing items
        for widget in self.chatbot_list_frame.winfo_children():
            widget.destroy()

        # Add filtered chatbots
        for name, config in self.config.get("chatbots", {}).items():
            if search_text in name.lower():
                self.add_chatbot_list_item(name, config)

    def show_chatbot_settings(self, name, config):
        """Show settings for the selected chatbot"""
        # Update header
        self.selected_chatbot_label.configure(text=f"Settings: {name}")

        # Clear existing settings
        for widget in self.settings_content.winfo_children():
            widget.destroy()

        # Create settings sections
        sections = [
            ("General Settings", self.create_general_settings),
            ("API Configuration", self.create_api_settings),
            ("Model Settings", self.create_model_settings),
            ("Response Settings", self.create_response_settings),
            ("Advanced Options", self.create_advanced_settings)
        ]

        for title, create_func in sections:
            section = create_func(self.settings_content, name, config)
            section.pack(fill="x", padx=10, pady=5)

    def create_general_settings(self, parent, name, config):
        """Create general settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="General Settings",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # Display name
        name_frame = ctk.CTkFrame(frame, fg_color="transparent")
        name_frame.pack(fill="x", padx=15, pady=5)

        name_label = ctk.CTkLabel(
            name_frame,
            text="Display Name:",
            width=120,
            anchor="w"
        )
        name_label.pack(side="left")

        name_entry = ctk.CTkEntry(
            name_frame,
            width=200,
            placeholder_text="Enter display name"
        )
        name_entry.insert(0, name)
        name_entry.pack(side="left", padx=10)

        # Icon selection
        icon_frame = ctk.CTkFrame(frame, fg_color="transparent")
        icon_frame.pack(fill="x", padx=15, pady=5)

        icon_label = ctk.CTkLabel(
            icon_frame,
            text="Icon:",
            width=120,
            anchor="w"
        )
        icon_label.pack(side="left")

        icons = ["ü§ñ", "üß†", "üí°", "üîç", "üí¨", "üåê", "üìö", "‚ö°"]
        icon_var = ctk.StringVar(value=config.get("icon", "ü§ñ"))

        for icon in icons:
            btn = ctk.CTkButton(
                icon_frame,
                text=icon,
                width=40,
                height=40,
                corner_radius=20,
                fg_color=self.colors["bg_medium"] if icon != icon_var.get() else self.colors["accent_primary"],
                hover_color=self.colors["accent_secondary"],
                command=lambda i=icon: [
                    icon_var.set(i),
                    self.update_chatbot_config(
                        name,
                        "icon",
                        i)])
            btn.pack(side="left", padx=2)

        return frame

    def create_api_settings(self, parent, name, config):
        """Create API settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="API Configuration",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # API Key
        key_frame = ctk.CTkFrame(frame, fg_color="transparent")
        key_frame.pack(fill="x", padx=15, pady=5)

        key_label = ctk.CTkLabel(
            key_frame,
            text="API Key:",
            width=120,
            anchor="w"
        )
        key_label.pack(side="left")

        key_entry = ctk.CTkEntry(
            key_frame,
            width=300,
            placeholder_text="Enter API key",
            show="*"
        )
        key_entry.insert(0, config.get("api_key", ""))
        key_entry.pack(side="left", padx=10)

        show_key = ctk.CTkButton(
            key_frame, text="üëÅÔ∏è", width=40, command=lambda: key_entry.configure(
                show="" if key_entry.cget("show") == "*" else "*"))
        show_key.pack(side="left")

        # API Endpoint
        endpoint_frame = ctk.CTkFrame(frame, fg_color="transparent")
        endpoint_frame.pack(fill="x", padx=15, pady=5)

        endpoint_label = ctk.CTkLabel(
            endpoint_frame,
            text="API Endpoint:",
            width=120,
            anchor="w"
        )
        endpoint_label.pack(side="left")

        endpoint_entry = ctk.CTkEntry(
            endpoint_frame,
            width=300,
            placeholder_text="Enter API endpoint"
        )
        endpoint_entry.insert(0, config.get("endpoint", ""))
        endpoint_entry.pack(side="left", padx=10)

        # Test connection button
        test_button = ctk.CTkButton(
            frame,
            text="Test Connection",
            command=lambda: self.test_chatbot_connection(name),
            fg_color=self.colors["accent_secondary"]
        )
        test_button.pack(anchor="e", padx=15, pady=10)

        return frame

    def create_model_settings(self, parent, name, config):
        """Create model settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="Model Settings",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # Model selection
        model_frame = ctk.CTkFrame(frame, fg_color="transparent")
        model_frame.pack(fill="x", padx=15, pady=5)

        model_label = ctk.CTkLabel(
            model_frame,
            text="Model:",
            width=120,
            anchor="w"
        )
        model_label.pack(side="left")

        models = {
            "GPT": ["gpt-4", "gpt-3.5-turbo", "gpt-3.5-turbo-16k"],
            "Claude": ["claude-2", "claude-instant"],
            "Gemini": ["gemini-pro", "gemini-pro-vision"],
            "Custom": ["custom-model"]
        }

        model_type = config.get("type", "GPT")
        model_var = ctk.StringVar(
            value=config.get(
                "model", models[model_type][0]))

        model_combo = ctk.CTkComboBox(
            model_frame,
            width=200,
            values=models[model_type],
            variable=model_var,
            state="readonly"
        )
        model_combo.pack(side="left", padx=10)

        # Temperature
        temp_frame = ctk.CTkFrame(frame, fg_color="transparent")
        temp_frame.pack(fill="x", padx=15, pady=5)

        temp_label = ctk.CTkLabel(
            temp_frame,
            text="Temperature:",
            width=120,
            anchor="w"
        )
        temp_label.pack(side="left")

        temp_var = ctk.DoubleVar(value=config.get("temperature", 0.7))
        temp_slider = ctk.CTkSlider(
            temp_frame,
            from_=0.0,
            to=2.0,
            variable=temp_var,
            width=200
        )
        temp_slider.pack(side="left", padx=10)

        temp_value = ctk.CTkLabel(
            temp_frame,
            textvariable=temp_var,
            width=50
        )
        temp_value.pack(side="left")

        return frame

    def create_response_settings(self, parent, name, config):
        """Create response settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="Response Settings",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # Max tokens
        tokens_frame = ctk.CTkFrame(frame, fg_color="transparent")
        tokens_frame.pack(fill="x", padx=15, pady=5)

        tokens_label = ctk.CTkLabel(
            tokens_frame,
            text="Max Tokens:",
            width=120,
            anchor="w"
        )
        tokens_label.pack(side="left")

        tokens_var = ctk.IntVar(value=config.get("max_tokens", 2000))
        tokens_slider = ctk.CTkSlider(
            tokens_frame,
            from_=100,
            to=4000,
            variable=tokens_var,
            width=200
        )
        tokens_slider.pack(side="left", padx=10)

        tokens_value = ctk.CTkLabel(
            tokens_frame,
            textvariable=tokens_var,
            width=50
        )
        tokens_value.pack(side="left")

        # Response format
        format_frame = ctk.CTkFrame(frame, fg_color="transparent")
        format_frame.pack(fill="x", padx=15, pady=5)

        format_label = ctk.CTkLabel(
            format_frame,
            text="Format:",
            width=120,
            anchor="w"
        )
        format_label.pack(side="left")

        format_var = ctk.StringVar(value=config.get("format", "markdown"))
        formats = ["markdown", "html", "plain"]

        format_combo = ctk.CTkComboBox(
            format_frame,
            width=200,
            values=formats,
            variable=format_var,
            state="readonly"
        )
        format_combo.pack(side="left", padx=10)

        return frame

    def create_advanced_settings(self, parent, name, config):
        """Create advanced settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="Advanced Options",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # System prompt
        prompt_label = ctk.CTkLabel(
            frame,
            text="System Prompt:",
            anchor="w"
        )
        prompt_label.pack(anchor="w", padx=15, pady=(5, 0))

        prompt_text = ctk.CTkTextbox(
            frame,
            height=100,
            wrap="word"
        )
        prompt_text.pack(fill="x", padx=15, pady=5)
        prompt_text.insert("1.0", config.get("system_prompt", ""))

        # Checkboxes
        options_frame = ctk.CTkFrame(frame, fg_color="transparent")
        options_frame.pack(fill="x", padx=15, pady=5)

        stream_var = ctk.BooleanVar(value=config.get("stream", True))
        stream_cb = ctk.CTkCheckBox(
            options_frame,
            text="Stream responses",
            variable=stream_var
        )
        stream_cb.pack(anchor="w")

        history_var = ctk.BooleanVar(value=config.get("keep_history", True))
        history_cb = ctk.CTkCheckBox(
            options_frame,
            text="Keep conversation history",
            variable=history_var
        )
        history_cb.pack(anchor="w", pady=5)

        # Action buttons
        buttons_frame = ctk.CTkFrame(frame, fg_color="transparent")
        buttons_frame.pack(fill="x", padx=15, pady=10)

        save_button = ctk.CTkButton(
            buttons_frame,
            text="Save Changes",
            command=lambda: self.save_chatbot_settings(name),
            fg_color=self.colors["accent_primary"]
        )
        save_button.pack(side="left", padx=5)

        delete_button = ctk.CTkButton(
            buttons_frame,
            text="Delete Chatbot",
            command=lambda: self.delete_chatbot(name),
            fg_color=self.colors["error"]
        )
        delete_button.pack(side="right", padx=5)

        return frame

    def refresh_chatbots(self):
        """Refresh the chatbot cards and status in the dashboard"""
        # Update the chatbot list in the dedicated chatbots tab if it exists
        if hasattr(
                self,
                'chatbot_list_frame') and self.chatbot_list_frame.winfo_exists():
            self.refresh_chatbot_list()

        # Update status
        self.update_status("Chatbots refreshed", "info")

        # Refresh the monitor visualization
        if hasattr(self, 'monitor_canvas'):
            self.refresh_monitor_visualization()

        return True

    def load_config(self) -> dict:
        """Load the configuration from the JSON file"""
        try:
            with open(self.config_path, "r") as f:
                config = json.load(f)
                logging.info("Configuration loaded successfully")
                return config
        except FileNotFoundError:
            logging.error(f"Configuration file not found: {self.config_path}")
            return {}
        except json.JSONDecodeError:
            logging.error(
                f"Invalid JSON in configuration file: {self.config_path}")
            return {}

    def toggle_voice_assistant(self):
        """Toggle the voice assistant on/off"""
        # Check if we're in recording mode
        if hasattr(self, 'recording_active') and self.recording_active:
            # Update button text and color
            if hasattr(self, 'toggle_button'):
                self.toggle_button.configure(
                    text="Start Voice Assistant",
                    fg_color=self.colors["status_green"],  # Green when off
                    hover_color=self._adjust_color_brightness(self.colors["status_green"], 0.8),
                    border_color=self._adjust_color_brightness(self.colors["status_green"], 1.2)
                )

            # Stop recording and transcribe
            if self.stop_manual_recording():
                # Transcribe the recording
                self.transcribe_last_recording()
                # Disable continuous recording
                self.continuous_recording = False

            # Update status indicator
            if hasattr(self, 'status_indicator'):
                self.status_indicator.configure(
                    fg_color=self.colors["status_gray"])
        else:
            # Update button text and color
            if hasattr(self, 'toggle_button'):
                self.toggle_button.configure(
                    text="Stop Voice Assistant",
                    fg_color=self.colors["status_red"],  # Red when on
                    hover_color=self._adjust_color_brightness(self.colors["status_red"], 0.8),
                    border_color=self._adjust_color_brightness(self.colors["status_red"], 1.2)
                )

            # Start recording
            success = self.start_manual_recording()
            if success:
                # Enable continuous recording
                self.continuous_recording = True

                # Update status indicator
                if hasattr(self, 'status_indicator'):
                    self.status_indicator.configure(
                        fg_color=self.colors["status_green"])

                if hasattr(self, 'text_display'):
                    # Update the text display to show that voice assistant is
                    # active
                    self.text_display.configure(state="normal")
                    timestamp = datetime.now().strftime("%H:%M:%S")

                    # Add system message with formatting
                    system_pos = self.text_display.index("end-1c")
                    self.text_display.insert(
                        "end", f"[{timestamp}] Voice Assistant activated. Speak now...\n\n")
                    self.text_display._textbox.tag_add(
                        "system", system_pos, self.text_display.index("end-2c"))

                    self.text_display.see("end")
                    self.text_display.configure(state="disabled")
                    # Update status
                    self.update_status(
                        "Voice Assistant activated. Speak now...",
                        log_level="info")

    def start_manual_recording(self):
        """Start manual recording"""
        if not hasattr(self, 'whisper_recognizer') or self.whisper_recognizer is None:
            self.update_status("Whisper recognizer not initialized", log_level="error")
            return False

        try:
            # Get the selected microphone device if available
            device_id = None
            if hasattr(self, 'mic_device_var') and self.mic_device_var.get() != "Default":
                # Extract device ID from the selection string
                device_str = self.mic_device_var.get()
                if ":" in device_str:
                    device_id = int(device_str.split(":")[0].strip())
            
            # Log the device being used
            logging.info(f"Started recording audio with device_id: {device_id}")
            
            # Start recording with the selected device
            self.whisper_recognizer.start_recording(device=device_id)
            self.recording_active = True

            # Start level meter animation
            self.animate_level_meter()

            # Update UI
            if hasattr(self, 'toggle_button'):
                self.toggle_button.configure(
                    text="Stop Voice Assistant",
                    fg_color=self.colors["status_red"],
                    hover_color=self._adjust_color_brightness(self.colors["status_red"], 0.8),
                    border_color=self._adjust_color_brightness(self.colors["status_red"], 1.2)
                )
                
            # Update record/stop buttons
            if hasattr(self, 'record_button'):
                self.record_button.configure(state="disabled")
                
            if hasattr(self, 'stop_record_button'):
                self.stop_record_button.configure(state="normal")
                
            # Update status
            self.update_status("Voice Assistant activated. Speak now...", log_level="info")
            return True
        except Exception as e:
            self.update_status(f"Failed to start recording: {str(e)}", log_level="error")
            return False

    def stop_manual_recording(self):
        """Stop recording audio manually"""
        if not hasattr(self, 'whisper_recognizer'):
            self.update_status(
                "Whisper recognizer not initialized",
                log_level="error")
            return False

        try:
            # Stop recording
            success = self.whisper_recognizer.stop_recording()
            if success:
                self.update_status("Recording stopped", log_level="info")
                # Update UI to show stopped state
                self.toggle_button.configure(
                    text="Start Voice Assistant",
                    fg_color=self.colors["status_green"],  # Green when off
                    hover_color=self._adjust_color_brightness(self.colors["status_green"], 0.8),
                    border_color=self._adjust_color_brightness(self.colors["status_green"], 1.2)
                )
                
                # Update record/stop buttons
                if hasattr(self, 'record_button'):
                    self.record_button.configure(state="normal")
                    
                if hasattr(self, 'stop_record_button'):
                    self.stop_record_button.configure(state="disabled")
                
                # Enable transcribe button after recording
                if hasattr(self, 'transcribe_button'):
                    self.transcribe_button.configure(state="normal")
                # Stop level meter animation
                self.recording_active = False

                # Update text display to show that voice assistant is stopped
                if hasattr(self, 'text_display'):
                    self.text_display.configure(state="normal")
                    timestamp = datetime.now().strftime("%H:%M:%S")

                    # Add system message with formatting
                    system_pos = self.text_display.index("end-1c")
                    self.text_display.insert(
                        "end", f"[{timestamp}] Voice Assistant stopped.\n\n")
                    self.text_display._textbox.tag_add(
                        "system", system_pos, self.text_display.index("end-2c"))

                    self.text_display.see("end")
                    self.text_display.configure(state="disabled")

                return True
            else:
                self.update_status("No recording to stop", log_level="warning")
                return False
        except Exception as e:
            self.update_status(
                f"Error stopping recording: {str(e)}",
                log_level="error")
            return False

    def transcribe_last_recording(self):
        """Transcribe the last recording"""
        if not hasattr(self, 'whisper_recognizer'):
            self.update_status(
                "Whisper recognizer not initialized",
                log_level="error")
            return None

        try:
            # Save audio to file
            audio_file = self.whisper_recognizer.save_audio_to_file()
            if not audio_file:
                self.update_status(
                    "No audio data to transcribe",
                    log_level="warning")
                return None

            # Transcribe audio
            self.update_status("Transcribing audio...", log_level="info")
            transcript = self.whisper_recognizer.transcribe_audio(
                audio_file,
                language="en",
                response_format="verbose_json"
            )

            if transcript:
                self.update_status(
                    f"Transcription successful: {transcript.text[:50]}...",
                    log_level="info")
                # Add to history
                timestamp = datetime.now().strftime("%H:%M:%S")
                self.add_history_item(transcript.text, timestamp, "Success")

                # Update the text display window with the voice command
                if hasattr(self, 'text_display'):
                    self.text_display.configure(state="normal")
                    # Add timestamp and text with formatting
                    timestamp_pos = self.text_display.index("end-1c")
                    self.text_display.insert("end", f"[{timestamp}] ")
                    self.text_display._textbox.tag_add(
                        "timestamp", timestamp_pos, self.text_display.index("end-1c"))

                    command_pos = self.text_display.index("end-1c")
                    self.text_display.insert("end", f"{transcript.text}\n\n")
                    self.text_display._textbox.tag_add(
                        "command", command_pos, self.text_display.index("end-2c"))

                    # Auto-scroll to the bottom
                    self.text_display.see("end")
                    self.text_display.configure(state="disabled")
                
                # Update the transcription display with the transcribed text
                if hasattr(self, 'transcription_display'):
                    self.transcription_display.configure(state="normal")
                    self.transcription_display.delete(1.0, "end")  # Clear previous content
                    self.transcription_display.insert("end", transcript.text)
                    self.transcription_display.configure(state="disabled")
                    
                    # Enable the Enter button
                    if hasattr(self, 'enter_button'):
                        self.enter_button.configure(state="normal")
                    
                    # Store the current transcription for processing
                    self.current_transcription = transcript.text

                    # Automatically start recording again for continuous voice command recognition
                    # Use a flag to control continuous recording
                    if hasattr(
                            self,
                            'continuous_recording') and self.continuous_recording:
                        self.app.after(1000, self.start_manual_recording)

                # Disable transcribe button after successful transcription
                if hasattr(self, 'transcribe_button'):
                    self.transcribe_button.configure(state="disabled")
                return transcript.text
            else:
                self.update_status("Transcription failed", log_level="error")
                return None

        except Exception as e:
            self.update_status(
                f"Transcription error: {str(e)}",
                log_level="error")
            return None
            
    def process_transcription(self):
        """Process the transcribed text and send it to the selected chatbot"""
        if not hasattr(self, 'current_transcription') or not self.current_transcription:
            self.update_status("No transcription to process", log_level="warning")
            return
            
        try:
            # Get the transcribed text
            transcribed_text = self.current_transcription
            
            # Log the action
            self.update_status(f"Processing transcription: {transcribed_text[:30]}...", log_level="info")
            
            # Here you would implement the logic to send the text to the selected chatbot
            # This could involve simulating keyboard input or using an API
            # For now, we'll just show a success message
            
            # Update status
            self.update_status("Transcription sent to chatbot", log_level="info")
            
            # Add to the text display as a system message
            if hasattr(self, 'text_display'):
                self.text_display.configure(state="normal")
                timestamp = datetime.now().strftime("%H:%M:%S")
                
                # Add system message with formatting
                system_pos = self.text_display.index("end-1c")
                self.text_display.insert(
                    "end", f"[{timestamp}] Sent to chatbot: {transcribed_text[:30]}...\n\n")
                self.text_display._textbox.tag_add(
                    "system", system_pos, self.text_display.index("end-2c"))
                
                self.text_display.see("end")
                self.text_display.configure(state="disabled")
            
            # Clear the transcription display and disable the Enter button
            if hasattr(self, 'transcription_display'):
                self.transcription_display.configure(state="normal")
                self.transcription_display.delete(1.0, "end")
                self.transcription_display.configure(state="disabled")
                
            if hasattr(self, 'enter_button'):
                self.enter_button.configure(state="disabled")
                
            # Clear the current transcription
            self.current_transcription = None
            
        except Exception as e:
            self.update_status(f"Error processing transcription: {str(e)}", log_level="error")

    def animate_level_meter(self):
        """Animate the microphone level meter during recording"""
        if not hasattr(self, 'recording_active') or not self.recording_active:
            # Even when not recording, update with zero level to show the meter
            if hasattr(self, 'synth_bar'):
                self.synth_bar.update(0)
            return

        try:
            # Get the latest audio data if available
            if hasattr(self, 'whisper_recognizer') and self.whisper_recognizer.audio_data:
                latest_chunk = self.whisper_recognizer.audio_data[-1]
                
                # Calculate volume (RMS)
                volume = np.sqrt(np.mean(latest_chunk**2))
                
                # Apply sensitivity/gain from the slider
                if hasattr(self, 'sensitivity_var'):
                    # Apply a logarithmic scaling for more natural sensitivity control
                    sensitivity = self.sensitivity_var.get()
                    volume = volume * (np.exp(sensitivity * 2) - 1)
                
                # Add noise floor threshold to filter out background noise
                noise_floor = 0.01  # Adjust this value based on testing
                if volume < noise_floor:
                    volume = 0
                
                # Scale for visualization (0-100) with more moderate scaling
                volume = min(100, volume * 150)  # Reduced from 300 to 150

                # Update the level meter
                if hasattr(self, 'synth_bar'):
                    self.synth_bar.update(volume)
                
                # Update voice status indicator
                if hasattr(self, 'status_value_3'):
                    if volume > 70:  # High volume
                        self.status_value_3.configure(text="Speaking")
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=self.colors["status_red"])
                    elif volume > 30:  # Medium volume
                        self.status_value_3.configure(text="Active")
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=self.colors["status_yellow"])
                    else:  # Low/no volume
                        self.status_value_3.configure(text="Listening")
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=self.colors["status_green"])
            else:
                # If no audio data, show no activity
                if hasattr(self, 'synth_bar'):
                    self.synth_bar.update(0)
            
            # Continue animation if recording is still active
            if self.recording_active:
                self.app.after(50, self.animate_level_meter)  # Faster updates for smoother animation
                
        except Exception as e:
            logging.error(f"Error in level meter animation: {str(e)}")
            # Try to continue animation despite error
            if hasattr(self, 'recording_active') and self.recording_active:
                self.app.after(100, self.animate_level_meter)

    def refresh_monitor_visualization(self):
        """Update the system monitor visualization"""
        try:
            # Check if monitor_canvas exists
            if not hasattr(self, 'monitor_canvas'):
                logging.warning("monitor_canvas not initialized yet")
                return

            # Clear previous visualization
            self.monitor_canvas.delete("all")

            # Get system metrics
            import psutil
            cpu_percent = psutil.cpu_percent()
            memory_percent = psutil.virtual_memory().percent
            disk_percent = psutil.disk_usage('/').percent

            # Canvas dimensions
            width = self.monitor_canvas.winfo_width()
            height = self.monitor_canvas.winfo_height()

            # Ensure we have valid dimensions
            if width <= 1 or height <= 1:
                # Canvas not properly sized yet, schedule another update
                self.app.after(1000, self.refresh_monitor_visualization)
                return

            # Bar width and spacing
            bar_width = width / 4
            spacing = width / 12

            # Draw CPU bar
            cpu_color = self.get_resource_color(cpu_percent)
            cpu_height = (cpu_percent / 100) * height
            self.monitor_canvas.create_rectangle(
                spacing, height - cpu_height,
                spacing + bar_width, height,
                fill=cpu_color, outline=""
            )
            self.monitor_canvas.create_text(
                spacing + bar_width / 2, height - cpu_height - 15,
                text=f"CPU\n{cpu_percent}%",
                fill=self.colors["text_bright"],
                font=("Helvetica", 10, "bold"),
                justify="center"
            )

            # Draw Memory bar
            mem_color = self.get_resource_color(memory_percent)
            mem_height = (memory_percent / 100) * height
            self.monitor_canvas.create_rectangle(
                spacing * 2 + bar_width, height - mem_height,
                spacing * 2 + bar_width * 2, height,
                fill=mem_color, outline=""
            )
            self.monitor_canvas.create_text(
                spacing * 2 + bar_width * 1.5, height - mem_height - 15,
                text=f"RAM\n{memory_percent}%",
                fill=self.colors["text_bright"],
                font=("Helvetica", 10, "bold"),
                justify="center"
            )

            # Draw Disk bar
            disk_color = self.get_resource_color(disk_percent)
            disk_height = (disk_percent / 100) * height
            self.monitor_canvas.create_rectangle(
                spacing * 3 + bar_width * 2, height - disk_height,
                spacing * 3 + bar_width * 3, height,
                fill=disk_color, outline=""
            )
            self.monitor_canvas.create_text(
                spacing * 3 + bar_width * 2.5, height - disk_height - 15,
                text=f"Disk\n{disk_percent}%",
                fill=self.colors["text_bright"],
                font=("Helvetica", 10, "bold"),
                justify="center"
            )

            # Schedule next update
            self.app.after(2000, self.refresh_monitor_visualization)

        except Exception as e:
            logging.error(f"Error updating monitor visualization: {str(e)}")
            # Try again later
            self.app.after(5000, self.refresh_monitor_visualization)

    def update_status(self, message, log_level="info"):
        """Update the status message in the footer"""
        try:
            # Log the message with appropriate level
            if log_level == "info":
                logging.info(message)
            elif log_level == "warning":
                logging.warning(message)
            elif log_level == "error":
                logging.error(message)

            # Check if status_label exists before updating
            if hasattr(self, 'status_label') and self.status_label is not None:
                self.status_label.configure(text=message)
            else:
                logging.warning(
                    "Status label not initialized yet, can't update status")

        except Exception as e:
            logging.error(f"Error updating status: {str(e)}")
            # Don't raise the exception to avoid crashing the app

    def _adjust_color_brightness(self, hex_color, factor):
        """Adjust the brightness of a hex color by a factor"""
        r, g, b = self.hex_to_rgb(hex_color)
        r = min(255, int(r * factor))
        g = min(255, int(g * factor))
        b = min(255, int(b * factor))
        return f'#{r:02x}{g:02x}{b:02x}'

    def toggle_fullscreen(self):
        """Toggle fullscreen mode for the application window"""
        try:
            # Track fullscreen state
            if not hasattr(self, 'is_fullscreen'):
                self.is_fullscreen = False

            # Toggle state
            self.is_fullscreen = not self.is_fullscreen

            # Apply the change
            self.app.attributes("-fullscreen", self.is_fullscreen)

            # Update status
            status = "Fullscreen mode enabled" if self.is_fullscreen else "Fullscreen mode disabled"
            self.update_status(status)

        except Exception as e:
            logging.error(f"Error toggling fullscreen: {str(e)}")
            self.update_status(
                f"Failed to toggle fullscreen: {str(e)}", "error")

    def create_settings_general_tab(self, parent):
        """Create the general settings tab content"""
        # Main container
        container = ctk.CTkFrame(parent, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)

        # Interface settings section
        interface_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        interface_frame.pack(fill="x", pady=(0, 15))

        # Section title
        interface_title = ctk.CTkLabel(
            interface_frame,
            text="Interface Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        interface_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Language setting
        language_frame = ctk.CTkFrame(interface_frame, fg_color="transparent")
        language_frame.pack(fill="x", padx=15, pady=5)

        language_label = ctk.CTkLabel(
            language_frame,
            text="Interface Language",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        language_label.pack(side="left")

        self.language_var = ctk.StringVar(value="English")
        language_dropdown = ctk.CTkOptionMenu(
            language_frame,
            values=[
                "English",
                "Spanish",
                "French",
                "German",
                "Chinese",
                "Japanese"],
            variable=self.language_var,
            width=200)
        language_dropdown.pack(side="left", padx=10)

        # Startup settings section
        startup_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        startup_frame.pack(fill="x", pady=(0, 15))

        # Section title
        startup_title = ctk.CTkLabel(
            startup_frame,
            text="Startup Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        startup_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Auto-start setting
        autostart_frame = ctk.CTkFrame(startup_frame, fg_color="transparent")
        autostart_frame.pack(fill="x", padx=15, pady=5)

        autostart_label = ctk.CTkLabel(
            autostart_frame,
            text="Start with Windows",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        autostart_label.pack(side="left")

        self.autostart_var = ctk.BooleanVar(value=False)
        autostart_switch = ctk.CTkSwitch(
            autostart_frame,
            text="",
            variable=self.autostart_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        autostart_switch.pack(side="left", padx=10)

        # Start minimized setting
        minimized_frame = ctk.CTkFrame(startup_frame, fg_color="transparent")
        minimized_frame.pack(fill="x", padx=15, pady=5)

        minimized_label = ctk.CTkLabel(
            minimized_frame,
            text="Start Minimized",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        minimized_label.pack(side="left")

        self.minimized_var = ctk.BooleanVar(value=False)
        minimized_switch = ctk.CTkSwitch(
            minimized_frame,
            text="",
            variable=self.minimized_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        minimized_switch.pack(side="left", padx=10)

        # Auto-activate voice assistant
        autoactivate_frame = ctk.CTkFrame(
            startup_frame, fg_color="transparent")
        autoactivate_frame.pack(fill="x", padx=15, pady=5)

        autoactivate_label = ctk.CTkLabel(
            autoactivate_frame,
            text="Auto-activate Voice Assistant",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        autoactivate_label.pack(side="left")

        self.autoactivate_var = ctk.BooleanVar(value=False)
        autoactivate_switch = ctk.CTkSwitch(
            autoactivate_frame,
            text="",
            variable=self.autoactivate_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        autoactivate_switch.pack(side="left", padx=10)

        return container

    def create_settings_appearance_tab(self, parent):
        """Create the appearance settings tab content"""
        # Main container
        container = ctk.CTkFrame(parent, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)

        # Theme settings section
        theme_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        theme_frame.pack(fill="x", pady=(0, 15))

        # Section title
        theme_title = ctk.CTkLabel(
            theme_frame,
            text="Theme Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        theme_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Theme selection
        theme_selection_frame = ctk.CTkFrame(
            theme_frame, fg_color="transparent")
        theme_selection_frame.pack(fill="x", padx=15, pady=5)

        theme_label = ctk.CTkLabel(
            theme_selection_frame,
            text="Color Theme",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        theme_label.pack(side="left")

        self.theme_var = ctk.StringVar(value="medical")
        theme_dropdown = ctk.CTkOptionMenu(
            theme_selection_frame,
            values=["medical", "midnight", "cyberpunk"],
            variable=self.theme_var,
            width=200,
            command=self.apply_theme
        )
        theme_dropdown.pack(side="left", padx=10)

        # Appearance mode
        appearance_frame = ctk.CTkFrame(theme_frame, fg_color="transparent")
        appearance_frame.pack(fill="x", padx=15, pady=5)

        appearance_label = ctk.CTkLabel(
            appearance_frame,
            text="Appearance Mode",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        appearance_label.pack(side="left")

        self.appearance_var = ctk.StringVar(value="Dark")
        appearance_dropdown = ctk.CTkOptionMenu(
            appearance_frame,
            values=["Dark", "Light", "System"],
            variable=self.appearance_var,
            width=200,
            command=lambda value: ctk.set_appearance_mode(value)
        )
        appearance_dropdown.pack(side="left", padx=10)

        # Font settings section
        font_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        font_frame.pack(fill="x", pady=(0, 15))

        # Section title
        font_title = ctk.CTkLabel(
            font_frame,
            text="Font Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        font_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Font size
        font_size_frame = ctk.CTkFrame(font_frame, fg_color="transparent")
        font_size_frame.pack(fill="x", padx=15, pady=5)

        font_size_label = ctk.CTkLabel(
            font_size_frame,
            text="Font Size",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        font_size_label.pack(side="left")

        self.font_size_var = ctk.IntVar(value=12)
        font_size_slider = ctk.CTkSlider(
            font_size_frame,
            from_=8,
            to=16,
            number_of_steps=8,
            variable=self.font_size_var,
            width=200
        )
        font_size_slider.pack(side="left", padx=10)

        font_size_value = ctk.CTkLabel(
            font_size_frame,
            textvariable=self.font_size_var,
            width=30
        )
        font_size_value.pack(side="left", padx=5)

        # Preview section
        preview_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        preview_frame.pack(fill="x", pady=(0, 15))

        # Section title
        preview_title = ctk.CTkLabel(
            preview_frame,
            text="Theme Preview",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        preview_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Preview content
        preview_content = ctk.CTkFrame(
            preview_frame,
            fg_color=self.colors["bg_medium"],
            corner_radius=5,
            height=100
        )
        preview_content.pack(fill="x", padx=15, pady=(0, 15))
        preview_content.pack_propagate(False)

        preview_label = ctk.CTkLabel(
            preview_content,
            text="Sample Text",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"]
        )
        preview_label.pack(anchor="center", pady=10)

        preview_button = ctk.CTkButton(
            preview_content,
            text="Sample Button",
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            width=150
        )
        preview_button.pack(anchor="center")

        return container

    def create_settings_voice_tab(self, parent):
        """Create the voice settings tab content"""
        # Main container with gradient background
        container = ctk.CTkFrame(parent, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)

        # Microphone settings section
        mic_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        mic_frame.pack(fill="x", pady=(0, 15))

        # Section title
        mic_title = ctk.CTkLabel(
            mic_frame,
            text="Microphone Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        mic_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Microphone selection
        mic_selection_frame = ctk.CTkFrame(mic_frame, fg_color="transparent")
        mic_selection_frame.pack(fill="x", padx=15, pady=5)

        mic_label = ctk.CTkLabel(
            mic_selection_frame,
            text="Input Device",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        mic_label.pack(side="left")

        # Create a frame for the dropdown and refresh button
        mic_dropdown_frame = ctk.CTkFrame(
            mic_selection_frame, fg_color="transparent")
        mic_dropdown_frame.pack(side="left", fill="x", expand=True)

        # Microphone dropdown
        self.mic_var = ctk.StringVar(value="Default Microphone")
        self.mic_dropdown = ctk.CTkOptionMenu(
            mic_dropdown_frame,
            values=["Default Microphone"],
            variable=self.mic_var,
            width=200
        )
        self.mic_dropdown.pack(side="left", padx=(0, 10))

        # Refresh button
        refresh_button = ctk.CTkButton(
            mic_dropdown_frame,
            text="Refresh",
            command=self.refresh_mic_list,
            fg_color=self.colors["bg_medium"],
            hover_color=self.colors["bg_light"],
            width=80
        )
        refresh_button.pack(side="left")

        # Microphone level visualization
        level_frame = ctk.CTkFrame(mic_frame, fg_color="transparent")
        level_frame.pack(fill="x", padx=15, pady=5)

        level_label = ctk.CTkLabel(
            level_frame,
            text="Input Level",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        level_label.pack(side="left")

        # Level meter canvas
        self.level_canvas = ctk.CTkCanvas(
            level_frame,
            height=24,
            width=200,
            bg=self.colors["bg_dark"],
            highlightthickness=0
        )
        self.level_canvas.pack(side="left", padx=10)

        # Test microphone button
        test_button = ctk.CTkButton(
            level_frame,
            text="Test",
            command=self.test_microphone,
            fg_color=self.colors["accent_secondary"],
            hover_color=self.colors["accent_primary"],
            width=80
        )
        test_button.pack(side="left")

        # Advanced microphone settings
        advanced_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        advanced_frame.pack(fill="x", pady=(0, 15))

        # Section title
        advanced_title = ctk.CTkLabel(
            advanced_frame,
            text="Advanced Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        advanced_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Input gain
        gain_frame = ctk.CTkFrame(advanced_frame, fg_color="transparent")
        gain_frame.pack(fill="x", padx=15, pady=5)

        gain_label = ctk.CTkLabel(
            gain_frame,
            text="Input Gain",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        gain_label.pack(side="left")

        self.gain_var = ctk.DoubleVar(value=1.0)
        gain_slider = ctk.CTkSlider(
            gain_frame,
            from_=0.1,
            to=2.0,
            variable=self.gain_var,
            width=200
        )
        gain_slider.pack(side="left", padx=10)

        gain_value = ctk.CTkLabel(
            gain_frame,
            text=f"{self.gain_var.get():.1f}",
            width=30
        )
        gain_value.pack(side="left", padx=5)

        # Noise threshold
        threshold_frame = ctk.CTkFrame(advanced_frame, fg_color="transparent")
        threshold_frame.pack(fill="x", padx=15, pady=5)

        threshold_label = ctk.CTkLabel(
            threshold_frame,
            text="Noise Threshold",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        threshold_label.pack(side="left")

        self.threshold_var = ctk.DoubleVar(value=0.2)
        threshold_slider = ctk.CTkSlider(
            threshold_frame,
            from_=0.0,
            to=0.5,
            variable=self.threshold_var,
            width=200
        )
        threshold_slider.pack(side="left", padx=10)

        threshold_value = ctk.CTkLabel(
            threshold_frame,
            text=f"{self.threshold_var.get():.2f}",
            width=30
        )
        threshold_value.pack(side="left", padx=5)

        # Echo cancellation
        echo_frame = ctk.CTkFrame(advanced_frame, fg_color="transparent")
        echo_frame.pack(fill="x", padx=15, pady=5)

        echo_label = ctk.CTkLabel(
            echo_frame,
            text="Echo Cancellation",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        echo_label.pack(side="left")

        self.echo_var = ctk.BooleanVar(value=True)
        echo_switch = ctk.CTkSwitch(
            echo_frame,
            text="",
            variable=self.echo_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        echo_switch.pack(side="left", padx=10)

        # Noise reduction
        noise_frame = ctk.CTkFrame(advanced_frame, fg_color="transparent")
        noise_frame.pack(fill="x", padx=15, pady=5)

        noise_label = ctk.CTkLabel(
            noise_frame,
            text="Noise Reduction",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        noise_label.pack(side="left")

        self.noise_var = ctk.BooleanVar(value=True)
        noise_switch = ctk.CTkSwitch(
            noise_frame,
            text="",
            variable=self.noise_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        noise_switch.pack(side="left", padx=10)

        # Initialize microphone list
        self.refresh_mic_list()

        return container

    def refresh_mic_list(self):
        """Refresh the list of available microphones."""
        try:
            devices = sd.query_devices()
            input_devices = []

            # Add a default option
            input_devices.append("Default Microphone")

            # Add all input devices with their IDs for easier identification
            for i, device in enumerate(devices):
                if device['max_input_channels'] > 0:
                    input_devices.append(f"{device['name']} (ID: {i})")

            # Update dropdown
            self.mic_dropdown.configure(values=input_devices)

            # Set default selection
            if input_devices:
                self.mic_var.set(input_devices[0])

            # Update status
            self.update_status(f"Found {len(input_devices)-1} input devices")

        except Exception as e:
            logging.error(f"Error refreshing microphone list: {str(e)}")
            self.update_status("Failed to refresh microphone list", "error")
            # Ensure at least the default option is available
            self.mic_dropdown.configure(values=["Default Microphone"])
            self.mic_var.set("Default Microphone")

    def test_microphone(self):
        """Test the selected microphone by recording and playing back audio."""
        try:
            device_str = self.mic_var.get()
            device_id = None

            # Extract device ID if it's not the default microphone
            if device_str != "Default Microphone":
                try:
                    device_id = int(device_str.split("ID: ")[1].strip(")"))
                    logging.info(f"Testing microphone with ID: {device_id}")
                except Exception as e:
                    logging.error(f"Error parsing device ID: {str(e)}")
                    device_id = None
                    logging.info("Using default microphone instead")

            # Create a modern dialog to show recording status
            dialog = ctk.CTkToplevel(self.app)
            dialog.title("Microphone Test")
            dialog.geometry("400x300")
            dialog.resizable(False, False)
            dialog.transient(self.app)
            dialog.grab_set()

            # Set dialog theme
            dialog.configure(fg_color=self.colors["bg_medium"])

            # Center the dialog
            dialog.update_idletasks()
            width = dialog.winfo_width()
            height = dialog.winfo_height()
            x = (dialog.winfo_screenwidth() // 2) - (width // 2)
            y = (dialog.winfo_screenheight() // 2) - (height // 2)
            dialog.geometry(f"{width}x{height}+{x}+{y}")

            # Title with icon
            title_frame = ctk.CTkFrame(dialog, fg_color="transparent")
            title_frame.pack(fill="x", padx=20, pady=(20, 10))

            title_label = ctk.CTkLabel(
                title_frame,
                text="Microphone Test",
                font=ctk.CTkFont(size=20, weight="bold"),
                text_color=self.colors["text_bright"]
            )
            title_label.pack(side="left")

            # Status label with modern styling
            status_frame = ctk.CTkFrame(
                dialog, fg_color=self.colors["bg_light"], corner_radius=10)
            status_frame.pack(fill="x", padx=20, pady=10)

            status_label = ctk.CTkLabel(
                status_frame,
                text="Initializing microphone test...",
                font=ctk.CTkFont(size=14),
                text_color=self.colors["text_bright"],
                wraplength=350
            )
            status_label.pack(pady=15, padx=15)

            # Progress bar with custom styling
            progress_frame = ctk.CTkFrame(dialog, fg_color="transparent")
            progress_frame.pack(fill="x", padx=20, pady=5)

            progress_label = ctk.CTkLabel(
                progress_frame,
                text="Progress:",
                font=ctk.CTkFont(size=12),
                text_color=self.colors["text_normal"]
            )
            progress_label.pack(anchor="w")

            progress = ctk.CTkProgressBar(
                progress_frame,
                width=360,
                height=15,
                corner_radius=5,
                fg_color=self.colors["bg_dark"],
                progress_color=self.colors["accent_primary"]
            )
            progress.pack(pady=5)
            progress.set(0)

            # Level meter with improved visualization
            level_frame = ctk.CTkFrame(dialog, fg_color="transparent")
            level_frame.pack(fill="x", padx=20, pady=5)

            level_label = ctk.CTkLabel(
                level_frame,
                text="Audio Level:",
                font=ctk.CTkFont(size=12),
                text_color=self.colors["text_normal"]
            )
            level_label.pack(anchor="w")

            meter_bg = ctk.CTkFrame(
                level_frame,
                fg_color=self.colors["bg_dark"],
                height=30,
                width=360,
                corner_radius=5
            )
            meter_bg.pack(pady=5)

            level_indicator = ctk.CTkFrame(
                meter_bg,
                fg_color=self.colors["accent_primary"],
                height=30,
                width=1,
                corner_radius=5
            )
            level_indicator.place(x=0, y=0)

            level_text = ctk.CTkLabel(
                meter_bg,
                text="0%",
                font=ctk.CTkFont(size=12, weight="bold"),
                text_color=self.colors["text_bright"]
            )
            level_text.place(relx=0.5, rely=0.5, anchor="center")

            # Button frame
            button_frame = ctk.CTkFrame(dialog, fg_color="transparent")
            button_frame.pack(fill="x", padx=20, pady=(15, 20))

            # Cancel button
            cancel_button = ctk.CTkButton(
                button_frame,
                text="Cancel",
                command=dialog.destroy,
                fg_color=self.colors["bg_light"],
                hover_color=self.colors["bg_medium"],
                text_color=self.colors["text_normal"],
                width=100
            )
            cancel_button.pack(side="left", padx=(0, 10))

            # Close button (initially disabled)
            close_button = ctk.CTkButton(
                button_frame,
                text="Close",
                command=dialog.destroy,
                state="disabled",
                fg_color=self.colors["accent_primary"],
                hover_color=self.colors["accent_secondary"],
                width=100
            )
            close_button.pack(side="right")

            # Get device info
            try:
                device_info = sd.query_devices(device_id)
                samplerate = int(device_info['default_samplerate'])

                # Show device info in status
                status_label.configure(
                    text=f"Testing: {device_info['name']}\nPlease speak now to test your microphone.")
            except Exception as e:
                status_label.configure(
                    text=f"Error: {str(e)}\nCould not initialize the selected microphone.")
                close_button.configure(state="normal")
                return

            # Duration of recording
            duration = 5  # seconds

            # Function to update progress
            def update_progress(current, total):
                progress.set(current / total)
                progress_label.configure(
                    text=f"Progress: {int(current/total*100)}%")
                dialog.update()

            # Function to update level indicator
            def update_level(volume):
                # Scale volume (0-1) to width
                width = min(360, int(volume * 360))
                level_indicator.configure(width=width)

                # Update color based on level
                if volume < 0.3:
                    level_indicator.configure(
                        fg_color=self.colors["status_green"])
                elif volume < 0.7:
                    level_indicator.configure(
                        fg_color=self.colors["status_yellow"])
                else:
                    level_indicator.configure(
                        fg_color=self.colors["status_red"])

                # Update text
                level_text.configure(text=f"{int(volume * 100)}%")
                dialog.update()

            # Function to record audio
            def record_audio():
                status_label.configure(
                    text=f"Recording from: {device_info['name']}\nPlease speak now...")

                # Create array to store audio data
                audio_data = []

                # Start time
                start_time = time.time()

                # Callback function for audio stream
                def audio_callback(indata, frames, time_info, status):
                    if status:
                        logging.warning(f"Audio status: {status}")

                    # Copy audio data
                    audio_data.append(indata.copy())

                    # Calculate volume level (RMS)
                    volume = np.sqrt(np.mean(indata**2))

                    # Apply gain if available
                    if hasattr(self, 'gain_var'):
                        volume *= self.gain_var.get()

                    # Update level indicator
                    dialog.after(0, lambda: update_level(min(1.0, volume * 2)))

                    # Update progress
                    elapsed = time.time() - start_time
                    if elapsed < duration:
                        dialog.after(
                            0, lambda: update_progress(
                                elapsed, duration))

                # Start audio stream
                try:
                    with sd.InputStream(
                        device=device_id,
                        channels=1,
                        callback=audio_callback,
                        samplerate=samplerate,
                        blocksize=int(samplerate * 0.1)  # 100ms blocks
                    ):
                        # Wait for duration
                        sd.sleep(int(duration * 1000))
                except Exception as e:
                    error_msg = f"Error recording: {str(e)}"
                    logging.error(error_msg)
                    status_label.configure(text=error_msg)
                    close_button.configure(state="normal")
                    return None

                # Combine all audio chunks
                if audio_data:
                    return np.concatenate(audio_data)
                return None

            # Function to play audio
            def play_audio(audio_data):
                status_label.configure(text="Playing back recording...")
                progress.set(0)

                try:
                    # Start time
                    start_time = time.time()

                    # Play audio
                    sd.play(audio_data, samplerate)

                    # Update progress during playback
                    def update_playback_progress():
                        elapsed = time.time() - start_time
                        if elapsed < duration and not dialog.winfo_exists():
                            return

                        if elapsed < duration:
                            update_progress(elapsed, duration)
                            dialog.after(100, update_playback_progress)
                        else:
                            progress.set(1.0)
                            progress_label.configure(text="Progress: 100%")

                    # Start progress updates
                    update_playback_progress()

                    # Wait for playback to complete
                    sd.wait()

                    # Test completed
                    status_label.configure(
                        text="Test completed successfully!\n\nYour microphone is working properly.")
                    close_button.configure(state="normal")

                except Exception as e:
                    error_msg = f"Error playing back: {str(e)}"
                    logging.error(error_msg)
                    status_label.configure(text=error_msg)
                    close_button.configure(state="normal")

            # Run the recording in a separate thread
            def run_test():
                try:
                    # Record audio
                    audio_data = record_audio()

                    if audio_data is not None and len(audio_data) > 0:
                        # Play it back
                        play_audio(audio_data)
                    else:
                        status_label.configure(
                            text="No audio recorded or error occurred.\n\nPlease check if your microphone is properly connected and not muted.")
                        close_button.configure(state="normal")
                except Exception as e:
                    error_msg = f"Test failed: {str(e)}"
                    logging.error(error_msg)
                    status_label.configure(text=error_msg)
                    close_button.configure(state="normal")

            # Start the test in a separate thread
            threading.Thread(target=run_test, daemon=True).start()

        except Exception as e:
            error_msg = f"Failed to test microphone: {str(e)}"
            logging.error(error_msg)
            messagebox.showerror("Error", error_msg)
            self.update_status(f"Microphone test failed: {str(e)}", "error")

    def create_settings_chatbots_tab(self, parent):
        """Create the chatbots settings tab content"""
        # Main container
        container = ctk.CTkFrame(parent, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)

        # Title and add button row
        title_frame = ctk.CTkFrame(container, fg_color="transparent")
        title_frame.pack(fill="x", pady=(0, 15))

        # Title
        title_label = ctk.CTkLabel(
            title_frame,
            text="Manage Chatbots",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title_label.pack(side="left")

        # Add chatbot button
        add_button = ctk.CTkButton(
            title_frame,
            text="Add New Chatbot",
            command=self.show_add_chatbot_dialog,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            width=150
        )
        add_button.pack(side="right")

        return container

    def start_manual_recording(self):
        """Start manual recording"""
        if not hasattr(
                self,
                'whisper_recognizer') or self.whisper_recognizer is None:
            self.update_status(
                "Whisper recognizer not initialized",
                log_level="error")
            return False

        try:
            # Start recording
            self.whisper_recognizer.start_recording()
            self.recording_active = True

            # Start level meter animation
            self.animate_level_meter()

            # Update UI
            if hasattr(self, 'toggle_button'):
                self.toggle_button.configure(
                    text="Stop Voice Assistant",
                    fg_color=self.colors["status_red"],
                    hover_color=self._adjust_color_brightness(self.colors["status_red"], 0.8),
                    border_color=self._adjust_color_brightness(self.colors["status_red"], 1.2)
                )
                
            # Update record/stop buttons
            if hasattr(self, 'record_button'):
                self.record_button.configure(state="disabled")
                
            if hasattr(self, 'stop_record_button'):
                self.stop_record_button.configure(state="normal")
                
            # Update status
            self.update_status("Voice Assistant activated. Speak now...", log_level="info")
            return True
        except Exception as e:
            self.update_status(
                f"Failed to start recording: {str(e)}",
                log_level="error")
            return False

    def stop_manual_recording(self):
        """Stop recording audio manually"""
        if not hasattr(self, 'whisper_recognizer'):
            self.update_status(
                "Whisper recognizer not initialized",
                log_level="error")
            return False

        try:
            # Stop recording
            success = self.whisper_recognizer.stop_recording()
            if success:
                self.update_status("Recording stopped", log_level="info")
                # Update UI to show stopped state
                self.toggle_button.configure(
                    text="Start Voice Assistant",
                    fg_color=self.colors["status_green"],  # Green when off
                    hover_color=self._adjust_color_brightness(self.colors["status_green"], 0.8),
                    border_color=self._adjust_color_brightness(self.colors["status_green"], 1.2)
                )
                
                # Update record/stop buttons
                if hasattr(self, 'record_button'):
                    self.record_button.configure(state="normal")
                    
                if hasattr(self, 'stop_record_button'):
                    self.stop_record_button.configure(state="disabled")
                
                # Enable transcribe button after recording
                if hasattr(self, 'transcribe_button'):
                    self.transcribe_button.configure(state="normal")
                # Stop level meter animation
                self.recording_active = False

                # Update text display to show that voice assistant is stopped
                if hasattr(self, 'text_display'):
                    self.text_display.configure(state="normal")
                    timestamp = datetime.now().strftime("%H:%M:%S")

                    # Add system message with formatting
                    system_pos = self.text_display.index("end-1c")
                    self.text_display.insert(
                        "end", f"[{timestamp}] Voice Assistant stopped.\n\n")
                    self.text_display._textbox.tag_add(
                        "system", system_pos, self.text_display.index("end-2c"))

                    self.text_display.see("end")
                    self.text_display.configure(state="disabled")

                return True
            else:
                self.update_status("No recording to stop", log_level="warning")
                return False
        except Exception as e:
            self.update_status(
                f"Error stopping recording: {str(e)}",
                log_level="error")
            return False

    def transcribe_last_recording(self):
        """Transcribe the last recording"""
        if not hasattr(self, 'whisper_recognizer'):
            self.update_status(
                "Whisper recognizer not initialized",
                log_level="error")
            return None

        try:
            # Save audio to file
            audio_file = self.whisper_recognizer.save_audio_to_file()
            if not audio_file:
                self.update_status(
                    "No audio data to transcribe",
                    log_level="warning")
                return None

            # Transcribe audio
            self.update_status("Transcribing audio...", log_level="info")
            transcript = self.whisper_recognizer.transcribe_audio(
                audio_file,
                language="en",
                response_format="verbose_json"
            )

            if transcript:
                self.update_status(
                    f"Transcription successful: {transcript.text[:50]}...",
                    log_level="info")
                # Add to history
                timestamp = datetime.now().strftime("%H:%M:%S")
                self.add_history_item(transcript.text, timestamp, "Success")

                # Update the text display window with the voice command
                if hasattr(self, 'text_display'):
                    self.text_display.configure(state="normal")
                    # Add timestamp and text with formatting
                    timestamp_pos = self.text_display.index("end-1c")
                    self.text_display.insert("end", f"[{timestamp}] ")
                    self.text_display._textbox.tag_add(
                        "timestamp", timestamp_pos, self.text_display.index("end-1c"))

                    command_pos = self.text_display.index("end-1c")
                    self.text_display.insert("end", f"{transcript.text}\n\n")
                    self.text_display._textbox.tag_add(
                        "command", command_pos, self.text_display.index("end-2c"))

                    # Auto-scroll to the bottom
                    self.text_display.see("end")
                    self.text_display.configure(state="disabled")
                
                # Update the transcription display with the transcribed text
                if hasattr(self, 'transcription_display'):
                    self.transcription_display.configure(state="normal")
                    self.transcription_display.delete(1.0, "end")  # Clear previous content
                    self.transcription_display.insert("end", transcript.text)
                    self.transcription_display.configure(state="disabled")
                    
                    # Enable the Enter button
                    if hasattr(self, 'enter_button'):
                        self.enter_button.configure(state="normal")
                    
                    # Store the current transcription for processing
                    self.current_transcription = transcript.text

                    # Automatically start recording again for continuous voice command recognition
                    # Use a flag to control continuous recording
                    if hasattr(
                            self,
                            'continuous_recording') and self.continuous_recording:
                        self.app.after(1000, self.start_manual_recording)

                # Disable transcribe button after successful transcription
                if hasattr(self, 'transcribe_button'):
                    self.transcribe_button.configure(state="disabled")
                return transcript.text
            else:
                self.update_status("Transcription failed", log_level="error")
                return None

        except Exception as e:
            self.update_status(
                f"Transcription error: {str(e)}",
                log_level="error")
            return None
            
    def process_transcription(self):
        """Process the transcribed text and send it to the selected chatbot"""
        if not hasattr(self, 'current_transcription') or not self.current_transcription:
            self.update_status("No transcription to process", log_level="warning")
            return
            
        try:
            # Get the transcribed text
            transcribed_text = self.current_transcription
            
            # Log the action
            self.update_status(f"Processing transcription: {transcribed_text[:30]}...", log_level="info")
            
            # Here you would implement the logic to send the text to the selected chatbot
            # This could involve simulating keyboard input or using an API
            # For now, we'll just show a success message
            
            # Update status
            self.update_status("Transcription sent to chatbot", log_level="info")
            
            # Add to the text display as a system message
            if hasattr(self, 'text_display'):
                self.text_display.configure(state="normal")
                timestamp = datetime.now().strftime("%H:%M:%S")
                
                # Add system message with formatting
                system_pos = self.text_display.index("end-1c")
                self.text_display.insert(
                    "end", f"[{timestamp}] Sent to chatbot: {transcribed_text[:30]}...\n\n")
                self.text_display._textbox.tag_add(
                    "system", system_pos, self.text_display.index("end-2c"))
                
                self.text_display.see("end")
                self.text_display.configure(state="disabled")
            
            # Clear the transcription display and disable the Enter button
            if hasattr(self, 'transcription_display'):
                self.transcription_display.configure(state="normal")
                self.transcription_display.delete(1.0, "end")
                self.transcription_display.configure(state="disabled")
                
            if hasattr(self, 'enter_button'):
                self.enter_button.configure(state="disabled")
                
            # Clear the current transcription
            self.current_transcription = None
            
        except Exception as e:
            self.update_status(f"Error processing transcription: {str(e)}", log_level="error")

    def animate_level_meter(self):
        """Animate the microphone level meter during recording"""
        if not hasattr(self, 'recording_active') or not self.recording_active:
            # Even when not recording, update with zero level to show the meter
            if hasattr(self, 'synth_bar'):
                self.synth_bar.update(0)
            return

        try:
            # Get the latest audio data if available
            if hasattr(self, 'whisper_recognizer') and self.whisper_recognizer.audio_data:
                latest_chunk = self.whisper_recognizer.audio_data[-1]
                
                # Calculate volume (RMS)
                volume = np.sqrt(np.mean(latest_chunk**2))
                
                # Apply sensitivity/gain from the slider
                if hasattr(self, 'sensitivity_var'):
                    # Apply a logarithmic scaling for more natural sensitivity control
                    sensitivity = self.sensitivity_var.get()
                    volume = volume * (np.exp(sensitivity * 2) - 1)
                
                # Add noise floor threshold to filter out background noise
                noise_floor = 0.01  # Adjust this value based on testing
                if volume < noise_floor:
                    volume = 0
                
                # Scale for visualization (0-100) with more moderate scaling
                volume = min(100, volume * 150)  # Reduced from 300 to 150

                # Update the level meter
                if hasattr(self, 'synth_bar'):
                    self.synth_bar.update(volume)
                
                # Update voice status indicator
                if hasattr(self, 'status_value_3'):
                    if volume > 70:  # High volume
                        self.status_value_3.configure(text="Speaking")
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=self.colors["status_red"])
                    elif volume > 30:  # Medium volume
                        self.status_value_3.configure(text="Active")
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=self.colors["status_yellow"])
                    else:  # Low/no volume
                        self.status_value_3.configure(text="Listening")
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=self.colors["status_green"])
            else:
                # If no audio data, show no activity
                if hasattr(self, 'synth_bar'):
                    self.synth_bar.update(0)
            
            # Continue animation if recording is still active
            if self.recording_active:
                self.app.after(50, self.animate_level_meter)  # Faster updates for smoother animation
                
        except Exception as e:
            logging.error(f"Error in level meter animation: {str(e)}")
            # Try to continue animation despite error
            if hasattr(self, 'recording_active') and self.recording_active:
                self.app.after(100, self.animate_level_meter)

    def refresh_monitor_visualization(self):
        """Update the system monitor visualization"""
        try:
            # Check if monitor_canvas exists
            if not hasattr(self, 'monitor_canvas'):
                logging.warning("monitor_canvas not initialized yet")
                return

            # Clear previous visualization
            self.monitor_canvas.delete("all")

            # Get system metrics
            import psutil
            cpu_percent = psutil.cpu_percent()
            memory_percent = psutil.virtual_memory().percent
            disk_percent = psutil.disk_usage('/').percent

            # Canvas dimensions
            width = self.monitor_canvas.winfo_width()
            height = self.monitor_canvas.winfo_height()

            # Ensure we have valid dimensions
            if width <= 1 or height <= 1:
                # Canvas not properly sized yet, schedule another update
                self.app.after(1000, self.refresh_monitor_visualization)
                return

            # Bar width and spacing
            bar_width = width / 4
            spacing = width / 12

            # Draw CPU bar
            cpu_color = self.get_resource_color(cpu_percent)
            cpu_height = (cpu_percent / 100) * height
            self.monitor_canvas.create_rectangle(
                spacing, height - cpu_height,
                spacing + bar_width, height,
                fill=cpu_color, outline=""
            )
            self.monitor_canvas.create_text(
                spacing + bar_width / 2, height - cpu_height - 15,
                text=f"CPU\n{cpu_percent}%",
                fill=self.colors["text_bright"],
                font=("Helvetica", 10, "bold"),
                justify="center"
            )

            # Draw Memory bar
            mem_color = self.get_resource_color(memory_percent)
            mem_height = (memory_percent / 100) * height
            self.monitor_canvas.create_rectangle(
                spacing * 2 + bar_width, height - mem_height,
                spacing * 2 + bar_width * 2, height,
                fill=mem_color, outline=""
            )
            self.monitor_canvas.create_text(
                spacing * 2 + bar_width * 1.5, height - mem_height - 15,
                text=f"RAM\n{memory_percent}%",
                fill=self.colors["text_bright"],
                font=("Helvetica", 10, "bold"),
                justify="center"
            )

            # Draw Disk bar
            disk_color = self.get_resource_color(disk_percent)
            disk_height = (disk_percent / 100) * height
            self.monitor_canvas.create_rectangle(
                spacing * 3 + bar_width * 2, height - disk_height,
                spacing * 3 + bar_width * 3, height,
                fill=disk_color, outline=""
            )
            self.monitor_canvas.create_text(
                spacing * 3 + bar_width * 2.5, height - disk_height - 15,
                text=f"Disk\n{disk_percent}%",
                fill=self.colors["text_bright"],
                font=("Helvetica", 10, "bold"),
                justify="center"
            )

            # Schedule next update
            self.app.after(2000, self.refresh_monitor_visualization)

        except Exception as e:
            logging.error(f"Error updating monitor visualization: {str(e)}")
            # Try again later
            self.app.after(5000, self.refresh_monitor_visualization)

    def _update_level_meter(self, volume):
        """Update the level meter with the current volume"""
        if hasattr(self, 'level_meter'):
            # Scale volume to meter width
            meter_width = int((volume / 100) * self.level_meter_width)
            # Update meter fill
            self.level_meter.configure(width=meter_width)
            
            # Update color based on volume level
            if volume > 80:  # High volume
                self.level_meter.configure(fg_color=self.colors["status_red"])
            elif volume > 40:  # Medium volume
                self.level_meter.configure(fg_color=self.colors["status_yellow"])
            else:  # Low volume
                self.level_meter.configure(fg_color=self.colors["status_green"])

    def create_status_panel(self, parent):
        """Create a status panel with system information"""
        # Create panel frame
        status_panel = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_medium"],
            corner_radius=15,
            border_width=1,
            border_color=self.colors["bg_light"]
        )

        # Panel header
        status_header = ctk.CTkFrame(
            status_panel, fg_color="transparent", height=50)
        status_header.pack(fill="x", padx=20, pady=(15, 5))

        # Panel title
        status_title = ctk.CTkLabel(
            status_header,
            text="System Status",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        status_title.pack(side="left")

        # Status indicators grid
        status_grid = ctk.CTkFrame(status_panel, fg_color="transparent")
        status_grid.pack(fill="both", expand=True, padx=20, pady=(5, 20))

        # Configure grid
        status_grid.columnconfigure((0, 1), weight=1)
        status_grid.rowconfigure((0, 1), weight=1)

        # Create status indicators
        indicators = [
            ("CPU Usage", "0%", self.colors["status_green"]),
            ("Memory", "0%", self.colors["status_green"]),
            ("Disk Space", "0%", self.colors["status_green"]),
            ("Voice Status", "Idle", self.colors["status_gray"])
        ]
        
        for i, (label, value, color) in enumerate(indicators):
            self.create_status_indicator(status_grid, label, value, color, i)

        return status_panel

    def create_status_indicator(self, parent, label, value, color, column):
#!/usr/bin/env python3
"""
Dragon Voice GUI - Main application interface for Dragon Voice Project
"""

from whisper_integration import WhisperRecognizer
import os
import sys
import json
import time
import logging
import webbrowser
import threading
from datetime import datetime
from pathlib import Path

# GUI libraries
import tkinter as tk
from tkinter import messagebox
import customtkinter as ctk
from PIL import Image, ImageTk

# System monitoring
import psutil
import platform

# Window management
import pygetwindow as gw
import pyautogui
import sounddevice as sd
import numpy as np
import tempfile
import os
import time
import threading

# Custom components
from synthesizer_bar import SynthesizerBar

# Try to import soundfile, but don't fail if it's not available
try:
    import soundfile as sf
    SOUNDFILE_AVAILABLE = True
except ImportError:
    SOUNDFILE_AVAILABLE = False
    print("Warning: soundfile module not found. Some audio features will be limited.")

# Configure logging
logging.basicConfig(
    level=logging.WARNING,  # Changed from INFO to WARNING
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("dragon_gui.log"),
        logging.StreamHandler()
    ]
)

# Constants
DEFAULT_CONFIG_PATH = "src/config.json"
ASSETS_DIR = os.path.join("src", "assets")

# Add Whisper integration


class DragonVoiceGUI:
    """
    Main GUI class for the Dragon Voice Project

    Provides a modern, feature-rich interface for controlling the voice assistant,
    managing chatbots, and configuring system settings.
    """

    def __init__(self, config_path=DEFAULT_CONFIG_PATH):
        """Initialize the DragonVoice GUI application"""
        logging.info("Initializing DragonVoiceGUI")

        try:
            # Initialize logging
            self.setup_logging()

            # Initialize state variables
            self.recording_active = False
            self.continuous_recording = False  # Flag for continuous recording
            self.is_fullscreen = False

            # Create main application window
            self.app = ctk.CTk()
            self.app.title("DragonVoice")
            self.app.geometry("1200x800")
            self.app.minsize(900, 600)

            # Load configuration
            self.config_path = config_path
            self.config = self.load_config()
            logging.info(f"Configuration loaded from {config_path}")

            # Set up theme and colors
            self.setup_theme()

            # Initialize Whisper recognizer
            self.init_whisper_recognizer()

            # Set up UI components
            self.setup_ui()

            # Start system monitoring
            self.start_system_monitoring()

        except Exception as e:
            logging.error(f"Error initializing DragonVoiceGUI: {str(e)}")
            raise

    def setup_logging(self):
        """Set up logging configuration"""
        # Check if logging is already configured
        if not logging.getLogger().handlers:
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - %(message)s'
            )
        logging.info("Logging setup complete")

    def setup_theme(self):
        """Set up the theme and colors for the application"""
        # Set appearance mode
        ctk.set_appearance_mode("dark")

        # Define color schemes with modern, sophisticated palettes
        self.color_schemes = {
            "aurora": {  # New default theme
                "bg_dark": "#1A1B26",      # Deep space blue
                "bg_medium": "#24283B",    # Midnight blue
                "bg_light": "#2F3549",     # Slate blue
                "accent_primary": "#7AA2F7",  # Electric blue
                "accent_secondary": "#BB9AF7",  # Soft purple
                "text_bright": "#C0CAF5",  # Ice blue
                "text_normal": "#9AA5CE",  # Muted blue
                "text_dim": "#565F89",     # Dark slate
                "status_green": "#9ECE6A",  # Sage green
                "status_yellow": "#E0AF68", # Warm amber
                "status_red": "#F7768E",    # Coral pink
                "status_blue": "#7DCFFF",   # Sky blue
                "status_gray": "#414868",   # Steel gray
                "separator": "#1F2335"      # Dark separator
            },
            "quantum": {  # High contrast theme
                "bg_dark": "#151515",      # Deep black
                "bg_medium": "#1E1E1E",    # Rich black
                "bg_light": "#252525",     # Soft black
                "accent_primary": "#00FF9C",  # Neon green
                "accent_secondary": "#00B8FF",  # Electric blue
                "text_bright": "#FFFFFF",   # Pure white
                "text_normal": "#CCCCCC",   # Light gray
                "text_dim": "#808080",      # Medium gray
                "status_green": "#00FF9C",  # Neon green
                "status_yellow": "#FFD700", # Gold
                "status_red": "#FF3366",    # Hot pink
                "status_blue": "#00B8FF",   # Electric blue
                "status_gray": "#404040",   # Dark gray
                "separator": "#333333"      # Dark separator
            },
            "glacier": {  # Light theme
                "bg_dark": "#E8EEF2",      # Ice white
                "bg_medium": "#D5E3EC",    # Glacier blue
                "bg_light": "#C2D8E9",     # Soft blue
                "accent_primary": "#2B7BB9",  # Deep blue
                "accent_secondary": "#5C6BC0",  # Royal blue
                "text_bright": "#1A1A1A",   # Near black
                "text_normal": "#2D2D2D",   # Dark gray
                "text_dim": "#5D5D5D",      # Medium gray
                "status_green": "#2E7D32",  # Forest green
                "status_yellow": "#F9A825", # Sunflower
                "status_red": "#C62828",    # Ruby red
                "status_blue": "#1565C0",   # Ocean blue
                "status_gray": "#90A4AE",   # Cool gray
                "separator": "#B0BEC5"      # Light separator
            }
        }

        # Set default color scheme
        self.colors = self.color_schemes["aurora"]

        # Define modern font system
        self.fonts = {
            "header": ctk.CTkFont(family="Segoe UI", size=32, weight="bold"),
            "title": ctk.CTkFont(family="Segoe UI", size=24, weight="bold"),
            "subtitle": ctk.CTkFont(family="Segoe UI", size=18, weight="bold"),
            "normal": ctk.CTkFont(family="Segoe UI", size=14),
            "small": ctk.CTkFont(family="Segoe UI", size=12),
            "tiny": ctk.CTkFont(family="Segoe UI", size=10),
            "mono": ctk.CTkFont(family="JetBrains Mono", size=12),
            "large": ctk.CTkFont(family="Segoe UI", size=20),
            "display": ctk.CTkFont(family="Segoe UI", size=40, weight="bold"),
            "button": ctk.CTkFont(family="Segoe UI", size=14, weight="bold"),
            "caption": ctk.CTkFont(family="Segoe UI", size=11),
            "code": ctk.CTkFont(family="JetBrains Mono", size=13)
        }

        # Define corner radius system
        self.corners = {
            "small": 4,
            "medium": 8,
            "large": 12,
            "xl": 16,
            "pill": 24
        }

        # Define spacing system
        self.spacing = {
            "xs": 4,
            "small": 8,
            "medium": 16,
            "large": 24,
            "xl": 32,
            "xxl": 48
        }

        # Define shadow system
        self.shadows = {
            "small": "0 2px 4px rgba(0,0,0,0.1)",
            "medium": "0 4px 8px rgba(0,0,0,0.15)",
            "large": "0 8px 16px rgba(0,0,0,0.2)"
        }

        # Animation durations
        self.animations = {
            "fast": 150,
            "normal": 250,
            "slow": 350
        }

    def init_whisper_recognizer(self):
        """Initialize the Whisper recognizer"""
        try:
            # Initialize API keys from environment or config
            self.openai_api_key = os.environ.get("OPENAI_API_KEY", "")
            if not self.openai_api_key and "openai_api_key" in self.config:
                self.openai_api_key = self.config["openai_api_key"]
                os.environ["OPENAI_API_KEY"] = self.openai_api_key

            # Initialize WhisperRecognizer with error handling
            if self.openai_api_key:
                self.whisper_recognizer = WhisperRecognizer(
                    api_key=self.openai_api_key)
                logging.info("WhisperRecognizer initialized successfully")
            else:
                logging.warning(
                    "No OpenAI API key found, WhisperRecognizer not initialized")
                self.whisper_recognizer = None
        except Exception as e:
            logging.error(f"Failed to initialize WhisperRecognizer: {str(e)}")
            self.whisper_recognizer = None

    def setup_ui(self):
        """Set up the main user interface"""
        try:
            # Create main container
            self.main_container = ctk.CTkFrame(self.app)
            self.main_container.pack(fill="both", expand=True)
            
            # Configure grid
            self.main_container.grid_columnconfigure(0, weight=1)
            self.main_container.grid_rowconfigure(1, weight=1)  # Content area expands
            
            # Create UI sections
            self.create_header()      # Row 0
            self.create_content()     # Row 1
            self.create_footer()      # Row 2
            
            # Start system monitoring
            self.start_system_monitoring()
            
            # Initial status update
            self.update_status("Ready")
            
        except Exception as e:
            logging.error(f"Error setting up UI: {str(e)}", exc_info=True)
            raise  # Re-raise the exception for proper error handling

    def create_content(self):
        """Create the main content area with tabs"""
        # Create content frame
        self.content_frame = ctk.CTkFrame(self.main_container, fg_color="transparent")
        self.content_frame.grid(row=1, column=0, sticky="nsew", padx=20, pady=10)
        
        # Configure content frame grid
        self.content_frame.grid_rowconfigure(0, weight=1)
        self.content_frame.grid_columnconfigure(0, weight=1)
        
        # Create tab view
        self.tab_view = ctk.CTkTabview(
            self.content_frame,
            fg_color=self.colors["bg_dark"],
            segmented_button_fg_color=self.colors["bg_medium"],
            segmented_button_selected_color=self.colors["accent_primary"],
            segmented_button_selected_hover_color=self.colors["accent_secondary"],
            segmented_button_unselected_color=self.colors["bg_medium"],
            segmented_button_unselected_hover_color=self.colors["bg_light"]
        )
        self.tab_view.grid(row=0, column=0, sticky="nsew")
        
        # Define tabs with icons
        tabs = [
            ("Dashboard", "üìä"),
            ("Chatbots", "ü§ñ"),
            ("History", "üìú"),
            ("Configuration", "‚öôÔ∏è"),
            ("About", "‚ÑπÔ∏è")
        ]
        
        # Add tabs
        for tab_name, icon in tabs:
            self.tab_view.add(tab_name)
            tab = self.tab_view.tab(tab_name)
            tab.configure(fg_color=self.colors["bg_dark"])
            
            # Configure tab grid
            tab.grid_rowconfigure(0, weight=1)
            tab.grid_columnconfigure(0, weight=1)
            
            # Add icon to tab button
            if hasattr(self.tab_view, "_segmented_button"):
                button = self.tab_view._segmented_button
                button._buttons_dict[tab_name].configure(
                    text=f"{icon} {tab_name}",
                    font=self.fonts["button"],
                    height=32,
                    corner_radius=self.corners["medium"]
                )
        
        # Set default tab
        self.tab_view.set("Dashboard")
        
        # Create tab contents
        self.create_dashboard_tab()
        self.create_chatbots_tab()
        self.create_history_tab()
        self.create_config_tab()
        self.create_about_tab()

    def create_header(self):
        """Create the application header"""
        # Create header frame
        self.header_frame = ctk.CTkFrame(
            self.main_container,
            fg_color=self.colors["bg_dark"],
            height=80
        )
        self.header_frame.grid(row=0, column=0, sticky="ew")
        self.header_frame.grid_propagate(False)
        
        # Configure header grid
        self.header_frame.grid_columnconfigure(1, weight=1)  # Center section expands
        
        # Left section - Logo and title
        left_section = ctk.CTkFrame(self.header_frame, fg_color="transparent")
        left_section.grid(row=0, column=0, padx=20, pady=10, sticky="w")
        
        # Try to load logo
        try:
            assets_dir = os.path.join("src", "assets")
            logo_path = os.path.join(assets_dir, "dragon_logo.png")
            
            # Create assets directory if it doesn't exist
            if not os.path.exists(assets_dir):
                os.makedirs(assets_dir)
                logging.warning(f"Created missing assets directory: {assets_dir}")
            
            if os.path.exists(logo_path):
                logo_image = ctk.CTkImage(
                    light_image=Image.open(logo_path),
                    dark_image=Image.open(logo_path),
                    size=(36, 36)
                )
                logo_label = ctk.CTkLabel(
                    left_section,
                    image=logo_image,
                    text=""
                )
                logo_label.pack(side="left", padx=(0, 10))
            else:
                # Create text-based logo as fallback
                logo_label = ctk.CTkLabel(
                    left_section,
                    text="üêâ",
                    font=("Segoe UI Emoji", 24),
                    text_color=self.colors["accent_primary"]
                )
                logo_label.pack(side="left", padx=(0, 10))
                logging.warning(f"Logo file not found: {logo_path}, using emoji fallback")
        except Exception as e:
            logging.error(f"Failed to load logo: {str(e)}")
            # Create text-based logo as fallback
            logo_label = ctk.CTkLabel(
                left_section,
                text="üêâ",
                font=("Segoe UI Emoji", 24),
                text_color=self.colors["accent_primary"]
            )
            logo_label.pack(side="left", padx=(0, 10))
        
        # App title
        title_label = ctk.CTkLabel(
            left_section,
            text="DragonVoice",
            font=self.fonts["header"],
            text_color=self.colors["text_bright"]
        )
        title_label.pack(side="left")
        
        # Version pill
        version_pill = ctk.CTkFrame(
            left_section,
            fg_color=self.colors["accent_primary"],
            corner_radius=self.corners["pill"]
        )
        version_pill.pack(side="left", padx=10)
        
        version_label = ctk.CTkLabel(
            version_pill,
            text="v2.0",
            font=self.fonts["caption"],
            text_color=self.colors["text_bright"]
        )
        version_label.pack(padx=10, pady=2)
        
        # Center section - Status
        center_section = ctk.CTkFrame(self.header_frame, fg_color="transparent")
        center_section.grid(row=0, column=1, sticky="ew")
        
        # Right section - Controls
        right_section = ctk.CTkFrame(self.header_frame, fg_color="transparent")
        right_section.grid(row=0, column=2, padx=20, pady=10, sticky="e")
        
        # Microphone selector
        mic_frame = ctk.CTkFrame(
            right_section,
            fg_color=self.colors["bg_light"],
            corner_radius=self.corners["medium"]
        )
        mic_frame.pack(side="left", padx=(0, 10))
        
        mic_label = ctk.CTkLabel(
            mic_frame,
            text="üé§",
            font=self.fonts["normal"]
        )
        mic_label.pack(side="left", padx=10, pady=5)
        
        self.mic_var = ctk.StringVar(value="Default Microphone")
        self.mic_dropdown = ctk.CTkOptionMenu(
            mic_frame,
            values=["Default Microphone"],
            variable=self.mic_var,
            width=140,
            dynamic_resizing=True
        )
        self.mic_dropdown.pack(side="left", padx=(0, 10), pady=5)
        
        # Control buttons
        for icon, command in [
            ("üé®", self.toggle_theme),
            ("‚öôÔ∏è", self.show_settings),
            ("‚ùî", self.show_help)
        ]:
            btn = ctk.CTkButton(
                right_section,
                text=icon,
                width=34,
                height=34,
                corner_radius=self.corners["medium"],
                fg_color=self.colors["bg_light"],
                hover_color=self.colors["accent_primary"],
                command=command
            )
            btn.pack(side="left", padx=5)

    def create_footer(self):
        """Create the application footer"""
        # Create footer frame
        self.footer = ctk.CTkFrame(
            self.main_container,
            fg_color=self.colors["bg_dark"],
            height=28
        )
        self.footer.grid(row=2, column=0, sticky="ew")
        self.footer.grid_propagate(False)
        
        # Configure footer grid
        self.footer.grid_columnconfigure(1, weight=1)  # Center section expands
        
        # Left section - Status
        status_frame = ctk.CTkFrame(self.footer, fg_color="transparent")
        status_frame.grid(row=0, column=0, padx=20, sticky="w")
        
        self.status_dot = ctk.CTkLabel(
            status_frame,
            text="‚óè",
            font=self.fonts["small"],
            text_color=self.colors["status_green"],
            width=20
        )
        self.status_dot.pack(side="left")
        
        self.status_label = ctk.CTkLabel(
            status_frame,
            text="Ready",
            font=self.fonts["caption"],
            text_color=self.colors["text_dim"]
        )
        self.status_label.pack(side="left", padx=5)
        
        # Center section - System metrics
        metrics_frame = ctk.CTkFrame(self.footer, fg_color="transparent")
        metrics_frame.grid(row=0, column=1, sticky="ew")
        
        metrics = [
            ("CPU", "0%", self.colors["status_green"]),
            ("RAM", "0%", self.colors["status_green"]),
            ("Disk", "0%", self.colors["status_green"])
        ]
        
        for i, (label, value, color) in enumerate(metrics):
            metric_frame = ctk.CTkFrame(metrics_frame, fg_color="transparent")
            metric_frame.pack(side="left", padx=20)
            
            ctk.CTkLabel(
                metric_frame,
                text=label,
                font=self.fonts["caption"],
                text_color=self.colors["text_dim"]
            ).pack(side="left")
            
            value_label = ctk.CTkLabel(
                metric_frame,
                text=value,
                font=self.fonts["caption"],
                text_color=color
            )
            value_label.pack(side="left", padx=5)
            setattr(self, f'metric_value_{i}', value_label)
        
        # Right section - Build info
        build_frame = ctk.CTkFrame(self.footer, fg_color="transparent")
        build_frame.grid(row=0, column=2, padx=20, sticky="e")
        
        build_label = ctk.CTkLabel(
            build_frame,
            text="Build 2024.03",
            font=self.fonts["caption"],
            text_color=self.colors["text_dim"]
        )
        build_label.pack()

    def create_dashboard_tab(self):
        """Create the dashboard tab content"""
        dashboard = self.tab_view.tab("Dashboard")
        
        # Configure grid
        dashboard.grid_columnconfigure(0, weight=2)  # Status panel
        dashboard.grid_columnconfigure(1, weight=1)  # Control panel
        dashboard.grid_rowconfigure(1, weight=1)     # Voice commands section
        dashboard.grid_rowconfigure(2, weight=1)     # Transcription section
        
        # Status panel (top left)
        status_panel = ctk.CTkFrame(
            dashboard,
            fg_color=self.colors["bg_medium"],
            corner_radius=15
        )
        status_panel.grid(row=0, column=0, sticky="nsew", padx=(20, 10), pady=(20, 10))
        
        # Status panel title
        status_title = ctk.CTkLabel(
            status_panel,
            text="System Status",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        status_title.pack(anchor="w", padx=20, pady=(15, 10))
        
        # Status indicators grid
        indicators_frame = ctk.CTkFrame(status_panel, fg_color="transparent")
        indicators_frame.pack(fill="both", expand=True, padx=20, pady=(0, 20))
        
        # Configure indicators grid
        indicators_frame.columnconfigure((0, 1), weight=1)
        indicators_frame.rowconfigure((0, 1), weight=1)
        
        # Create status indicators
        self.create_status_indicator(indicators_frame, "CPU Usage", "0%", self.colors["status_green"], 0, 0)
        self.create_status_indicator(indicators_frame, "Memory", "0%", self.colors["status_green"], 0, 1)
        self.create_status_indicator(indicators_frame, "Disk Space", "0%", self.colors["status_green"], 1, 0)
        self.create_status_indicator(indicators_frame, "Voice Status", "Idle", self.colors["status_gray"], 1, 1)
        
        # Voice assistant control panel (top right)
        control_panel = ctk.CTkFrame(
            dashboard,
            fg_color=self.colors["bg_medium"],
            corner_radius=15
        )
        control_panel.grid(row=0, column=1, sticky="nsew", padx=(10, 20), pady=(20, 10))
        
        # Control panel title
        control_title = ctk.CTkLabel(
            control_panel,
            text="Voice Assistant",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        control_title.pack(anchor="w", padx=20, pady=(15, 10))
        
        # Start/Stop button
        self.toggle_button = ctk.CTkButton(
            control_panel,
            text="Start Voice Assistant",
            command=self.toggle_voice_assistant,
            fg_color=self.colors["status_green"],
            hover_color=self._adjust_color_brightness(self.colors["status_green"], 0.8),
            height=50,
            corner_radius=10,
            font=self.fonts["subtitle"]
        )
        self.toggle_button.pack(fill="x", padx=20, pady=10)
        
        # Recording buttons frame
        recording_frame = ctk.CTkFrame(control_panel, fg_color="transparent")
        recording_frame.pack(fill="x", padx=20, pady=5)
        
        # Configure recording frame grid
        recording_frame.columnconfigure((0, 1), weight=1)
        
        # Record button
        self.record_button = ctk.CTkButton(
            recording_frame,
            text="Record",
            command=self.start_manual_recording,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            height=40
        )
        self.record_button.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        
        # Stop Recording button
        self.stop_record_button = ctk.CTkButton(
            recording_frame,
            text="Stop Recording",
            command=self.stop_manual_recording,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["accent_primary"],
            height=40,
            state="disabled"
        )
        self.stop_record_button.grid(row=0, column=1, sticky="ew", padx=(5, 0))
        
        # Add synthesizer bar
        self.synth_bar = SynthesizerBar(control_panel, self.colors, self.fonts)
        
        # Voice commands section (middle)
        commands_frame = ctk.CTkFrame(
            dashboard,
            fg_color=self.colors["bg_medium"],
            corner_radius=15
        )
        commands_frame.grid(row=1, column=0, columnspan=2, sticky="nsew", padx=20, pady=10)
        
        # Commands title with clear button
        commands_header = ctk.CTkFrame(commands_frame, fg_color="transparent")
        commands_header.pack(fill="x", padx=20, pady=(15, 10))
        
        commands_title = ctk.CTkLabel(
            commands_header,
            text="Voice Commands",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        commands_title.pack(side="left")
        
        clear_commands = ctk.CTkButton(
            commands_header,
            text="Clear",
            command=lambda: self.clear_text_display("text_display"),
            width=80,
            fg_color=self.colors["accent_secondary"]
        )
        clear_commands.pack(side="right")
        
        # Commands text display
        self.text_display = ctk.CTkTextbox(
            commands_frame,
            fg_color=self.colors["bg_light"],
            text_color=self.colors["text_bright"],
            font=self.fonts["normal"],
            corner_radius=10,
            height=150
        )
        self.text_display.pack(fill="both", expand=True, padx=20, pady=(5, 15))
        
        # Configure text tags
        self.text_display._textbox.tag_configure("timestamp", foreground=self.colors["accent_secondary"])
        self.text_display._textbox.tag_configure("command", foreground=self.colors["text_bright"])
        self.text_display._textbox.tag_configure("system", foreground=self.colors["status_blue"])
        
        # Transcription section (bottom)
        transcription_frame = ctk.CTkFrame(
            dashboard,
            fg_color=self.colors["bg_medium"],
            corner_radius=15
        )
        transcription_frame.grid(row=2, column=0, columnspan=2, sticky="nsew", padx=20, pady=(10, 20))
        
        # Transcription header
        transcription_header = ctk.CTkFrame(transcription_frame, fg_color="transparent")
        transcription_header.pack(fill="x", padx=20, pady=(15, 10))
        
        transcription_title = ctk.CTkLabel(
            transcription_header,
            text="Transcribed Text",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        transcription_title.pack(side="left")
        
        clear_transcription = ctk.CTkButton(
            transcription_header,
            text="Clear",
            command=lambda: self.clear_text_display("transcription_display"),
            width=80,
            fg_color=self.colors["accent_secondary"]
        )
        clear_transcription.pack(side="right")
        
        # Transcription display
        self.transcription_display = ctk.CTkTextbox(
            transcription_frame,
            fg_color=self.colors["bg_light"],
            text_color=self.colors["text_bright"],
            font=self.fonts["normal"],
            corner_radius=10,
            height=100
        )
        self.transcription_display.pack(fill="both", expand=True, padx=20, pady=(5, 10))
        
        # Enter button frame
        enter_frame = ctk.CTkFrame(transcription_frame, fg_color="transparent")
        enter_frame.pack(fill="x", padx=20, pady=(0, 15))
        
        # Enter button
        self.enter_button = ctk.CTkButton(
            enter_frame,
            text="Enter",
            command=self.process_transcription,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            height=40,
            state="disabled"
        )
        self.enter_button.pack(side="right")

    def clear_text_display(self, display_name):
        """Clear the specified text display"""
        if hasattr(self, display_name):
            display = getattr(self, display_name)
            display.configure(state="normal")
            display.delete(1.0, "end")
            display.configure(state="disabled")

    def create_chatbots_tab(self):
        """Create the chatbots tab content"""
        chatbots = self.tab_view.tab("Chatbots")
        
        # Configure grid
        chatbots.grid_columnconfigure(0, weight=1)
        chatbots.grid_rowconfigure(2, weight=1)  # Chatbot list expands
        
        # Title and add button row
        title_frame = ctk.CTkFrame(chatbots, fg_color="transparent")
        title_frame.grid(row=0, column=0, sticky="ew", padx=20, pady=(20, 10))
        
        # Configure title frame grid
        title_frame.grid_columnconfigure(1, weight=1)
        
        # Title
        title_label = ctk.CTkLabel(
            title_frame,
            text="Chatbot Management",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        title_label.grid(row=0, column=0, sticky="w")
        
        # Add chatbot button
        add_button = ctk.CTkButton(
            title_frame,
            text="Add New Chatbot",
            command=self.show_add_chatbot_dialog,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            width=150
        )
        add_button.grid(row=0, column=2, sticky="e")
        
        # Search bar
        search_frame = ctk.CTkFrame(
            chatbots,
            fg_color=self.colors["bg_medium"],
            corner_radius=10,
            height=50
        )
        search_frame.grid(row=1, column=0, sticky="ew", padx=20, pady=10)
        search_frame.grid_propagate(False)
        
        # Configure search frame grid
        search_frame.grid_columnconfigure(1, weight=1)
        
        # Search icon
        search_icon = ctk.CTkLabel(
            search_frame,
            text="üîç",
            font=self.fonts["normal"],
            width=30
        )
        search_icon.grid(row=0, column=0, padx=(15, 0), pady=10)
        
        # Search entry
        self.search_var = ctk.StringVar()
        self.search_var.trace_add("write", lambda *args: self.filter_chatbot_list())
        search_entry = ctk.CTkEntry(
            search_frame,
            placeholder_text="Search chatbots...",
            textvariable=self.search_var,
            border_width=0,
            fg_color="transparent",
            height=40
        )
        search_entry.grid(row=0, column=1, sticky="ew", padx=10)
        
        # Chatbot list
        self.chatbot_list_frame = ctk.CTkScrollableFrame(
            chatbots,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        self.chatbot_list_frame.grid(row=2, column=0, sticky="nsew", padx=20, pady=(0, 20))
        
        # Configure list frame grid
        self.chatbot_list_frame.grid_columnconfigure(0, weight=1)
        
        # Add header
        header = ctk.CTkFrame(
            self.chatbot_list_frame,
            fg_color=self.colors["bg_dark"],
            corner_radius=10,
            height=40
        )
        header.grid(row=0, column=0, sticky="ew", pady=(0, 10))
        header.grid_propagate(False)
        
        # Configure header grid
        header.grid_columnconfigure((0, 1, 2), weight=1)
        
        # Header labels
        for i, text in enumerate(["Name", "Type", "Status"]):
            label = ctk.CTkLabel(
                header,
                text=text,
                font=self.fonts["subtitle"],
                text_color=self.colors["text_bright"]
            )
            label.grid(row=0, column=i, padx=20, pady=10)
        
        # Refresh chatbot list
        self.refresh_chatbots()

    def add_chatbot_list_item(self, name, config):
        """Add a single chatbot item to the list"""
        # Get next row index
        row = len(self.chatbot_list_frame._scrollable_frame_children)
        
        # Create item frame
        item = ctk.CTkFrame(
            self.chatbot_list_frame,
            fg_color=self.colors["bg_dark"],
            corner_radius=10,
            height=70
        )
        item.grid(row=row, column=0, sticky="ew", padx=5, pady=5)
        item.grid_propagate(False)
        
        # Configure item grid
        item.grid_columnconfigure(1, weight=1)  # Name/type section expands
        
        # Icon frame
        icon_frame = ctk.CTkFrame(
            item,
            fg_color=config.get("color", self.colors["accent_primary"]),
            width=40,
            height=40,
            corner_radius=20
        )
        icon_frame.grid(row=0, column=0, padx=15, pady=15)
        icon_frame.grid_propagate(False)
        
        # Icon label
        icon_label = ctk.CTkLabel(
            icon_frame,
            text=config.get("icon", "ü§ñ"),
            font=self.fonts["large"]
        )
        icon_label.place(relx=0.5, rely=0.5, anchor="center")
        
        # Name and type section
        info_frame = ctk.CTkFrame(item, fg_color="transparent")
        info_frame.grid(row=0, column=1, sticky="nsw", pady=10)
        
        # Name
        name_label = ctk.CTkLabel(
            info_frame,
            text=name,
            font=self.fonts["subtitle"],
            text_color=self.colors["text_bright"]
        )
        name_label.grid(row=0, column=0, sticky="w")
        
        # Type
        type_label = ctk.CTkLabel(
            info_frame,
            text=config.get("type", "Unknown"),
            font=self.fonts["small"],
            text_color=self.colors["text_dim"]
        )
        type_label.grid(row=1, column=0, sticky="w")
        
        # Status section
        status_frame = ctk.CTkFrame(item, fg_color="transparent")
        status_frame.grid(row=0, column=2, padx=15)
        
        # Status indicator
        status_color = self.colors["status_green"] if config.get("status") == "Ready" else self.colors["status_red"]
        status_dot = ctk.CTkLabel(
            status_frame,
            text="‚óè",
            font=self.fonts["large"],
            text_color=status_color
        )
        status_dot.grid(row=0, column=0, padx=5)
        
        # Status text
        status_label = ctk.CTkLabel(
            status_frame,
            text=config.get("status", "Unknown"),
            font=self.fonts["small"],
            text_color=status_color
        )
        status_label.grid(row=0, column=1)
        
        # Add hover effect
        def on_enter(e):
            item.configure(fg_color=self.colors["bg_light"])
            
        def on_leave(e):
            item.configure(fg_color=self.colors["bg_dark"])
            
        item.bind("<Enter>", on_enter)
        item.bind("<Leave>", on_leave)
        
        # Make item clickable
        item.bind("<Button-1>", lambda e: self.show_chatbot_settings(name, config))

    def delete_chatbot(self, name):
        """Delete a chatbot from the configuration"""
        if name in self.config.get("chatbots", {}):
            del self.config["chatbots"][name]
            self.save_configuration()
            self.refresh_chatbot_list()
            # Also refresh the dashboard
            self.add_sample_chatbot_cards()

    def run(self):
        """Run the application main loop"""
        try:
            # Log startup
            logging.info("Starting DragonVoice application")

            # Update status
            self.update_status("Application started successfully")

            # Start the main event loop
            self.app.mainloop()

        except Exception as e:
            logging.error(f"Error in main loop: {str(e)}")
            raise

    def create_help_getting_started(self, parent):
        """Create the getting started help content"""
        # Welcome section
        welcome_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        welcome_frame.pack(fill="x", padx=20, pady=10)

        welcome_label = ctk.CTkLabel(
            welcome_frame,
            text="Welcome to DragonVoice",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        welcome_label.pack(anchor="w", padx=15, pady=(10, 5))

        welcome_text = ctk.CTkTextbox(
            welcome_frame,
            height=100,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        welcome_text.pack(fill="x", padx=15, pady=(0, 10))
        welcome_text.insert(
            "1.0",
            """DragonVoice is a powerful voice-controlled interface for interacting with multiple AI chatbots. This guide will help you get started with the basic features and setup.""")
        welcome_text.configure(state="disabled")

        # Quick Start Guide
        quickstart_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        quickstart_frame.pack(fill="x", padx=20, pady=10)

        quickstart_label = ctk.CTkLabel(
            quickstart_frame,
            text="Quick Start Guide",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        quickstart_label.pack(anchor="w", padx=15, pady=(10, 5))

        steps_text = ctk.CTkTextbox(
            quickstart_frame,
            height=200,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        steps_text.pack(fill="x", padx=15, pady=(0, 10))
        steps_text.insert("1.0", """1. Configure Your Chatbots
‚Ä¢ Click the Settings button (‚öôÔ∏è) in the top right
‚Ä¢ Go to the Chatbots tab
‚Ä¢ Click "Add New Chatbot" and enter your API keys

2. Start Voice Assistant
‚Ä¢ Click the "Start Voice Assistant" button in the header
‚Ä¢ Wait for the status to show "Ready"
‚Ä¢ Say your wake word (default: "Hey Dragon")

3. Issue Commands
‚Ä¢ After the wake word, speak your command
‚Ä¢ Example: "Ask what are the latest treatments for hypertension"
‚Ä¢ The command will be sent to the appropriate chatbot

4. View Responses
‚Ä¢ Responses appear in the chatbot windows
‚Ä¢ You can interact with multiple chatbots simultaneously
‚Ä¢ Use voice commands to switch between chatbots""")
        steps_text.configure(state="disabled")

    def create_help_voice_commands(self, parent):
        """Create the voice commands help content"""
        # Available Commands
        commands_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        commands_frame.pack(fill="x", padx=20, pady=10)

        commands_label = ctk.CTkLabel(
            commands_frame,
            text="Available Voice Commands",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        commands_label.pack(anchor="w", padx=15, pady=(10, 5))

        commands_text = ctk.CTkTextbox(
            commands_frame,
            height=400,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        commands_text.pack(fill="x", padx=15, pady=(0, 10))
        commands_text.insert("1.0", """Basic Commands:
‚Ä¢ "Hey Dragon" - Wake word to start listening
‚Ä¢ "Ask [question]" - Send a question to the active chatbot
‚Ä¢ "Switch to [chatbot name]" - Change the active chatbot
‚Ä¢ "Stop listening" - Deactivate voice recognition
‚Ä¢ "Clear chat" - Clear the current conversation

Chatbot Control:
‚Ä¢ "New conversation" - Start a fresh chat session
‚Ä¢ "Save conversation" - Save the current chat history
‚Ä¢ "Load conversation" - Restore a previous chat session
‚Ä¢ "Export as PDF" - Export the conversation to PDF

Window Management:
‚Ä¢ "Maximize window" - Expand the current chatbot window
‚Ä¢ "Minimize window" - Minimize the current chatbot window
‚Ä¢ "Arrange windows" - Organize all chatbot windows
‚Ä¢ "Close window" - Close the current chatbot window

System Commands:
‚Ä¢ "Open settings" - Show the settings dialog
‚Ä¢ "Show help" - Display this help window
‚Ä¢ "Check status" - Report system status
‚Ä¢ "Exit program" - Close DragonVoice

Tips:
‚Ä¢ Speak clearly and at a normal pace
‚Ä¢ Wait for the "Listening..." indicator
‚Ä¢ You can customize the wake word in settings
‚Ä¢ Commands are case-insensitive""")
        commands_text.configure(state="disabled")

    def create_help_chatbots(self, parent):
        """Create the chatbots help content"""
        # Chatbot Overview
        overview_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        overview_frame.pack(fill="x", padx=20, pady=10)

        overview_label = ctk.CTkLabel(
            overview_frame,
            text="Working with Chatbots",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        overview_label.pack(anchor="w", padx=15, pady=(10, 5))

        overview_text = ctk.CTkTextbox(
            overview_frame,
            height=300,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        overview_text.pack(fill="x", padx=15, pady=(0, 10))
        overview_text.insert(
            "1.0", """DragonVoice supports multiple AI chatbots, allowing you to:
‚Ä¢ Interact with different AI models simultaneously
‚Ä¢ Compare responses across different chatbots
‚Ä¢ Use specialized models for specific tasks
‚Ä¢ Maintain separate conversation contexts

Supported Chatbots:
1. GPT (OpenAI)
   ‚Ä¢ Requires OpenAI API key
   ‚Ä¢ Supports GPT-3.5 and GPT-4
   ‚Ä¢ Best for general knowledge and coding

2. Claude (Anthropic)
   ‚Ä¢ Requires Anthropic API key
   ‚Ä¢ Excellent for analysis and writing
   ‚Ä¢ Strong ethical considerations

3. Gemini (Google)
   ‚Ä¢ Requires Google API key
   ‚Ä¢ Good at mathematical reasoning
   ‚Ä¢ Supports image understanding

4. Custom Chatbots
   ‚Ä¢ Add your own API integrations
   ‚Ä¢ Configure custom endpoints
   ‚Ä¢ Define specialized behaviors

Setting Up Chatbots:
1. Obtain API keys from providers
2. Add chatbots in Settings > Chatbots
3. Configure any special parameters
4. Test the connection

Best Practices:
‚Ä¢ Keep API keys secure
‚Ä¢ Monitor usage and costs
‚Ä¢ Regular backup conversations
‚Ä¢ Update chatbot configs as needed""")
        overview_text.configure(state="disabled")

    def create_help_troubleshooting(self, parent):
        """Create the troubleshooting help content"""
        # Common Issues
        issues_frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        issues_frame.pack(fill="x", padx=20, pady=10)

        issues_label = ctk.CTkLabel(
            issues_frame,
            text="Common Issues",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        issues_label.pack(anchor="w", padx=15, pady=(10, 5))

        issues_text = ctk.CTkTextbox(
            issues_frame,
            height=400,
            fg_color="transparent",
            text_color=self.colors["text_normal"],
            wrap="word"
        )
        issues_text.pack(fill="x", padx=15, pady=(0, 10))
        issues_text.insert("1.0", """Voice Recognition Issues:
1. Microphone Not Detected
   ‚Ä¢ Check microphone connections
   ‚Ä¢ Verify Windows permissions
   ‚Ä¢ Select correct input device in settings
   ‚Ä¢ Try restarting the application

2. Poor Recognition Accuracy
   ‚Ä¢ Adjust microphone sensitivity
   ‚Ä¢ Reduce background noise
   ‚Ä¢ Speak clearly and at normal pace
   ‚Ä¢ Check for latest updates

Chatbot Connection Problems:
1. API Key Errors
   ‚Ä¢ Verify API key is valid
   ‚Ä¢ Check for sufficient credits
   ‚Ä¢ Ensure correct API endpoint
   ‚Ä¢ Look for error messages in logs

2. Slow Responses
   ‚Ä¢ Check internet connection
   ‚Ä¢ Verify server status
   ‚Ä¢ Adjust timeout settings
   ‚Ä¢ Consider upgrading API tier

Interface Issues:
1. Display Problems
   ‚Ä¢ Update graphics drivers
   ‚Ä¢ Check resolution settings
   ‚Ä¢ Try different theme
   ‚Ä¢ Restart application

2. Performance Issues
   ‚Ä¢ Close unused applications
   ‚Ä¢ Check CPU/memory usage
   ‚Ä¢ Reduce number of active chatbots
   ‚Ä¢ Clear conversation history

Getting Help:
‚Ä¢ Check application logs
‚Ä¢ Visit our support forum
‚Ä¢ Submit bug reports
‚Ä¢ Contact technical support""")
        issues_text.configure(state="disabled")

    def create_about_tab(self):
        """Create the about tab content"""
        about = self.tab_view.tab("About")
        
        # Configure grid
        about.grid_columnconfigure(0, weight=1)
        about.grid_rowconfigure(1, weight=1)  # Content area expands
        
        # Title section
        title_frame = ctk.CTkFrame(about, fg_color="transparent")
        title_frame.grid(row=0, column=0, sticky="ew", padx=20, pady=(20, 10))
        
        # App logo
        logo_label = ctk.CTkLabel(
            title_frame,
            text="üêâ",
            font=self.fonts["display"],
            text_color=self.colors["accent_primary"]
        )
        logo_label.pack(anchor="center", pady=10)
        
        # App title
        title_label = ctk.CTkLabel(
            title_frame,
            text="DragonVoice",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        title_label.pack(anchor="center")
        
        # Version
        version_label = ctk.CTkLabel(
            title_frame,
            text="Version 2.0",
            font=self.fonts["small"],
            text_color=self.colors["text_dim"]
        )
        version_label.pack(anchor="center", pady=(0, 10))
        
        # Create scrollable content area
        content_frame = ctk.CTkScrollableFrame(
            about,
            fg_color="transparent"
        )
        content_frame.grid(row=1, column=0, sticky="nsew", padx=20, pady=(0, 20))
        
        # Configure content grid
        content_frame.grid_columnconfigure(0, weight=1)
        
        # Description section
        description_frame = ctk.CTkFrame(
            content_frame,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        description_frame.grid(row=0, column=0, sticky="ew", pady=(0, 10))
        
        description_label = ctk.CTkLabel(
            description_frame,
            text="DragonVoice is an advanced voice assistant that integrates with multiple AI chatbots.\n"
                 "It provides a seamless voice interface for interacting with AI models and controlling your computer.",
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"],
            wraplength=800,
            justify="left"
        )
        description_label.pack(padx=20, pady=20)
        
        # Features section
        features_frame = ctk.CTkFrame(
            content_frame,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        features_frame.grid(row=1, column=0, sticky="ew", pady=(0, 10))
        
        features_title = ctk.CTkLabel(
            features_frame,
            text="Key Features",
            font=self.fonts["subtitle"],
            text_color=self.colors["text_bright"]
        )
        features_title.pack(anchor="w", padx=20, pady=(15, 10))
        
        features = [
            "üé§ Voice recognition with OpenAI Whisper",
            "ü§ñ Multiple AI chatbot integrations",
            "‚å®Ô∏è System control through voice commands",
            "üìä Real-time system monitoring",
            "üé® Customizable themes and appearance",
            "üîß Advanced configuration options"
        ]
        
        for feature in features:
            feature_label = ctk.CTkLabel(
                features_frame,
                text=feature,
                font=self.fonts["normal"],
                text_color=self.colors["text_normal"],
                anchor="w"
            )
            feature_label.pack(anchor="w", padx=20, pady=5)
        
        # Credits section
        credits_frame = ctk.CTkFrame(
            content_frame,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        credits_frame.grid(row=2, column=0, sticky="ew", pady=(0, 10))
        
        credits_title = ctk.CTkLabel(
            credits_frame,
            text="Credits",
            font=self.fonts["subtitle"],
            text_color=self.colors["text_bright"]
        )
        credits_title.pack(anchor="w", padx=20, pady=(15, 10))
        
        credits_text = ctk.CTkLabel(
            credits_frame,
            text="Developed by: DragonVoice Team\n"
                 "UI Framework: CustomTkinter\n"
                 "Voice Recognition: OpenAI Whisper\n"
                 "Special thanks to all contributors and testers",
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"],
            justify="left"
        )
        credits_text.pack(anchor="w", padx=20, pady=(0, 15))
        
        # Links section
        links_frame = ctk.CTkFrame(
            content_frame,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        links_frame.grid(row=3, column=0, sticky="ew")
        
        # Configure links grid
        links_frame.grid_columnconfigure((0, 1, 2), weight=1)
        
        # Website button
        website_btn = ctk.CTkButton(
            links_frame,
            text="Visit Website",
            command=lambda: webbrowser.open("https://dragonvoice.ai"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        website_btn.grid(row=0, column=0, padx=10, pady=15)
        
        # Documentation button
        docs_btn = ctk.CTkButton(
            links_frame,
            text="Documentation",
            command=lambda: webbrowser.open("https://docs.dragonvoice.ai"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        docs_btn.grid(row=0, column=1, padx=10, pady=15)
        
        # GitHub button
        github_btn = ctk.CTkButton(
            links_frame,
            text="GitHub Repository",
            command=lambda: webbrowser.open("https://github.com/dragonvoice/dragonvoice"),
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"]
        )
        github_btn.grid(row=0, column=2, padx=10, pady=15)

    def toggle_theme(self):
        """Toggle between light and dark themes"""
        try:
            # Get current appearance mode
            current_mode = ctk.get_appearance_mode()

            # Toggle mode
            new_mode = "Light" if current_mode == "Dark" else "Dark"
            ctk.set_appearance_mode(new_mode)

            # Update status
            self.update_status(f"Theme changed to {new_mode} mode")

        except Exception as e:
            logging.error(f"Error toggling theme: {str(e)}")
            self.update_status(f"Failed to toggle theme: {str(e)}", "error")

    def start_system_monitoring(self):
        """Start monitoring system resources"""
        try:
            # Initialize status variables if they don't exist
            if not hasattr(self, 'cpu_usage'):
                self.cpu_usage = 0
            if not hasattr(self, 'memory_usage'):
                self.memory_usage = 0
            if not hasattr(self, 'disk_usage'):
                self.disk_usage = 0
            if not hasattr(self, 'voice_status'):
                self.voice_status = "Idle"

            def update_system_info():
                try:
                    # Update CPU usage
                    self.cpu_usage = psutil.cpu_percent(interval=None)

                    # Update memory usage
                    memory = psutil.virtual_memory()
                    self.memory_usage = memory.percent

                    # Update disk usage
                    disk = psutil.disk_usage('/')
                    self.disk_usage = disk.percent

                    # Update status indicators if they exist
                    for i, (value, color) in enumerate([
                        (self.cpu_usage, self.get_resource_color(self.cpu_usage)),
                        (self.memory_usage, self.get_resource_color(self.memory_usage)),
                        (self.disk_usage, self.get_resource_color(self.disk_usage))
                    ]):
                        status_indicator = getattr(self, f'status_indicator_{i}', None)
                        status_value = getattr(self, f'status_value_{i}', None)
                        if status_indicator and status_value:
                            status_indicator.configure(fg_color=color)
                            status_value.configure(
                                text=f"{value:.1f}%",
                                text_color=self.colors["text_bright"]
                            )

                    # Update voice status
                    if hasattr(self, 'recording_active'):
                        voice_status = "Recording" if self.recording_active else "Idle"
                        status_color = self.colors["status_green"] if self.recording_active else self.colors["status_gray"]
                        
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=status_color)
                        if hasattr(self, 'status_value_3'):
                            self.status_value_3.configure(
                                text=voice_status,
                                text_color=self.colors["text_bright"]
                            )

                    # Schedule next update
                    self.app.after(1000, update_system_info)

                except Exception as e:
                    logging.error(f"Error updating system info: {str(e)}")
                    # Try again later
                    self.app.after(5000, update_system_info)

            # Start the update loop
            update_system_info()

        except Exception as e:
            logging.error(f"Error starting system monitoring: {str(e)}")

    def get_resource_color(self, value):
        """Get color based on resource usage percentage"""
        if value < 60:
            return self.colors["status_green"]  # Green for normal
        elif value < 80:
            return self.colors["status_yellow"]  # Yellow for warning
        else:
            return self.colors["status_red"]  # Red for critical

    def filter_chatbot_list(self):
        """Filter the chatbot list based on search text"""
        search_text = self.search_var.get().lower()

        # Clear existing items
        for widget in self.chatbot_list_frame.winfo_children():
            widget.destroy()

        # Add filtered chatbots
        for name, config in self.config.get("chatbots", {}).items():
            if search_text in name.lower():
                self.add_chatbot_list_item(name, config)

    def show_chatbot_settings(self, name, config):
        """Show settings for the selected chatbot"""
        # Update header
        self.selected_chatbot_label.configure(text=f"Settings: {name}")

        # Clear existing settings
        for widget in self.settings_content.winfo_children():
            widget.destroy()

        # Create settings sections
        sections = [
            ("General Settings", self.create_general_settings),
            ("API Configuration", self.create_api_settings),
            ("Model Settings", self.create_model_settings),
            ("Response Settings", self.create_response_settings),
            ("Advanced Options", self.create_advanced_settings)
        ]

        for title, create_func in sections:
            section = create_func(self.settings_content, name, config)
            section.pack(fill="x", padx=10, pady=5)

    def create_general_settings(self, parent, name, config):
        """Create general settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="General Settings",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # Display name
        name_frame = ctk.CTkFrame(frame, fg_color="transparent")
        name_frame.pack(fill="x", padx=15, pady=5)

        name_label = ctk.CTkLabel(
            name_frame,
            text="Display Name:",
            width=120,
            anchor="w"
        )
        name_label.pack(side="left")

        name_entry = ctk.CTkEntry(
            name_frame,
            width=200,
            placeholder_text="Enter display name"
        )
        name_entry.insert(0, name)
        name_entry.pack(side="left", padx=10)

        # Icon selection
        icon_frame = ctk.CTkFrame(frame, fg_color="transparent")
        icon_frame.pack(fill="x", padx=15, pady=5)

        icon_label = ctk.CTkLabel(
            icon_frame,
            text="Icon:",
            width=120,
            anchor="w"
        )
        icon_label.pack(side="left")

        icons = ["ü§ñ", "üß†", "üí°", "üîç", "üí¨", "üåê", "üìö", "‚ö°"]
        icon_var = ctk.StringVar(value=config.get("icon", "ü§ñ"))

        for icon in icons:
            btn = ctk.CTkButton(
                icon_frame,
                text=icon,
                width=40,
                height=40,
                corner_radius=20,
                fg_color=self.colors["bg_medium"] if icon != icon_var.get() else self.colors["accent_primary"],
                hover_color=self.colors["accent_secondary"],
                command=lambda i=icon: [
                    icon_var.set(i),
                    self.update_chatbot_config(
                        name,
                        "icon",
                        i)])
            btn.pack(side="left", padx=2)

        return frame

    def create_api_settings(self, parent, name, config):
        """Create API settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="API Configuration",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # API Key
        key_frame = ctk.CTkFrame(frame, fg_color="transparent")
        key_frame.pack(fill="x", padx=15, pady=5)

        key_label = ctk.CTkLabel(
            key_frame,
            text="API Key:",
            width=120,
            anchor="w"
        )
        key_label.pack(side="left")

        key_entry = ctk.CTkEntry(
            key_frame,
            width=300,
            placeholder_text="Enter API key",
            show="*"
        )
        key_entry.insert(0, config.get("api_key", ""))
        key_entry.pack(side="left", padx=10)

        show_key = ctk.CTkButton(
            key_frame, text="üëÅÔ∏è", width=40, command=lambda: key_entry.configure(
                show="" if key_entry.cget("show") == "*" else "*"))
        show_key.pack(side="left")

        # API Endpoint
        endpoint_frame = ctk.CTkFrame(frame, fg_color="transparent")
        endpoint_frame.pack(fill="x", padx=15, pady=5)

        endpoint_label = ctk.CTkLabel(
            endpoint_frame,
            text="API Endpoint:",
            width=120,
            anchor="w"
        )
        endpoint_label.pack(side="left")

        endpoint_entry = ctk.CTkEntry(
            endpoint_frame,
            width=300,
            placeholder_text="Enter API endpoint"
        )
        endpoint_entry.insert(0, config.get("endpoint", ""))
        endpoint_entry.pack(side="left", padx=10)

        # Test connection button
        test_button = ctk.CTkButton(
            frame,
            text="Test Connection",
            command=lambda: self.test_chatbot_connection(name),
            fg_color=self.colors["accent_secondary"]
        )
        test_button.pack(anchor="e", padx=15, pady=10)

        return frame

    def create_model_settings(self, parent, name, config):
        """Create model settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="Model Settings",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # Model selection
        model_frame = ctk.CTkFrame(frame, fg_color="transparent")
        model_frame.pack(fill="x", padx=15, pady=5)

        model_label = ctk.CTkLabel(
            model_frame,
            text="Model:",
            width=120,
            anchor="w"
        )
        model_label.pack(side="left")

        models = {
            "GPT": ["gpt-4", "gpt-3.5-turbo", "gpt-3.5-turbo-16k"],
            "Claude": ["claude-2", "claude-instant"],
            "Gemini": ["gemini-pro", "gemini-pro-vision"],
            "Custom": ["custom-model"]
        }

        model_type = config.get("type", "GPT")
        model_var = ctk.StringVar(
            value=config.get(
                "model", models[model_type][0]))

        model_combo = ctk.CTkComboBox(
            model_frame,
            width=200,
            values=models[model_type],
            variable=model_var,
            state="readonly"
        )
        model_combo.pack(side="left", padx=10)

        # Temperature
        temp_frame = ctk.CTkFrame(frame, fg_color="transparent")
        temp_frame.pack(fill="x", padx=15, pady=5)

        temp_label = ctk.CTkLabel(
            temp_frame,
            text="Temperature:",
            width=120,
            anchor="w"
        )
        temp_label.pack(side="left")

        temp_var = ctk.DoubleVar(value=config.get("temperature", 0.7))
        temp_slider = ctk.CTkSlider(
            temp_frame,
            from_=0.0,
            to=2.0,
            variable=temp_var,
            width=200
        )
        temp_slider.pack(side="left", padx=10)

        temp_value = ctk.CTkLabel(
            temp_frame,
            textvariable=temp_var,
            width=50
        )
        temp_value.pack(side="left")

        return frame

    def create_response_settings(self, parent, name, config):
        """Create response settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="Response Settings",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # Max tokens
        tokens_frame = ctk.CTkFrame(frame, fg_color="transparent")
        tokens_frame.pack(fill="x", padx=15, pady=5)

        tokens_label = ctk.CTkLabel(
            tokens_frame,
            text="Max Tokens:",
            width=120,
            anchor="w"
        )
        tokens_label.pack(side="left")

        tokens_var = ctk.IntVar(value=config.get("max_tokens", 2000))
        tokens_slider = ctk.CTkSlider(
            tokens_frame,
            from_=100,
            to=4000,
            variable=tokens_var,
            width=200
        )
        tokens_slider.pack(side="left", padx=10)

        tokens_value = ctk.CTkLabel(
            tokens_frame,
            textvariable=tokens_var,
            width=50
        )
        tokens_value.pack(side="left")

        # Response format
        format_frame = ctk.CTkFrame(frame, fg_color="transparent")
        format_frame.pack(fill="x", padx=15, pady=5)

        format_label = ctk.CTkLabel(
            format_frame,
            text="Format:",
            width=120,
            anchor="w"
        )
        format_label.pack(side="left")

        format_var = ctk.StringVar(value=config.get("format", "markdown"))
        formats = ["markdown", "html", "plain"]

        format_combo = ctk.CTkComboBox(
            format_frame,
            width=200,
            values=formats,
            variable=format_var,
            state="readonly"
        )
        format_combo.pack(side="left", padx=10)

        return frame

    def create_advanced_settings(self, parent, name, config):
        """Create advanced settings section"""
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_dark"],
            corner_radius=10
        )

        # Section title
        title = ctk.CTkLabel(
            frame,
            text="Advanced Options",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title.pack(anchor="w", padx=15, pady=(10, 5))

        # System prompt
        prompt_label = ctk.CTkLabel(
            frame,
            text="System Prompt:",
            anchor="w"
        )
        prompt_label.pack(anchor="w", padx=15, pady=(5, 0))

        prompt_text = ctk.CTkTextbox(
            frame,
            height=100,
            wrap="word"
        )
        prompt_text.pack(fill="x", padx=15, pady=5)
        prompt_text.insert("1.0", config.get("system_prompt", ""))

        # Checkboxes
        options_frame = ctk.CTkFrame(frame, fg_color="transparent")
        options_frame.pack(fill="x", padx=15, pady=5)

        stream_var = ctk.BooleanVar(value=config.get("stream", True))
        stream_cb = ctk.CTkCheckBox(
            options_frame,
            text="Stream responses",
            variable=stream_var
        )
        stream_cb.pack(anchor="w")

        history_var = ctk.BooleanVar(value=config.get("keep_history", True))
        history_cb = ctk.CTkCheckBox(
            options_frame,
            text="Keep conversation history",
            variable=history_var
        )
        history_cb.pack(anchor="w", pady=5)

        # Action buttons
        buttons_frame = ctk.CTkFrame(frame, fg_color="transparent")
        buttons_frame.pack(fill="x", padx=15, pady=10)

        save_button = ctk.CTkButton(
            buttons_frame,
            text="Save Changes",
            command=lambda: self.save_chatbot_settings(name),
            fg_color=self.colors["accent_primary"]
        )
        save_button.pack(side="left", padx=5)

        delete_button = ctk.CTkButton(
            buttons_frame,
            text="Delete Chatbot",
            command=lambda: self.delete_chatbot(name),
            fg_color=self.colors["error"]
        )
        delete_button.pack(side="right", padx=5)

        return frame

    def refresh_chatbots(self):
        """Refresh the chatbot cards and status in the dashboard"""
        # Update the chatbot list in the dedicated chatbots tab if it exists
        if hasattr(
                self,
                'chatbot_list_frame') and self.chatbot_list_frame.winfo_exists():
            self.refresh_chatbot_list()

        # Update status
        self.update_status("Chatbots refreshed", "info")

        # Refresh the monitor visualization
        if hasattr(self, 'monitor_canvas'):
            self.refresh_monitor_visualization()

        return True

    def load_config(self) -> dict:
        """Load the configuration from the JSON file"""
        try:
            with open(self.config_path, "r") as f:
                config = json.load(f)
                logging.info("Configuration loaded successfully")
                return config
        except FileNotFoundError:
            logging.error(f"Configuration file not found: {self.config_path}")
            return {}
        except json.JSONDecodeError:
            logging.error(
                f"Invalid JSON in configuration file: {self.config_path}")
            return {}

    def toggle_voice_assistant(self):
        """Toggle the voice assistant on/off"""
        # Check if we're in recording mode
        if hasattr(self, 'recording_active') and self.recording_active:
            # Update button text and color
            if hasattr(self, 'toggle_button'):
                self.toggle_button.configure(
                    text="Start Voice Assistant",
                    fg_color=self.colors["status_green"],  # Green when off
                    hover_color=self._adjust_color_brightness(self.colors["status_green"], 0.8),
                    border_color=self._adjust_color_brightness(self.colors["status_green"], 1.2)
                )

            # Stop recording and transcribe
            if self.stop_manual_recording():
                # Transcribe the recording
                self.transcribe_last_recording()
                # Disable continuous recording
                self.continuous_recording = False

            # Update status indicator
            if hasattr(self, 'status_indicator'):
                self.status_indicator.configure(
                    fg_color=self.colors["status_gray"])
        else:
            # Update button text and color
            if hasattr(self, 'toggle_button'):
                self.toggle_button.configure(
                    text="Stop Voice Assistant",
                    fg_color=self.colors["status_red"],  # Red when on
                    hover_color=self._adjust_color_brightness(self.colors["status_red"], 0.8),
                    border_color=self._adjust_color_brightness(self.colors["status_red"], 1.2)
                )

            # Start recording
            success = self.start_manual_recording()
            if success:
                # Enable continuous recording
                self.continuous_recording = True

                # Update status indicator
                if hasattr(self, 'status_indicator'):
                    self.status_indicator.configure(
                        fg_color=self.colors["status_green"])

                if hasattr(self, 'text_display'):
                    # Update the text display to show that voice assistant is
                    # active
                    self.text_display.configure(state="normal")
                    timestamp = datetime.now().strftime("%H:%M:%S")

                    # Add system message with formatting
                    system_pos = self.text_display.index("end-1c")
                    self.text_display.insert(
                        "end", f"[{timestamp}] Voice Assistant activated. Speak now...\n\n")
                    self.text_display._textbox.tag_add(
                        "system", system_pos, self.text_display.index("end-2c"))

                    self.text_display.see("end")
                    self.text_display.configure(state="disabled")
                    # Update status
                    self.update_status(
                        "Voice Assistant activated. Speak now...",
                        log_level="info")

    def start_manual_recording(self):
        """Start manual recording"""
        if not hasattr(self, 'whisper_recognizer') or self.whisper_recognizer is None:
            self.update_status("Whisper recognizer not initialized", log_level="error")
            return False

        try:
            # Get the selected microphone device if available
            device_id = None
            if hasattr(self, 'mic_device_var') and self.mic_device_var.get() != "Default":
                # Extract device ID from the selection string
                device_str = self.mic_device_var.get()
                if ":" in device_str:
                    device_id = int(device_str.split(":")[0].strip())
            
            # Log the device being used
            logging.info(f"Started recording audio with device_id: {device_id}")
            
            # Start recording with the selected device
            self.whisper_recognizer.start_recording(device=device_id)
            self.recording_active = True

            # Start level meter animation
            self.animate_level_meter()

            # Update UI
            if hasattr(self, 'toggle_button'):
                self.toggle_button.configure(
                    text="Stop Voice Assistant",
                    fg_color=self.colors["status_red"],
                    hover_color=self._adjust_color_brightness(self.colors["status_red"], 0.8),
                    border_color=self._adjust_color_brightness(self.colors["status_red"], 1.2)
                )
                
            # Update record/stop buttons
            if hasattr(self, 'record_button'):
                self.record_button.configure(state="disabled")
                
            if hasattr(self, 'stop_record_button'):
                self.stop_record_button.configure(state="normal")
                
            # Update status
            self.update_status("Voice Assistant activated. Speak now...", log_level="info")
            return True
        except Exception as e:
            self.update_status(f"Failed to start recording: {str(e)}", log_level="error")
            return False

    def stop_manual_recording(self):
        """Stop recording audio manually"""
        if not hasattr(self, 'whisper_recognizer'):
            self.update_status(
                "Whisper recognizer not initialized",
                log_level="error")
            return False

        try:
            # Stop recording
            success = self.whisper_recognizer.stop_recording()
            if success:
                self.update_status("Recording stopped", log_level="info")
                # Update UI to show stopped state
                self.toggle_button.configure(
                    text="Start Voice Assistant",
                    fg_color=self.colors["status_green"],  # Green when off
                    hover_color=self._adjust_color_brightness(self.colors["status_green"], 0.8),
                    border_color=self._adjust_color_brightness(self.colors["status_green"], 1.2)
                )
                
                # Update record/stop buttons
                if hasattr(self, 'record_button'):
                    self.record_button.configure(state="normal")
                    
                if hasattr(self, 'stop_record_button'):
                    self.stop_record_button.configure(state="disabled")
                
                # Enable transcribe button after recording
                if hasattr(self, 'transcribe_button'):
                    self.transcribe_button.configure(state="normal")
                # Stop level meter animation
                self.recording_active = False

                # Update text display to show that voice assistant is stopped
                if hasattr(self, 'text_display'):
                    self.text_display.configure(state="normal")
                    timestamp = datetime.now().strftime("%H:%M:%S")

                    # Add system message with formatting
                    system_pos = self.text_display.index("end-1c")
                    self.text_display.insert(
                        "end", f"[{timestamp}] Voice Assistant stopped.\n\n")
                    self.text_display._textbox.tag_add(
                        "system", system_pos, self.text_display.index("end-2c"))

                    self.text_display.see("end")
                    self.text_display.configure(state="disabled")

                return True
            else:
                self.update_status("No recording to stop", log_level="warning")
                return False
        except Exception as e:
            self.update_status(
                f"Error stopping recording: {str(e)}",
                log_level="error")
            return False

    def transcribe_last_recording(self):
        """Transcribe the last recording"""
        if not hasattr(self, 'whisper_recognizer'):
            self.update_status(
                "Whisper recognizer not initialized",
                log_level="error")
            return None

        try:
            # Save audio to file
            audio_file = self.whisper_recognizer.save_audio_to_file()
            if not audio_file:
                self.update_status(
                    "No audio data to transcribe",
                    log_level="warning")
                return None

            # Transcribe audio
            self.update_status("Transcribing audio...", log_level="info")
            transcript = self.whisper_recognizer.transcribe_audio(
                audio_file,
                language="en",
                response_format="verbose_json"
            )

            if transcript:
                self.update_status(
                    f"Transcription successful: {transcript.text[:50]}...",
                    log_level="info")
                # Add to history
                timestamp = datetime.now().strftime("%H:%M:%S")
                self.add_history_item(transcript.text, timestamp, "Success")

                # Update the text display window with the voice command
                if hasattr(self, 'text_display'):
                    self.text_display.configure(state="normal")
                    # Add timestamp and text with formatting
                    timestamp_pos = self.text_display.index("end-1c")
                    self.text_display.insert("end", f"[{timestamp}] ")
                    self.text_display._textbox.tag_add(
                        "timestamp", timestamp_pos, self.text_display.index("end-1c"))

                    command_pos = self.text_display.index("end-1c")
                    self.text_display.insert("end", f"{transcript.text}\n\n")
                    self.text_display._textbox.tag_add(
                        "command", command_pos, self.text_display.index("end-2c"))

                    # Auto-scroll to the bottom
                    self.text_display.see("end")
                    self.text_display.configure(state="disabled")
                
                # Update the transcription display with the transcribed text
                if hasattr(self, 'transcription_display'):
                    self.transcription_display.configure(state="normal")
                    self.transcription_display.delete(1.0, "end")  # Clear previous content
                    self.transcription_display.insert("end", transcript.text)
                    self.transcription_display.configure(state="disabled")
                    
                    # Enable the Enter button
                    if hasattr(self, 'enter_button'):
                        self.enter_button.configure(state="normal")
                    
                    # Store the current transcription for processing
                    self.current_transcription = transcript.text

                    # Automatically start recording again for continuous voice command recognition
                    # Use a flag to control continuous recording
                    if hasattr(
                            self,
                            'continuous_recording') and self.continuous_recording:
                        self.app.after(1000, self.start_manual_recording)

                # Disable transcribe button after successful transcription
                if hasattr(self, 'transcribe_button'):
                    self.transcribe_button.configure(state="disabled")
                return transcript.text
            else:
                self.update_status("Transcription failed", log_level="error")
                return None

        except Exception as e:
            self.update_status(
                f"Transcription error: {str(e)}",
                log_level="error")
            return None
            
    def process_transcription(self):
        """Process the transcribed text and send it to the selected chatbot"""
        if not hasattr(self, 'current_transcription') or not self.current_transcription:
            self.update_status("No transcription to process", log_level="warning")
            return
            
        try:
            # Get the transcribed text
            transcribed_text = self.current_transcription
            
            # Log the action
            self.update_status(f"Processing transcription: {transcribed_text[:30]}...", log_level="info")
            
            # Here you would implement the logic to send the text to the selected chatbot
            # This could involve simulating keyboard input or using an API
            # For now, we'll just show a success message
            
            # Update status
            self.update_status("Transcription sent to chatbot", log_level="info")
            
            # Add to the text display as a system message
            if hasattr(self, 'text_display'):
                self.text_display.configure(state="normal")
                timestamp = datetime.now().strftime("%H:%M:%S")
                
                # Add system message with formatting
                system_pos = self.text_display.index("end-1c")
                self.text_display.insert(
                    "end", f"[{timestamp}] Sent to chatbot: {transcribed_text[:30]}...\n\n")
                self.text_display._textbox.tag_add(
                    "system", system_pos, self.text_display.index("end-2c"))
                
                self.text_display.see("end")
                self.text_display.configure(state="disabled")
            
            # Clear the transcription display and disable the Enter button
            if hasattr(self, 'transcription_display'):
                self.transcription_display.configure(state="normal")
                self.transcription_display.delete(1.0, "end")
                self.transcription_display.configure(state="disabled")
                
            if hasattr(self, 'enter_button'):
                self.enter_button.configure(state="disabled")
                
            # Clear the current transcription
            self.current_transcription = None
            
        except Exception as e:
            self.update_status(f"Error processing transcription: {str(e)}", log_level="error")

    def animate_level_meter(self):
        """Animate the microphone level meter during recording"""
        if not hasattr(self, 'recording_active') or not self.recording_active:
            # Even when not recording, update with zero level to show the meter
            if hasattr(self, 'synth_bar'):
                self.synth_bar.update(0)
            return

        try:
            # Get the latest audio data if available
            if hasattr(self, 'whisper_recognizer') and self.whisper_recognizer.audio_data:
                latest_chunk = self.whisper_recognizer.audio_data[-1]
                
                # Calculate volume (RMS)
                volume = np.sqrt(np.mean(latest_chunk**2))
                
                # Apply sensitivity/gain from the slider
                if hasattr(self, 'sensitivity_var'):
                    # Apply a logarithmic scaling for more natural sensitivity control
                    sensitivity = self.sensitivity_var.get()
                    volume = volume * (np.exp(sensitivity * 2) - 1)
                
                # Add noise floor threshold to filter out background noise
                noise_floor = 0.01  # Adjust this value based on testing
                if volume < noise_floor:
                    volume = 0
                
                # Scale for visualization (0-100) with more moderate scaling
                volume = min(100, volume * 150)  # Reduced from 300 to 150

                # Update the level meter
                if hasattr(self, 'synth_bar'):
                    self.synth_bar.update(volume)
                
                # Update voice status indicator
                if hasattr(self, 'status_value_3'):
                    if volume > 70:  # High volume
                        self.status_value_3.configure(text="Speaking")
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=self.colors["status_red"])
                    elif volume > 30:  # Medium volume
                        self.status_value_3.configure(text="Active")
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=self.colors["status_yellow"])
                    else:  # Low/no volume
                        self.status_value_3.configure(text="Listening")
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=self.colors["status_green"])
            else:
                # If no audio data, show no activity
                if hasattr(self, 'synth_bar'):
                    self.synth_bar.update(0)
            
            # Continue animation if recording is still active
            if self.recording_active:
                self.app.after(50, self.animate_level_meter)  # Faster updates for smoother animation
                
        except Exception as e:
            logging.error(f"Error in level meter animation: {str(e)}")
            # Try to continue animation despite error
            if hasattr(self, 'recording_active') and self.recording_active:
                self.app.after(100, self.animate_level_meter)

    def refresh_monitor_visualization(self):
        """Update the system monitor visualization"""
        try:
            # Check if monitor_canvas exists
            if not hasattr(self, 'monitor_canvas'):
                logging.warning("monitor_canvas not initialized yet")
                return

            # Clear previous visualization
            self.monitor_canvas.delete("all")

            # Get system metrics
            import psutil
            cpu_percent = psutil.cpu_percent()
            memory_percent = psutil.virtual_memory().percent
            disk_percent = psutil.disk_usage('/').percent

            # Canvas dimensions
            width = self.monitor_canvas.winfo_width()
            height = self.monitor_canvas.winfo_height()

            # Ensure we have valid dimensions
            if width <= 1 or height <= 1:
                # Canvas not properly sized yet, schedule another update
                self.app.after(1000, self.refresh_monitor_visualization)
                return

            # Bar width and spacing
            bar_width = width / 4
            spacing = width / 12

            # Draw CPU bar
            cpu_color = self.get_resource_color(cpu_percent)
            cpu_height = (cpu_percent / 100) * height
            self.monitor_canvas.create_rectangle(
                spacing, height - cpu_height,
                spacing + bar_width, height,
                fill=cpu_color, outline=""
            )
            self.monitor_canvas.create_text(
                spacing + bar_width / 2, height - cpu_height - 15,
                text=f"CPU\n{cpu_percent}%",
                fill=self.colors["text_bright"],
                font=("Helvetica", 10, "bold"),
                justify="center"
            )

            # Draw Memory bar
            mem_color = self.get_resource_color(memory_percent)
            mem_height = (memory_percent / 100) * height
            self.monitor_canvas.create_rectangle(
                spacing * 2 + bar_width, height - mem_height,
                spacing * 2 + bar_width * 2, height,
                fill=mem_color, outline=""
            )
            self.monitor_canvas.create_text(
                spacing * 2 + bar_width * 1.5, height - mem_height - 15,
                text=f"RAM\n{memory_percent}%",
                fill=self.colors["text_bright"],
                font=("Helvetica", 10, "bold"),
                justify="center"
            )

            # Draw Disk bar
            disk_color = self.get_resource_color(disk_percent)
            disk_height = (disk_percent / 100) * height
            self.monitor_canvas.create_rectangle(
                spacing * 3 + bar_width * 2, height - disk_height,
                spacing * 3 + bar_width * 3, height,
                fill=disk_color, outline=""
            )
            self.monitor_canvas.create_text(
                spacing * 3 + bar_width * 2.5, height - disk_height - 15,
                text=f"Disk\n{disk_percent}%",
                fill=self.colors["text_bright"],
                font=("Helvetica", 10, "bold"),
                justify="center"
            )

            # Schedule next update
            self.app.after(2000, self.refresh_monitor_visualization)

        except Exception as e:
            logging.error(f"Error updating monitor visualization: {str(e)}")
            # Try again later
            self.app.after(5000, self.refresh_monitor_visualization)

    def update_status(self, message, log_level="info"):
        """Update the status message in the footer"""
        try:
            # Log the message with appropriate level
            if log_level == "info":
                logging.info(message)
            elif log_level == "warning":
                logging.warning(message)
            elif log_level == "error":
                logging.error(message)

            # Check if status_label exists before updating
            if hasattr(self, 'status_label') and self.status_label is not None:
                self.status_label.configure(text=message)
            else:
                logging.warning(
                    "Status label not initialized yet, can't update status")

        except Exception as e:
            logging.error(f"Error updating status: {str(e)}")
            # Don't raise the exception to avoid crashing the app

    def _adjust_color_brightness(self, hex_color, factor):
        """Adjust the brightness of a hex color by a factor"""
        r, g, b = self.hex_to_rgb(hex_color)
        r = min(255, int(r * factor))
        g = min(255, int(g * factor))
        b = min(255, int(b * factor))
        return f'#{r:02x}{g:02x}{b:02x}'

    def toggle_fullscreen(self):
        """Toggle fullscreen mode for the application window"""
        try:
            # Track fullscreen state
            if not hasattr(self, 'is_fullscreen'):
                self.is_fullscreen = False

            # Toggle state
            self.is_fullscreen = not self.is_fullscreen

            # Apply the change
            self.app.attributes("-fullscreen", self.is_fullscreen)

            # Update status
            status = "Fullscreen mode enabled" if self.is_fullscreen else "Fullscreen mode disabled"
            self.update_status(status)

        except Exception as e:
            logging.error(f"Error toggling fullscreen: {str(e)}")
            self.update_status(
                f"Failed to toggle fullscreen: {str(e)}", "error")

    def create_settings_general_tab(self, parent):
        """Create the general settings tab content"""
        # Main container
        container = ctk.CTkFrame(parent, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)

        # Interface settings section
        interface_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        interface_frame.pack(fill="x", pady=(0, 15))

        # Section title
        interface_title = ctk.CTkLabel(
            interface_frame,
            text="Interface Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        interface_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Language setting
        language_frame = ctk.CTkFrame(interface_frame, fg_color="transparent")
        language_frame.pack(fill="x", padx=15, pady=5)

        language_label = ctk.CTkLabel(
            language_frame,
            text="Interface Language",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        language_label.pack(side="left")

        self.language_var = ctk.StringVar(value="English")
        language_dropdown = ctk.CTkOptionMenu(
            language_frame,
            values=[
                "English",
                "Spanish",
                "French",
                "German",
                "Chinese",
                "Japanese"],
            variable=self.language_var,
            width=200)
        language_dropdown.pack(side="left", padx=10)

        # Startup settings section
        startup_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        startup_frame.pack(fill="x", pady=(0, 15))

        # Section title
        startup_title = ctk.CTkLabel(
            startup_frame,
            text="Startup Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        startup_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Auto-start setting
        autostart_frame = ctk.CTkFrame(startup_frame, fg_color="transparent")
        autostart_frame.pack(fill="x", padx=15, pady=5)

        autostart_label = ctk.CTkLabel(
            autostart_frame,
            text="Start with Windows",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        autostart_label.pack(side="left")

        self.autostart_var = ctk.BooleanVar(value=False)
        autostart_switch = ctk.CTkSwitch(
            autostart_frame,
            text="",
            variable=self.autostart_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        autostart_switch.pack(side="left", padx=10)

        # Start minimized setting
        minimized_frame = ctk.CTkFrame(startup_frame, fg_color="transparent")
        minimized_frame.pack(fill="x", padx=15, pady=5)

        minimized_label = ctk.CTkLabel(
            minimized_frame,
            text="Start Minimized",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        minimized_label.pack(side="left")

        self.minimized_var = ctk.BooleanVar(value=False)
        minimized_switch = ctk.CTkSwitch(
            minimized_frame,
            text="",
            variable=self.minimized_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        minimized_switch.pack(side="left", padx=10)

        # Auto-activate voice assistant
        autoactivate_frame = ctk.CTkFrame(
            startup_frame, fg_color="transparent")
        autoactivate_frame.pack(fill="x", padx=15, pady=5)

        autoactivate_label = ctk.CTkLabel(
            autoactivate_frame,
            text="Auto-activate Voice Assistant",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        autoactivate_label.pack(side="left")

        self.autoactivate_var = ctk.BooleanVar(value=False)
        autoactivate_switch = ctk.CTkSwitch(
            autoactivate_frame,
            text="",
            variable=self.autoactivate_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        autoactivate_switch.pack(side="left", padx=10)

        return container

    def create_settings_appearance_tab(self, parent):
        """Create the appearance settings tab content"""
        # Main container
        container = ctk.CTkFrame(parent, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)

        # Theme settings section
        theme_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        theme_frame.pack(fill="x", pady=(0, 15))

        # Section title
        theme_title = ctk.CTkLabel(
            theme_frame,
            text="Theme Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        theme_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Theme selection
        theme_selection_frame = ctk.CTkFrame(
            theme_frame, fg_color="transparent")
        theme_selection_frame.pack(fill="x", padx=15, pady=5)

        theme_label = ctk.CTkLabel(
            theme_selection_frame,
            text="Color Theme",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        theme_label.pack(side="left")

        self.theme_var = ctk.StringVar(value="medical")
        theme_dropdown = ctk.CTkOptionMenu(
            theme_selection_frame,
            values=["medical", "midnight", "cyberpunk"],
            variable=self.theme_var,
            width=200,
            command=self.apply_theme
        )
        theme_dropdown.pack(side="left", padx=10)

        # Appearance mode
        appearance_frame = ctk.CTkFrame(theme_frame, fg_color="transparent")
        appearance_frame.pack(fill="x", padx=15, pady=5)

        appearance_label = ctk.CTkLabel(
            appearance_frame,
            text="Appearance Mode",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        appearance_label.pack(side="left")

        self.appearance_var = ctk.StringVar(value="Dark")
        appearance_dropdown = ctk.CTkOptionMenu(
            appearance_frame,
            values=["Dark", "Light", "System"],
            variable=self.appearance_var,
            width=200,
            command=lambda value: ctk.set_appearance_mode(value)
        )
        appearance_dropdown.pack(side="left", padx=10)

        # Font settings section
        font_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        font_frame.pack(fill="x", pady=(0, 15))

        # Section title
        font_title = ctk.CTkLabel(
            font_frame,
            text="Font Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        font_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Font size
        font_size_frame = ctk.CTkFrame(font_frame, fg_color="transparent")
        font_size_frame.pack(fill="x", padx=15, pady=5)

        font_size_label = ctk.CTkLabel(
            font_size_frame,
            text="Font Size",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        font_size_label.pack(side="left")

        self.font_size_var = ctk.IntVar(value=12)
        font_size_slider = ctk.CTkSlider(
            font_size_frame,
            from_=8,
            to=16,
            number_of_steps=8,
            variable=self.font_size_var,
            width=200
        )
        font_size_slider.pack(side="left", padx=10)

        font_size_value = ctk.CTkLabel(
            font_size_frame,
            textvariable=self.font_size_var,
            width=30
        )
        font_size_value.pack(side="left", padx=5)

        # Preview section
        preview_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        preview_frame.pack(fill="x", pady=(0, 15))

        # Section title
        preview_title = ctk.CTkLabel(
            preview_frame,
            text="Theme Preview",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        preview_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Preview content
        preview_content = ctk.CTkFrame(
            preview_frame,
            fg_color=self.colors["bg_medium"],
            corner_radius=5,
            height=100
        )
        preview_content.pack(fill="x", padx=15, pady=(0, 15))
        preview_content.pack_propagate(False)

        preview_label = ctk.CTkLabel(
            preview_content,
            text="Sample Text",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"]
        )
        preview_label.pack(anchor="center", pady=10)

        preview_button = ctk.CTkButton(
            preview_content,
            text="Sample Button",
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            width=150
        )
        preview_button.pack(anchor="center")

        return container

    def create_settings_voice_tab(self, parent):
        """Create the voice settings tab content"""
        # Main container with gradient background
        container = ctk.CTkFrame(parent, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)

        # Microphone settings section
        mic_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        mic_frame.pack(fill="x", pady=(0, 15))

        # Section title
        mic_title = ctk.CTkLabel(
            mic_frame,
            text="Microphone Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        mic_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Microphone selection
        mic_selection_frame = ctk.CTkFrame(mic_frame, fg_color="transparent")
        mic_selection_frame.pack(fill="x", padx=15, pady=5)

        mic_label = ctk.CTkLabel(
            mic_selection_frame,
            text="Input Device",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        mic_label.pack(side="left")

        # Create a frame for the dropdown and refresh button
        mic_dropdown_frame = ctk.CTkFrame(
            mic_selection_frame, fg_color="transparent")
        mic_dropdown_frame.pack(side="left", fill="x", expand=True)

        # Microphone dropdown
        self.mic_var = ctk.StringVar(value="Default Microphone")
        self.mic_dropdown = ctk.CTkOptionMenu(
            mic_dropdown_frame,
            values=["Default Microphone"],
            variable=self.mic_var,
            width=200
        )
        self.mic_dropdown.pack(side="left", padx=(0, 10))

        # Refresh button
        refresh_button = ctk.CTkButton(
            mic_dropdown_frame,
            text="Refresh",
            command=self.refresh_mic_list,
            fg_color=self.colors["bg_medium"],
            hover_color=self.colors["bg_light"],
            width=80
        )
        refresh_button.pack(side="left")

        # Microphone level visualization
        level_frame = ctk.CTkFrame(mic_frame, fg_color="transparent")
        level_frame.pack(fill="x", padx=15, pady=5)

        level_label = ctk.CTkLabel(
            level_frame,
            text="Input Level",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        level_label.pack(side="left")

        # Level meter canvas
        self.level_canvas = ctk.CTkCanvas(
            level_frame,
            height=24,
            width=200,
            bg=self.colors["bg_dark"],
            highlightthickness=0
        )
        self.level_canvas.pack(side="left", padx=10)

        # Test microphone button
        test_button = ctk.CTkButton(
            level_frame,
            text="Test",
            command=self.test_microphone,
            fg_color=self.colors["accent_secondary"],
            hover_color=self.colors["accent_primary"],
            width=80
        )
        test_button.pack(side="left")

        # Advanced microphone settings
        advanced_frame = ctk.CTkFrame(
            container,
            fg_color=self.colors["bg_light"],
            corner_radius=10
        )
        advanced_frame.pack(fill="x", pady=(0, 15))

        # Section title
        advanced_title = ctk.CTkLabel(
            advanced_frame,
            text="Advanced Settings",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        advanced_title.pack(anchor="w", padx=15, pady=(15, 10))

        # Input gain
        gain_frame = ctk.CTkFrame(advanced_frame, fg_color="transparent")
        gain_frame.pack(fill="x", padx=15, pady=5)

        gain_label = ctk.CTkLabel(
            gain_frame,
            text="Input Gain",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        gain_label.pack(side="left")

        self.gain_var = ctk.DoubleVar(value=1.0)
        gain_slider = ctk.CTkSlider(
            gain_frame,
            from_=0.1,
            to=2.0,
            variable=self.gain_var,
            width=200
        )
        gain_slider.pack(side="left", padx=10)

        gain_value = ctk.CTkLabel(
            gain_frame,
            text=f"{self.gain_var.get():.1f}",
            width=30
        )
        gain_value.pack(side="left", padx=5)

        # Noise threshold
        threshold_frame = ctk.CTkFrame(advanced_frame, fg_color="transparent")
        threshold_frame.pack(fill="x", padx=15, pady=5)

        threshold_label = ctk.CTkLabel(
            threshold_frame,
            text="Noise Threshold",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        threshold_label.pack(side="left")

        self.threshold_var = ctk.DoubleVar(value=0.2)
        threshold_slider = ctk.CTkSlider(
            threshold_frame,
            from_=0.0,
            to=0.5,
            variable=self.threshold_var,
            width=200
        )
        threshold_slider.pack(side="left", padx=10)

        threshold_value = ctk.CTkLabel(
            threshold_frame,
            text=f"{self.threshold_var.get():.2f}",
            width=30
        )
        threshold_value.pack(side="left", padx=5)

        # Echo cancellation
        echo_frame = ctk.CTkFrame(advanced_frame, fg_color="transparent")
        echo_frame.pack(fill="x", padx=15, pady=5)

        echo_label = ctk.CTkLabel(
            echo_frame,
            text="Echo Cancellation",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        echo_label.pack(side="left")

        self.echo_var = ctk.BooleanVar(value=True)
        echo_switch = ctk.CTkSwitch(
            echo_frame,
            text="",
            variable=self.echo_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        echo_switch.pack(side="left", padx=10)

        # Noise reduction
        noise_frame = ctk.CTkFrame(advanced_frame, fg_color="transparent")
        noise_frame.pack(fill="x", padx=15, pady=5)

        noise_label = ctk.CTkLabel(
            noise_frame,
            text="Noise Reduction",
            font=ctk.CTkFont(size=14),
            text_color=self.colors["text_normal"],
            width=150,
            anchor="w"
        )
        noise_label.pack(side="left")

        self.noise_var = ctk.BooleanVar(value=True)
        noise_switch = ctk.CTkSwitch(
            noise_frame,
            text="",
            variable=self.noise_var,
            width=50,
            switch_width=50,
            switch_height=24,
            fg_color=self.colors["bg_medium"],
            progress_color=self.colors["accent_primary"]
        )
        noise_switch.pack(side="left", padx=10)

        # Initialize microphone list
        self.refresh_mic_list()

        return container

    def refresh_mic_list(self):
        """Refresh the list of available microphones."""
        try:
            devices = sd.query_devices()
            input_devices = []

            # Add a default option
            input_devices.append("Default Microphone")

            # Add all input devices with their IDs for easier identification
            for i, device in enumerate(devices):
                if device['max_input_channels'] > 0:
                    input_devices.append(f"{device['name']} (ID: {i})")

            # Update dropdown
            self.mic_dropdown.configure(values=input_devices)

            # Set default selection
            if input_devices:
                self.mic_var.set(input_devices[0])

            # Update status
            self.update_status(f"Found {len(input_devices)-1} input devices")

        except Exception as e:
            logging.error(f"Error refreshing microphone list: {str(e)}")
            self.update_status("Failed to refresh microphone list", "error")
            # Ensure at least the default option is available
            self.mic_dropdown.configure(values=["Default Microphone"])
            self.mic_var.set("Default Microphone")

    def test_microphone(self):
        """Test the selected microphone by recording and playing back audio."""
        try:
            device_str = self.mic_var.get()
            device_id = None

            # Extract device ID if it's not the default microphone
            if device_str != "Default Microphone":
                try:
                    device_id = int(device_str.split("ID: ")[1].strip(")"))
                    logging.info(f"Testing microphone with ID: {device_id}")
                except Exception as e:
                    logging.error(f"Error parsing device ID: {str(e)}")
                    device_id = None
                    logging.info("Using default microphone instead")

            # Create a modern dialog to show recording status
            dialog = ctk.CTkToplevel(self.app)
            dialog.title("Microphone Test")
            dialog.geometry("400x300")
            dialog.resizable(False, False)
            dialog.transient(self.app)
            dialog.grab_set()

            # Set dialog theme
            dialog.configure(fg_color=self.colors["bg_medium"])

            # Center the dialog
            dialog.update_idletasks()
            width = dialog.winfo_width()
            height = dialog.winfo_height()
            x = (dialog.winfo_screenwidth() // 2) - (width // 2)
            y = (dialog.winfo_screenheight() // 2) - (height // 2)
            dialog.geometry(f"{width}x{height}+{x}+{y}")

            # Title with icon
            title_frame = ctk.CTkFrame(dialog, fg_color="transparent")
            title_frame.pack(fill="x", padx=20, pady=(20, 10))

            title_label = ctk.CTkLabel(
                title_frame,
                text="Microphone Test",
                font=ctk.CTkFont(size=20, weight="bold"),
                text_color=self.colors["text_bright"]
            )
            title_label.pack(side="left")

            # Status label with modern styling
            status_frame = ctk.CTkFrame(
                dialog, fg_color=self.colors["bg_light"], corner_radius=10)
            status_frame.pack(fill="x", padx=20, pady=10)

            status_label = ctk.CTkLabel(
                status_frame,
                text="Initializing microphone test...",
                font=ctk.CTkFont(size=14),
                text_color=self.colors["text_bright"],
                wraplength=350
            )
            status_label.pack(pady=15, padx=15)

            # Progress bar with custom styling
            progress_frame = ctk.CTkFrame(dialog, fg_color="transparent")
            progress_frame.pack(fill="x", padx=20, pady=5)

            progress_label = ctk.CTkLabel(
                progress_frame,
                text="Progress:",
                font=ctk.CTkFont(size=12),
                text_color=self.colors["text_normal"]
            )
            progress_label.pack(anchor="w")

            progress = ctk.CTkProgressBar(
                progress_frame,
                width=360,
                height=15,
                corner_radius=5,
                fg_color=self.colors["bg_dark"],
                progress_color=self.colors["accent_primary"]
            )
            progress.pack(pady=5)
            progress.set(0)

            # Level meter with improved visualization
            level_frame = ctk.CTkFrame(dialog, fg_color="transparent")
            level_frame.pack(fill="x", padx=20, pady=5)

            level_label = ctk.CTkLabel(
                level_frame,
                text="Audio Level:",
                font=ctk.CTkFont(size=12),
                text_color=self.colors["text_normal"]
            )
            level_label.pack(anchor="w")

            meter_bg = ctk.CTkFrame(
                level_frame,
                fg_color=self.colors["bg_dark"],
                height=30,
                width=360,
                corner_radius=5
            )
            meter_bg.pack(pady=5)

            level_indicator = ctk.CTkFrame(
                meter_bg,
                fg_color=self.colors["accent_primary"],
                height=30,
                width=1,
                corner_radius=5
            )
            level_indicator.place(x=0, y=0)

            level_text = ctk.CTkLabel(
                meter_bg,
                text="0%",
                font=ctk.CTkFont(size=12, weight="bold"),
                text_color=self.colors["text_bright"]
            )
            level_text.place(relx=0.5, rely=0.5, anchor="center")

            # Button frame
            button_frame = ctk.CTkFrame(dialog, fg_color="transparent")
            button_frame.pack(fill="x", padx=20, pady=(15, 20))

            # Cancel button
            cancel_button = ctk.CTkButton(
                button_frame,
                text="Cancel",
                command=dialog.destroy,
                fg_color=self.colors["bg_light"],
                hover_color=self.colors["bg_medium"],
                text_color=self.colors["text_normal"],
                width=100
            )
            cancel_button.pack(side="left", padx=(0, 10))

            # Close button (initially disabled)
            close_button = ctk.CTkButton(
                button_frame,
                text="Close",
                command=dialog.destroy,
                state="disabled",
                fg_color=self.colors["accent_primary"],
                hover_color=self.colors["accent_secondary"],
                width=100
            )
            close_button.pack(side="right")

            # Get device info
            try:
                device_info = sd.query_devices(device_id)
                samplerate = int(device_info['default_samplerate'])

                # Show device info in status
                status_label.configure(
                    text=f"Testing: {device_info['name']}\nPlease speak now to test your microphone.")
            except Exception as e:
                status_label.configure(
                    text=f"Error: {str(e)}\nCould not initialize the selected microphone.")
                close_button.configure(state="normal")
                return

            # Duration of recording
            duration = 5  # seconds

            # Function to update progress
            def update_progress(current, total):
                progress.set(current / total)
                progress_label.configure(
                    text=f"Progress: {int(current/total*100)}%")
                dialog.update()

            # Function to update level indicator
            def update_level(volume):
                # Scale volume (0-1) to width
                width = min(360, int(volume * 360))
                level_indicator.configure(width=width)

                # Update color based on level
                if volume < 0.3:
                    level_indicator.configure(
                        fg_color=self.colors["status_green"])
                elif volume < 0.7:
                    level_indicator.configure(
                        fg_color=self.colors["status_yellow"])
                else:
                    level_indicator.configure(
                        fg_color=self.colors["status_red"])

                # Update text
                level_text.configure(text=f"{int(volume * 100)}%")
                dialog.update()

            # Function to record audio
            def record_audio():
                status_label.configure(
                    text=f"Recording from: {device_info['name']}\nPlease speak now...")

                # Create array to store audio data
                audio_data = []

                # Start time
                start_time = time.time()

                # Callback function for audio stream
                def audio_callback(indata, frames, time_info, status):
                    if status:
                        logging.warning(f"Audio status: {status}")

                    # Copy audio data
                    audio_data.append(indata.copy())

                    # Calculate volume level (RMS)
                    volume = np.sqrt(np.mean(indata**2))

                    # Apply gain if available
                    if hasattr(self, 'gain_var'):
                        volume *= self.gain_var.get()

                    # Update level indicator
                    dialog.after(0, lambda: update_level(min(1.0, volume * 2)))

                    # Update progress
                    elapsed = time.time() - start_time
                    if elapsed < duration:
                        dialog.after(
                            0, lambda: update_progress(
                                elapsed, duration))

                # Start audio stream
                try:
                    with sd.InputStream(
                        device=device_id,
                        channels=1,
                        callback=audio_callback,
                        samplerate=samplerate,
                        blocksize=int(samplerate * 0.1)  # 100ms blocks
                    ):
                        # Wait for duration
                        sd.sleep(int(duration * 1000))
                except Exception as e:
                    error_msg = f"Error recording: {str(e)}"
                    logging.error(error_msg)
                    status_label.configure(text=error_msg)
                    close_button.configure(state="normal")
                    return None

                # Combine all audio chunks
                if audio_data:
                    return np.concatenate(audio_data)
                return None

            # Function to play audio
            def play_audio(audio_data):
                status_label.configure(text="Playing back recording...")
                progress.set(0)

                try:
                    # Start time
                    start_time = time.time()

                    # Play audio
                    sd.play(audio_data, samplerate)

                    # Update progress during playback
                    def update_playback_progress():
                        elapsed = time.time() - start_time
                        if elapsed < duration and not dialog.winfo_exists():
                            return

                        if elapsed < duration:
                            update_progress(elapsed, duration)
                            dialog.after(100, update_playback_progress)
                        else:
                            progress.set(1.0)
                            progress_label.configure(text="Progress: 100%")

                    # Start progress updates
                    update_playback_progress()

                    # Wait for playback to complete
                    sd.wait()

                    # Test completed
                    status_label.configure(
                        text="Test completed successfully!\n\nYour microphone is working properly.")
                    close_button.configure(state="normal")

                except Exception as e:
                    error_msg = f"Error playing back: {str(e)}"
                    logging.error(error_msg)
                    status_label.configure(text=error_msg)
                    close_button.configure(state="normal")

            # Run the recording in a separate thread
            def run_test():
                try:
                    # Record audio
                    audio_data = record_audio()

                    if audio_data is not None and len(audio_data) > 0:
                        # Play it back
                        play_audio(audio_data)
                    else:
                        status_label.configure(
                            text="No audio recorded or error occurred.\n\nPlease check if your microphone is properly connected and not muted.")
                        close_button.configure(state="normal")
                except Exception as e:
                    error_msg = f"Test failed: {str(e)}"
                    logging.error(error_msg)
                    status_label.configure(text=error_msg)
                    close_button.configure(state="normal")

            # Start the test in a separate thread
            threading.Thread(target=run_test, daemon=True).start()

        except Exception as e:
            error_msg = f"Failed to test microphone: {str(e)}"
            logging.error(error_msg)
            messagebox.showerror("Error", error_msg)
            self.update_status(f"Microphone test failed: {str(e)}", "error")

    def create_settings_chatbots_tab(self, parent):
        """Create the chatbots settings tab content"""
        # Main container
        container = ctk.CTkFrame(parent, fg_color="transparent")
        container.pack(fill="both", expand=True, padx=20, pady=20)

        # Title and add button row
        title_frame = ctk.CTkFrame(container, fg_color="transparent")
        title_frame.pack(fill="x", pady=(0, 15))

        # Title
        title_label = ctk.CTkLabel(
            title_frame,
            text="Manage Chatbots",
            font=ctk.CTkFont(size=20, weight="bold"),
            text_color=self.colors["text_bright"]
        )
        title_label.pack(side="left")

        # Add chatbot button
        add_button = ctk.CTkButton(
            title_frame,
            text="Add New Chatbot",
            command=self.show_add_chatbot_dialog,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            width=150
        )
        add_button.pack(side="right")

        return container

    def start_manual_recording(self):
        """Start manual recording"""
        if not hasattr(
                self,
                'whisper_recognizer') or self.whisper_recognizer is None:
            self.update_status(
                "Whisper recognizer not initialized",
                log_level="error")
            return False

        try:
            # Start recording
            self.whisper_recognizer.start_recording()
            self.recording_active = True

            # Start level meter animation
            self.animate_level_meter()

            # Update UI
            if hasattr(self, 'toggle_button'):
                self.toggle_button.configure(
                    text="Stop Voice Assistant",
                    fg_color=self.colors["status_red"],
                    hover_color=self._adjust_color_brightness(self.colors["status_red"], 0.8),
                    border_color=self._adjust_color_brightness(self.colors["status_red"], 1.2)
                )
                
            # Update record/stop buttons
            if hasattr(self, 'record_button'):
                self.record_button.configure(state="disabled")
                
            if hasattr(self, 'stop_record_button'):
                self.stop_record_button.configure(state="normal")
                
            # Update status
            self.update_status("Voice Assistant activated. Speak now...", log_level="info")
            return True
        except Exception as e:
            self.update_status(
                f"Failed to start recording: {str(e)}",
                log_level="error")
            return False

    def stop_manual_recording(self):
        """Stop recording audio manually"""
        if not hasattr(self, 'whisper_recognizer'):
            self.update_status(
                "Whisper recognizer not initialized",
                log_level="error")
            return False

        try:
            # Stop recording
            success = self.whisper_recognizer.stop_recording()
            if success:
                self.update_status("Recording stopped", log_level="info")
                # Update UI to show stopped state
                self.toggle_button.configure(
                    text="Start Voice Assistant",
                    fg_color=self.colors["status_green"],  # Green when off
                    hover_color=self._adjust_color_brightness(self.colors["status_green"], 0.8),
                    border_color=self._adjust_color_brightness(self.colors["status_green"], 1.2)
                )
                
                # Update record/stop buttons
                if hasattr(self, 'record_button'):
                    self.record_button.configure(state="normal")
                    
                if hasattr(self, 'stop_record_button'):
                    self.stop_record_button.configure(state="disabled")
                
                # Enable transcribe button after recording
                if hasattr(self, 'transcribe_button'):
                    self.transcribe_button.configure(state="normal")
                # Stop level meter animation
                self.recording_active = False

                # Update text display to show that voice assistant is stopped
                if hasattr(self, 'text_display'):
                    self.text_display.configure(state="normal")
                    timestamp = datetime.now().strftime("%H:%M:%S")

                    # Add system message with formatting
                    system_pos = self.text_display.index("end-1c")
                    self.text_display.insert(
                        "end", f"[{timestamp}] Voice Assistant stopped.\n\n")
                    self.text_display._textbox.tag_add(
                        "system", system_pos, self.text_display.index("end-2c"))

                    self.text_display.see("end")
                    self.text_display.configure(state="disabled")

                return True
            else:
                self.update_status("No recording to stop", log_level="warning")
                return False
        except Exception as e:
            self.update_status(
                f"Error stopping recording: {str(e)}",
                log_level="error")
            return False

    def transcribe_last_recording(self):
        """Transcribe the last recording"""
        if not hasattr(self, 'whisper_recognizer'):
            self.update_status(
                "Whisper recognizer not initialized",
                log_level="error")
            return None

        try:
            # Save audio to file
            audio_file = self.whisper_recognizer.save_audio_to_file()
            if not audio_file:
                self.update_status(
                    "No audio data to transcribe",
                    log_level="warning")
                return None

            # Transcribe audio
            self.update_status("Transcribing audio...", log_level="info")
            transcript = self.whisper_recognizer.transcribe_audio(
                audio_file,
                language="en",
                response_format="verbose_json"
            )

            if transcript:
                self.update_status(
                    f"Transcription successful: {transcript.text[:50]}...",
                    log_level="info")
                # Add to history
                timestamp = datetime.now().strftime("%H:%M:%S")
                self.add_history_item(transcript.text, timestamp, "Success")

                # Update the text display window with the voice command
                if hasattr(self, 'text_display'):
                    self.text_display.configure(state="normal")
                    # Add timestamp and text with formatting
                    timestamp_pos = self.text_display.index("end-1c")
                    self.text_display.insert("end", f"[{timestamp}] ")
                    self.text_display._textbox.tag_add(
                        "timestamp", timestamp_pos, self.text_display.index("end-1c"))

                    command_pos = self.text_display.index("end-1c")
                    self.text_display.insert("end", f"{transcript.text}\n\n")
                    self.text_display._textbox.tag_add(
                        "command", command_pos, self.text_display.index("end-2c"))

                    # Auto-scroll to the bottom
                    self.text_display.see("end")
                    self.text_display.configure(state="disabled")
                
                # Update the transcription display with the transcribed text
                if hasattr(self, 'transcription_display'):
                    self.transcription_display.configure(state="normal")
                    self.transcription_display.delete(1.0, "end")  # Clear previous content
                    self.transcription_display.insert("end", transcript.text)
                    self.transcription_display.configure(state="disabled")
                    
                    # Enable the Enter button
                    if hasattr(self, 'enter_button'):
                        self.enter_button.configure(state="normal")
                    
                    # Store the current transcription for processing
                    self.current_transcription = transcript.text

                    # Automatically start recording again for continuous voice command recognition
                    # Use a flag to control continuous recording
                    if hasattr(
                            self,
                            'continuous_recording') and self.continuous_recording:
                        self.app.after(1000, self.start_manual_recording)

                # Disable transcribe button after successful transcription
                if hasattr(self, 'transcribe_button'):
                    self.transcribe_button.configure(state="disabled")
                return transcript.text
            else:
                self.update_status("Transcription failed", log_level="error")
                return None

        except Exception as e:
            self.update_status(
                f"Transcription error: {str(e)}",
                log_level="error")
            return None
            
    def process_transcription(self):
        """Process the transcribed text and send it to the selected chatbot"""
        if not hasattr(self, 'current_transcription') or not self.current_transcription:
            self.update_status("No transcription to process", log_level="warning")
            return
            
        try:
            # Get the transcribed text
            transcribed_text = self.current_transcription
            
            # Log the action
            self.update_status(f"Processing transcription: {transcribed_text[:30]}...", log_level="info")
            
            # Here you would implement the logic to send the text to the selected chatbot
            # This could involve simulating keyboard input or using an API
            # For now, we'll just show a success message
            
            # Update status
            self.update_status("Transcription sent to chatbot", log_level="info")
            
            # Add to the text display as a system message
            if hasattr(self, 'text_display'):
                self.text_display.configure(state="normal")
                timestamp = datetime.now().strftime("%H:%M:%S")
                
                # Add system message with formatting
                system_pos = self.text_display.index("end-1c")
                self.text_display.insert(
                    "end", f"[{timestamp}] Sent to chatbot: {transcribed_text[:30]}...\n\n")
                self.text_display._textbox.tag_add(
                    "system", system_pos, self.text_display.index("end-2c"))
                
                self.text_display.see("end")
                self.text_display.configure(state="disabled")
            
            # Clear the transcription display and disable the Enter button
            if hasattr(self, 'transcription_display'):
                self.transcription_display.configure(state="normal")
                self.transcription_display.delete(1.0, "end")
                self.transcription_display.configure(state="disabled")
                
            if hasattr(self, 'enter_button'):
                self.enter_button.configure(state="disabled")
                
            # Clear the current transcription
            self.current_transcription = None
            
        except Exception as e:
            self.update_status(f"Error processing transcription: {str(e)}", log_level="error")

    def animate_level_meter(self):
        """Animate the microphone level meter during recording"""
        if not hasattr(self, 'recording_active') or not self.recording_active:
            # Even when not recording, update with zero level to show the meter
            if hasattr(self, 'synth_bar'):
                self.synth_bar.update(0)
            return

        try:
            # Get the latest audio data if available
            if hasattr(self, 'whisper_recognizer') and self.whisper_recognizer.audio_data:
                latest_chunk = self.whisper_recognizer.audio_data[-1]
                
                # Calculate volume (RMS)
                volume = np.sqrt(np.mean(latest_chunk**2))
                
                # Apply sensitivity/gain from the slider
                if hasattr(self, 'sensitivity_var'):
                    # Apply a logarithmic scaling for more natural sensitivity control
                    sensitivity = self.sensitivity_var.get()
                    volume = volume * (np.exp(sensitivity * 2) - 1)
                
                # Add noise floor threshold to filter out background noise
                noise_floor = 0.01  # Adjust this value based on testing
                if volume < noise_floor:
                    volume = 0
                
                # Scale for visualization (0-100) with more moderate scaling
                volume = min(100, volume * 150)  # Reduced from 300 to 150

                # Update the level meter
                if hasattr(self, 'synth_bar'):
                    self.synth_bar.update(volume)
                
                # Update voice status indicator
                if hasattr(self, 'status_value_3'):
                    if volume > 70:  # High volume
                        self.status_value_3.configure(text="Speaking")
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=self.colors["status_red"])
                    elif volume > 30:  # Medium volume
                        self.status_value_3.configure(text="Active")
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=self.colors["status_yellow"])
                    else:  # Low/no volume
                        self.status_value_3.configure(text="Listening")
                        if hasattr(self, 'status_indicator_3'):
                            self.status_indicator_3.configure(fg_color=self.colors["status_green"])
            else:
                # If no audio data, show no activity
                if hasattr(self, 'synth_bar'):
                    self.synth_bar.update(0)
            
            # Continue animation if recording is still active
            if self.recording_active:
                self.app.after(50, self.animate_level_meter)  # Faster updates for smoother animation
                
        except Exception as e:
            logging.error(f"Error in level meter animation: {str(e)}")
            # Try to continue animation despite error
            if hasattr(self, 'recording_active') and self.recording_active:
                self.app.after(100, self.animate_level_meter)

    def refresh_monitor_visualization(self):
        """Update the system monitor visualization"""
        try:
            # Check if monitor_canvas exists
            if not hasattr(self, 'monitor_canvas'):
                logging.warning("monitor_canvas not initialized yet")
                return

            # Clear previous visualization
            self.monitor_canvas.delete("all")

            # Get system metrics
            import psutil
            cpu_percent = psutil.cpu_percent()
            memory_percent = psutil.virtual_memory().percent
            disk_percent = psutil.disk_usage('/').percent

            # Canvas dimensions
            width = self.monitor_canvas.winfo_width()
            height = self.monitor_canvas.winfo_height()

            # Ensure we have valid dimensions
            if width <= 1 or height <= 1:
                # Canvas not properly sized yet, schedule another update
                self.app.after(1000, self.refresh_monitor_visualization)
                return

            # Bar width and spacing
            bar_width = width / 4
            spacing = width / 12

            # Draw CPU bar
            cpu_color = self.get_resource_color(cpu_percent)
            cpu_height = (cpu_percent / 100) * height
            self.monitor_canvas.create_rectangle(
                spacing, height - cpu_height,
                spacing + bar_width, height,
                fill=cpu_color, outline=""
            )
            self.monitor_canvas.create_text(
                spacing + bar_width / 2, height - cpu_height - 15,
                text=f"CPU\n{cpu_percent}%",
                fill=self.colors["text_bright"],
                font=("Helvetica", 10, "bold"),
                justify="center"
            )

            # Draw Memory bar
            mem_color = self.get_resource_color(memory_percent)
            mem_height = (memory_percent / 100) * height
            self.monitor_canvas.create_rectangle(
                spacing * 2 + bar_width, height - mem_height,
                spacing * 2 + bar_width * 2, height,
                fill=mem_color, outline=""
            )
            self.monitor_canvas.create_text(
                spacing * 2 + bar_width * 1.5, height - mem_height - 15,
                text=f"RAM\n{memory_percent}%",
                fill=self.colors["text_bright"],
                font=("Helvetica", 10, "bold"),
                justify="center"
            )

            # Draw Disk bar
            disk_color = self.get_resource_color(disk_percent)
            disk_height = (disk_percent / 100) * height
            self.monitor_canvas.create_rectangle(
                spacing * 3 + bar_width * 2, height - disk_height,
                spacing * 3 + bar_width * 3, height,
                fill=disk_color, outline=""
            )
            self.monitor_canvas.create_text(
                spacing * 3 + bar_width * 2.5, height - disk_height - 15,
                text=f"Disk\n{disk_percent}%",
                fill=self.colors["text_bright"],
                font=("Helvetica", 10, "bold"),
                justify="center"
            )

            # Schedule next update
            self.app.after(2000, self.refresh_monitor_visualization)

        except Exception as e:
            logging.error(f"Error updating monitor visualization: {str(e)}")
            # Try again later
            self.app.after(5000, self.refresh_monitor_visualization)

    def _update_level_meter(self, volume):
        """Update the level meter with the current volume"""
        if hasattr(self, 'level_meter'):
            # Scale volume to meter width
            meter_width = int((volume / 100) * self.level_meter_width)
            # Update meter fill
            self.level_meter.configure(width=meter_width)
            
            # Update color based on volume level
            if volume > 80:  # High volume
                self.level_meter.configure(fg_color=self.colors["status_red"])
            elif volume > 40:  # Medium volume
                self.level_meter.configure(fg_color=self.colors["status_yellow"])
            else:  # Low volume
                self.level_meter.configure(fg_color=self.colors["status_green"])

    def create_status_panel(self, parent):
        """Create a status panel with system information"""
        # Create panel frame
        status_panel = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_medium"],
            corner_radius=15,
            border_width=1,
            border_color=self.colors["bg_light"]
        )

        # Panel header
        status_header = ctk.CTkFrame(
            status_panel, fg_color="transparent", height=50)
        status_header.pack(fill="x", padx=20, pady=(15, 5))

        # Panel title
        status_title = ctk.CTkLabel(
            status_header,
            text="System Status",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        status_title.pack(side="left")

        # Status indicators grid
        status_grid = ctk.CTkFrame(status_panel, fg_color="transparent")
        status_grid.pack(fill="both", expand=True, padx=20, pady=(5, 20))

        # Configure grid
        status_grid.columnconfigure(0, weight=1)
        status_grid.columnconfigure(1, weight=1)
        status_grid.rowconfigure(0, weight=1)
        status_grid.rowconfigure(1, weight=1)

        # Create status indicators
        self.create_status_indicator(
            status_grid,
            "CPU Usage",
            "0%",
            self.colors["status_green"],
            0)
        self.create_status_indicator(
            status_grid,
            "Memory",
            "0%",
            self.colors["status_green"],
            1)
        self.create_status_indicator(
            status_grid,
            "Disk Space",
            "0%",
            self.colors["status_green"],
            2)
        self.create_status_indicator(
            status_grid,
            "Voice Status",
            "Idle",
            self.colors["status_gray"],
            3)

        return status_panel

    def create_status_indicator(self, parent, label, value, color, column):
        """Create a status indicator with label and value"""
        # Calculate row and column based on index
        row = column // 2
        col = column % 2

        # Create indicator frame
        indicator = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_light"],
            corner_radius=10,
            height=60
        )
        indicator.grid(row=row, column=col, sticky="nsew", padx=5, pady=5)
        indicator.pack_propagate(False)

        # Indicator label
        label_widget = ctk.CTkLabel(
            indicator,
            text=label,
            font=self.fonts["normal"],
            text_color=self.colors["text_normal"]
        )
        label_widget.pack(anchor="w", padx=15, pady=(10, 0))

        # Value and status indicator in a row
        value_frame = ctk.CTkFrame(indicator, fg_color="transparent")
        value_frame.pack(fill="x", padx=15, pady=(0, 10))

        # Value label
        value_widget = ctk.CTkLabel(
            value_frame,
            text=value,
            font=self.fonts["subtitle"],
            text_color=self.colors["text_bright"]
        )
        value_widget.pack(side="left")

        # Status indicator
        status_indicator = ctk.CTkFrame(
            value_frame,
            fg_color=color,
            width=15,
            height=15,
            corner_radius=7
        )
        status_indicator.pack(side="right", padx=10)

        # Store references for updating
        setattr(self, f"status_indicator_{column}", status_indicator)
        setattr(self, f"status_value_{column}", value_widget)

        return indicator

    def create_history_tab(self):
        """Create the history tab content"""
        history = self.tab_view.tab("History")
        
        # Configure grid
        history.grid_columnconfigure(0, weight=1)
        history.grid_rowconfigure(1, weight=1)  # List area expands
        
        # Title section
        title_frame = ctk.CTkFrame(history, fg_color="transparent")
        title_frame.grid(row=0, column=0, sticky="ew", padx=20, pady=(20, 10))
        
        # Configure title frame grid
        title_frame.grid_columnconfigure(1, weight=1)
        
        # Title
        title_label = ctk.CTkLabel(
            title_frame,
            text="Voice Command History",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        title_label.grid(row=0, column=0, sticky="w")
        
        # Clear history button
        clear_button = ctk.CTkButton(
            title_frame,
            text="Clear History",
            command=self.clear_history,
            fg_color=self.colors["accent_secondary"],
            hover_color=self.colors["accent_primary"],
            width=120
        )
        clear_button.grid(row=0, column=2, sticky="e")
        
        # History list
        self.history_frame = ctk.CTkScrollableFrame(
            history,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        self.history_frame.grid(row=1, column=0, sticky="nsew", padx=20, pady=(0, 20))
        
        # Configure history frame grid
        self.history_frame.grid_columnconfigure(0, weight=1)
        
        # Add header
        header = ctk.CTkFrame(
            self.history_frame,
            fg_color=self.colors["bg_dark"],
            corner_radius=10,
            height=40
        )
        header.grid(row=0, column=0, sticky="ew", pady=(0, 10))
        header.grid_propagate(False)
        
        # Configure header grid
        header.grid_columnconfigure((1, 2), weight=1)
        
        # Header labels
        labels = [("Time", 100), ("Command", None), ("Status", 100)]
        for i, (text, width) in enumerate(labels):
            label = ctk.CTkLabel(
                header,
                text=text,
                font=self.fonts["subtitle"],
                text_color=self.colors["text_bright"],
                width=width
            )
            label.grid(row=0, column=i, padx=20, pady=10, sticky="w" if i == 1 else "")
        
        # Add sample history items
        self.add_sample_history_items()
        
    def clear_history(self):
        """Clear all history items"""
        for widget in self.history_frame._scrollable_frame_children:
            if widget != list(self.history_frame._scrollable_frame_children.values())[0]:  # Skip header
                widget.destroy()
        
    def add_history_item(self, command, timestamp, status):
        """Add a single history item"""
        # Get next row index
        row = len(self.history_frame._scrollable_frame_children)
        
        # Create item frame
        item = ctk.CTkFrame(
            self.history_frame,
            fg_color=self.colors["bg_dark"],
            corner_radius=10,
            height=50
        )
        item.grid(row=row, column=0, sticky="ew", pady=5)
        item.grid_propagate(False)
        
        # Configure item grid
        item.grid_columnconfigure(1, weight=1)
        
        # Time
        time_label = ctk.CTkLabel(
            item,
            text=timestamp,
            font=self.fonts["small"],
            text_color=self.colors["text_dim"],
            width=100
        )
        time_label.grid(row=0, column=0, padx=20, pady=15)
        
        # Command
        command_label = ctk.CTkLabel(
            item,
            text=command,
            font=self.fonts["normal"],
            text_color=self.colors["text_bright"],
            anchor="w"
        )
        command_label.grid(row=0, column=1, padx=20, pady=15, sticky="w")
        
        # Status
        status_color = self.colors["status_green"] if status == "Success" else self.colors["status_red"]
        status_label = ctk.CTkLabel(
            item,
            text=status,
            font=self.fonts["small"],
            text_color=status_color,
            width=100
        )
        status_label.grid(row=0, column=2, padx=20, pady=15)
        
        # Add hover effect
        def on_enter(e):
            item.configure(fg_color=self.colors["bg_light"])
            
        def on_leave(e):
            item.configure(fg_color=self.colors["bg_dark"])
            
        item.bind("<Enter>", on_enter)
        item.bind("<Leave>", on_leave)
        
    def add_sample_history_items(self):
        """Add some sample history items"""
        samples = [
            ("What are the symptoms of hypertension?", "10:30:15", "Success"),
            ("Set a reminder for medication at 2 PM", "10:28:45", "Success"),
            ("Failed to recognize speech", "10:25:12", "Error"),
            ("Show my appointments for today", "10:20:30", "Success"),
            ("What are the side effects of aspirin?", "10:15:22", "Success")
        ]
        
        for command, time, status in samples:
            self.add_history_item(command, time, status)

    def create_config_tab(self):
        """Create the configuration tab content"""
        config = self.tab_view.tab("Configuration")
        
        # Configure grid
        config.grid_columnconfigure(0, weight=1)
        config.grid_rowconfigure(1, weight=1)  # Content area expands
        
        # Title section
        title_frame = ctk.CTkFrame(config, fg_color="transparent")
        title_frame.grid(row=0, column=0, sticky="ew", padx=20, pady=(20, 10))
        
        # Title
        title_label = ctk.CTkLabel(
            title_frame,
            text="Configuration",
            font=self.fonts["title"],
            text_color=self.colors["text_bright"]
        )
        title_label.pack(side="left")
        
        # Create scrollable content area
        content_frame = ctk.CTkScrollableFrame(
            config,
            fg_color="transparent"
        )
        content_frame.grid(row=1, column=0, sticky="nsew", padx=20, pady=(0, 20))
        
        # Configure content grid
        content_frame.grid_columnconfigure(0, weight=1)
        
        # Voice Recognition section
        voice_frame = self.create_config_section(
            content_frame,
            "Voice Recognition",
            [
                ("Language", "language_var", "combobox", ["English", "Spanish", "French", "German"]),
                ("Model", "model_var", "combobox", ["Whisper Base", "Whisper Small", "Whisper Medium", "Whisper Large"]),
                ("Continuous Recognition", "continuous_var", "switch", None),
                ("Wake Word", "wake_word_var", "entry", "Hey Dragon")
            ]
        )
        voice_frame.grid(row=0, column=0, sticky="ew", pady=(0, 10))
        
        # Audio Settings section
        audio_frame = self.create_config_section(
            content_frame,
            "Audio Settings",
            [
                ("Input Device", "input_device_var", "combobox", self.get_audio_devices()),
                ("Sample Rate", "sample_rate_var", "combobox", ["16000 Hz", "22050 Hz", "44100 Hz", "48000 Hz"]),
                ("Noise Reduction", "noise_reduction_var", "switch", None),
                ("Input Gain", "gain_var", "slider", (0.0, 2.0, 0.5))
            ]
        )
        audio_frame.grid(row=1, column=0, sticky="ew", pady=(0, 10))
        
        # Interface Settings section
        interface_frame = self.create_config_section(
            content_frame,
            "Interface Settings",
            [
                ("Theme", "theme_var", "combobox", ["Aurora", "Quantum", "Glacier"]),
                ("Font Size", "font_size_var", "slider", (8, 16, 12)),
                ("Show Notifications", "notifications_var", "switch", None),
                ("Minimize to Tray", "minimize_tray_var", "switch", None)
            ]
        )
        interface_frame.grid(row=2, column=0, sticky="ew", pady=(0, 10))
        
        # Advanced Settings section
        advanced_frame = self.create_config_section(
            content_frame,
            "Advanced Settings",
            [
                ("Log Level", "log_level_var", "combobox", ["DEBUG", "INFO", "WARNING", "ERROR"]),
                ("Max History Items", "max_history_var", "entry", "1000"),
                ("Debug Mode", "debug_mode_var", "switch", None)
            ]
        )
        advanced_frame.grid(row=3, column=0, sticky="ew", pady=(0, 10))
        
        # Action buttons
        button_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        button_frame.grid(row=4, column=0, sticky="e", pady=(10, 0))
        
        # Reset button
        reset_button = ctk.CTkButton(
            button_frame,
            text="Reset to Defaults",
            command=self.reset_config,
            fg_color=self.colors["bg_light"],
            hover_color=self.colors["bg_medium"],
            width=120
        )
        reset_button.pack(side="left", padx=10)
        
        # Save button
        save_button = ctk.CTkButton(
            button_frame,
            text="Save Changes",
            command=self.save_config,
            fg_color=self.colors["accent_primary"],
            hover_color=self.colors["accent_secondary"],
            width=120
        )
        save_button.pack(side="left")

    def create_config_section(self, parent, title, fields):
        """Create a configuration section with fields"""
        # Create section frame
        frame = ctk.CTkFrame(
            parent,
            fg_color=self.colors["bg_medium"],
            corner_radius=10
        )
        
        # Section title
        title_label = ctk.CTkLabel(
            frame,
            text=title,
            font=self.fonts["subtitle"],
            text_color=self.colors["text_bright"]
        )
        title_label.pack(anchor="w", padx=20, pady=(15, 10))
        
        # Add fields
        for label_text, var_name, field_type, options in fields:
            field_frame = ctk.CTkFrame(frame, fg_color="transparent")
            field_frame.pack(fill="x", padx=20, pady=5)
            
            # Label
            label = ctk.CTkLabel(
                field_frame,
                text=label_text,
                font=self.fonts["normal"],
                text_color=self.colors["text_normal"],
                width=150,
                anchor="w"
            )
            label.pack(side="left")
            
            # Create and store variable
            if not hasattr(self, var_name):
                if field_type == "switch":
                    setattr(self, var_name, ctk.BooleanVar(value=False))
                elif field_type == "slider":
                    setattr(self, var_name, ctk.DoubleVar(value=options[2]))
                else:
                    setattr(self, var_name, ctk.StringVar(value=options[0] if options else ""))
            
            # Create field
            if field_type == "combobox":
                field = ctk.CTkOptionMenu(
                    field_frame,
                    values=options,
                    variable=getattr(self, var_name),
                    width=200
                )
            elif field_type == "entry":
                field = ctk.CTkEntry(
                    field_frame,
                    textvariable=getattr(self, var_name),
                    width=200
                )
                if isinstance(options, str):
                    field.insert(0, options)
            elif field_type == "switch":
                field = ctk.CTkSwitch(
                    field_frame,
                    text="",
                    variable=getattr(self, var_name),
                    width=50,
                    switch_width=50,
                    switch_height=24,
                    fg_color=self.colors["bg_dark"],
                    progress_color=self.colors["accent_primary"]
                )
            elif field_type == "slider":
                min_val, max_val, default = options
                field = ctk.CTkSlider(
                    field_frame,
                    from_=min_val,
                    to=max_val,
                    variable=getattr(self, var_name),
                    width=200
                )
                # Add value label
                value_label = ctk.CTkLabel(
                    field_frame,
                    textvariable=getattr(self, var_name),
                    width=50,
                    font=self.fonts["small"],
                    text_color=self.colors["text_dim"]
                )
                value_label.pack(side="right", padx=5)
            
            field.pack(side="left", padx=5)
        
        return frame
        
    def get_audio_devices(self):
        """Get list of available audio input devices"""
        try:
            devices = sd.query_devices()
            input_devices = ["Default"]
            for i, device in enumerate(devices):
                if device['max_input_channels'] > 0:
                    input_devices.append(f"{device['name']} (ID: {i})")
            return input_devices
        except Exception as e:
            logging.error(f"Error getting audio devices: {str(e)}")
            return ["Default"]
            
    def reset_config(self):
        """Reset configuration to defaults"""
        # Reset each variable to its default value
        defaults = {
            "language_var": "English",
            "model_var": "Whisper Base",
            "continuous_var": False,
            "wake_word_var": "Hey Dragon",
            "input_device_var": "Default",
            "sample_rate_var": "16000 Hz",
            "noise_reduction_var": True,
            "gain_var": 0.5,
            "theme_var": "Aurora",
            "font_size_var": 12,
            "notifications_var": True,
            "minimize_tray_var": False,
            "log_level_var": "INFO",
            "max_history_var": "1000",
            "debug_mode_var": False
        }
        
        for var_name, default_value in defaults.items():
            if hasattr(self, var_name):
                getattr(self, var_name).set(default_value)
        
        self.update_status("Configuration reset to defaults")
        
    def save_config(self):
        """Save configuration changes"""
        try:
            # Update config dictionary
            self.config.update({
                "language": self.language_var.get(),
                "model": self.model_var.get(),
                "continuous_recognition": self.continuous_var.get(),
                "wake_word": self.wake_word_var.get(),
                "input_device": self.input_device_var.get(),
                "sample_rate": self.sample_rate_var.get(),
                "noise_reduction": self.noise_reduction_var.get(),
                "input_gain": self.gain_var.get(),
                "theme": self.theme_var.get(),
                "font_size": self.font_size_var.get(),
                "show_notifications": self.notifications_var.get(),
                "minimize_to_tray": self.minimize_tray_var.get(),
                "log_level": self.log_level_var.get(),
                "max_history_items": self.max_history_var.get(),
                "debug_mode": self.debug_mode_var.get()
            })
            
            # Save to file
            self.save_configuration()
            
            # Apply changes
            self.apply_config_changes()
            
            self.update_status("Configuration saved successfully")
            
        except Exception as e:
            logging.error(f"Error saving configuration: {str(e)}")
            self.update_status(f"Error saving configuration: {str(e)}", "error")
            
    def apply_config_changes(self):
        """Apply configuration changes that require immediate updates"""
        try:
            # Apply theme
            if self.theme_var.get() in self.color_schemes:
                self.apply_theme(self.theme_var.get())
            
            # Apply font size
            font_size = int(self.font_size_var.get())
            for name, font in self.fonts.items():
                font.configure(size=font_size)
            
            # Apply logging level
            logging.getLogger().setLevel(self.log_level_var.get())
            
            # Apply audio settings
            if hasattr(self, 'whisper_recognizer'):
                self.whisper_recognizer.set_input_device(self.input_device_var.get())
                self.whisper_recognizer.set_sample_rate(int(self.sample_rate_var.get().split()[0]))
                self.whisper_recognizer.set_noise_reduction(self.noise_reduction_var.get())
                self.whisper_recognizer.set_input_gain(self.gain_var.get())
            
            # Refresh UI
            self.refresh_ui()
            
        except Exception as e:
            logging.error(f"Error applying configuration changes: {str(e)}")
            self.update_status(f"Error applying changes: {str(e)}", "error")

    def show_settings(self):
        """Show settings tab"""
        if hasattr(self, 'tab_view'):
            self.tab_view.set("Configuration")
            
    def show_help(self):
        """Show help tab"""
        if hasattr(self, 'tab_view'):
            self.tab_view.set("Help")


def main():
    """Main function to run the application"""
    try:
        # Initialize logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            filename='dragon_gui.log',
            filemode='a'
        )

        # Add console handler
        console = logging.StreamHandler()
        console.setLevel(logging.INFO)
        formatter = logging.Formatter(
            '%(asctime)s - %(levelname)s - %(message)s')
        console.setFormatter(formatter)
        logging.getLogger('').addHandler(console)

        logging.info("Starting DragonVoice application")

        # Initialize Tkinter before creating the app
        root = ctk.CTk()
        root.withdraw()  # Hide the root window

        # Create and run the GUI
        logging.info("Initializing DragonVoiceGUI")
        app = DragonVoiceGUI()

        # Check for required methods
        required_methods = [
            'toggle_voice_assistant',
            'refresh_chatbots',
            'load_config']
        for method in required_methods:
            if not hasattr(app, method):
                logging.error(f"Missing required method: {method}")
                raise AttributeError(
                    f"DragonVoiceGUI is missing required method: {method}")

        logging.info("Starting application main loop")
        app.run()

    except Exception as e:
        logging.error(f"Error running application: {str(e)}", exc_info=True)
        print(f"Error: {str(e)}")

        # Show error in a messagebox if possible
        try:
            import tkinter.messagebox as messagebox
            messagebox.showerror(
                "Dragon Voice Error",
                f"An error occurred:\n{str(e)}")
        except BaseException:
            pass

        # Print traceback for debugging
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main()
